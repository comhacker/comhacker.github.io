<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CISCN2024wp</title>
    <url>/posts/55463/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="ezCsky"><a href="#ezCsky" class="headerlink" title="ezCsky"></a>ezCsky</h2><p>题目描述： 某个新能源汽车使用了国产的交叉编译链对tbox的固件程序进行了编译，你能通过逆向发现其中的秘密吗？</p>
<p>用DIE查看，这是一个elf文件</p>
<p>尝试用ida打开，发现他说“不包括处理器类型mcore”，点击ok就直接退出了</p>
<img src="/posts/55463/image-20241218215831091.png" class="" title="image-20241218215831091">

<p>查了一下题目描述中提到的交叉编译：<strong>交叉编译器</strong>（英语：Cross compiler）是指一个在某个系统平台下可以产生另一个系统平台系的可执行文件的编译器。没什么信息。</p>
<p>使用虚拟机里面的readelf工具查看该elf文件的信息：</p>
<h6 id="readelf工具"><a href="#readelf工具" class="headerlink" title="readelf工具"></a>readelf工具</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：readelf -x 文件名</span><br><span class="line">-h 或 --file-header：显示 ELF 文件头部的信息。*****</span><br><span class="line">-l 或 --program-headers，有时也用 -p：显示程序头部表的内容，这描述了文件如何映射到内存中。</span><br><span class="line">-S 或 --section-headers：显示节头部表的信息，即文件中各节的基本信息。</span><br><span class="line">-s 或 --syms：显示文件的符号表内容。*****</span><br><span class="line">-r 或 --relocs：显示重定位条目。</span><br><span class="line">-d 或 --dynamic：显示动态段的信息，这对于共享库或动态链接的可执行文件尤为重要。</span><br><span class="line">-n 或 --notes：显示任何存在的注释段落。</span><br><span class="line">-u 或 --unwind：显示 unwind 表格信息。</span><br><span class="line">-x SEC 或 --hex-dump=SEC：以十六进制转储指定节的内容。</span><br></pre></td></tr></table></figure>



<img src="/posts/55463/image-20241218220926597.png" class="" title="image-20241218220926597">

<p>发现MCORE架构的，也可以使用file命令：file + 文件名</p>
<img src="/posts/55463/image-20241218221522667.png" class="" title="image-20241218221522667">

<p>发现他是Motorola RCE架构的。</p>
<h6 id="计算机架构："><a href="#计算机架构：" class="headerlink" title="计算机架构："></a>计算机架构：</h6><p>Motorola RCE (RISC Core Engine)，全称为Motorola RISC Core Engine，是由 Motorola开发，基于 RISC 架构的处理器架构。</p>
<p>RISC是一种开源指令集架构。</p>
<p>指令集架构(ISA)是指定计算机硬件如何执行基本操作的一组规则和格式，而处理器架构（如ARM 架构和x86架构）是指处理器内部的具体设计实现，处理器架构必须遵循某个特定的 ISA。ISA 是一个更高层次的概念，定义了处理器应该如何工作；而处理器架构则是更具体的设计实现，描述了实际的硬件是如何构建来满足 ISA 的要求。</p>
<p>由此可以得知，这个elf使用了RISC架构，之前IDA无法反编译是选错了架构。</p>
<p>接着，继续使用readelf查看更多信息：</p>
<p>readelf -s 文件名  ：查看符号表</p>
<img src="/posts/55463/image-2024-12-18223425.png" class="" title="image-2024-12-18223425">

<p>注意到有xor函数、check函数和RC4加密。</p>
<p>接下来使用IDA反编译，需要先手动选择RISC架构：</p>
<img src="/posts/55463/image-2024-12-18223808.png" class="" title="image-2024-12-18223808">

<img src="/posts/55463/image2024-12-18223941.png" class="" title="image2024-12-18223941">

<p>由这里的RC4加密可以推知，’testkey’就是密钥，unk_8AA0就是密文</p>
<img src="/posts/55463/image-20241218224642852.png" class="" title="image-20241218224642852">

<p>直接RC4解密得不到flag，根据前面在符号表里面看到的东西，还有一个xor函数。</p>
<p>先尝试用”flag{“头来反推异或的密钥：</p>
<img src="/posts/55463/image-20241218224927370.png" class="" title="image-20241218224927370">

<p>发现推到的密钥很像flag，意味着它是flag自身进行前后异或。写脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">/*初始化函数*/</span><br><span class="line">void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    char k[256] = &#123; 0 &#125;;</span><br><span class="line">    unsigned char tmp = 0;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = (j + s[i] + k[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[i]和s[j]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">/*加解密*/</span><br><span class="line">void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0, t = 0;</span><br><span class="line">    unsigned long k = 0;</span><br><span class="line">    unsigned char tmp;</span><br><span class="line">    for (k = 0; k&lt;Len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i = (i + 1) % 256;</span><br><span class="line">        j = (j + s[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[x]和s[y]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t = (s[i] + s[j]) % 256;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char flag[]=</span><br><span class="line">    &#123;</span><br><span class="line">     	0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,</span><br><span class="line">        0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,</span><br><span class="line">        0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,</span><br><span class="line">        0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,</span><br><span class="line">        0xED, 0xD1</span><br><span class="line">    &#125;; </span><br><span class="line">    unsigned char key[]=&quot;testkey&quot;;</span><br><span class="line">    unsigned  char s[256]=&#123;0&#125;;</span><br><span class="line">    rc4_init(s,key,7);    //第三位是key长度 </span><br><span class="line">    rc4_crypt(s,flag,42);  //第三位是s长度 </span><br><span class="line">    int i;</span><br><span class="line">    for(i=40;i&gt;=0;i--)&#123;</span><br><span class="line">        flag[i]^=flag[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;42;i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; //flag&#123;d0f5b330-9a74-11ef-9afd-acde48001122&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP定律脱壳</title>
    <url>/posts/43303/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>加壳是利用特殊的算法事先对程序源代码进行压缩，并向程序里面注入解压的代码，这段解压代码会先于源代码执行。在程序执行时，会自动将原始代码进行解压，然后跳转到原程序的入口点，继续执行原程序。而在执行完解压过程后需要将栈恢复到解压前的状态，即ESP会回到解压前的位置，因此，我们可以通过判断ESP是否回到初始位置来判断程序是否已经达到入口点（OEP）。</p>
<p>接下来以脱upx壳为例：</p>
<p>程序源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char s[] = &quot;ek`fz`abcdefg|&quot;;</span><br><span class="line">	char input[15];</span><br><span class="line">	int i;</span><br><span class="line">	printf(&quot;请输入你的flag:\n&quot;);</span><br><span class="line">	scanf(&quot;%14s&quot;, input,sizeof(input));</span><br><span class="line">	for (i = 0; i &lt; 14; i++)</span><br><span class="line">		input[i] -= 1;</span><br><span class="line">	if (!strcmp(input, s))</span><br><span class="line">		printf(&quot;right!&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;wrong!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><p>一共分为三步：</p>
<ol>
<li>寻找OEP</li>
<li>dump出初步的脱壳程序</li>
<li>修复程序</li>
</ol>
<h2 id="1、寻找OEP"><a href="#1、寻找OEP" class="headerlink" title="1、寻找OEP"></a>1、寻找OEP</h2><p>使用xdbg打开</p>
<img src="/posts/43303/image-20241206232732823.png" class="" title="image-20241206232732823">

<p>可以看到开始就是pushad指令，这个指令是将所有寄存器都压入栈。</p>
<p>一般的壳都会在开始时进行压栈，然后在解压结束时进行出栈。</p>
<p>此时按F8单步步过，可以看到右边的ESP发生了变化</p>
<img src="/posts/43303/image-20241206232654462.png" class="" title="image-20241206232654462">

<p>点击右边ESP，按右键，选内存窗口中转到，内存1</p>
<img src="/posts/43303/image-20241206232906388.png" class="" title="image-20241206232906388">

<p>此时左下角的内存窗口已经转移到ESP的位置</p>
<img src="/posts/43303/image-20241206233019638.png" class="" title="image-20241206233019638">

<p>选定第一个字节，按右键，断点，硬件访问，接下来三个里面随便选一个</p>
<img src="/posts/43303/image-20241206233108832.png" class="" title="image-20241206233108832">

<p>此时下好了断点，按F9让程序一直运行直到断点处</p>
<img src="/posts/43303/image-20241211210508761.png" class="" title="image-20241211210508761">

<p>注意此时的ESP回到了刚用xdbg打开时的值0x0061FF78，此时壳已经解压完了，那么下一个大的跳转就是跳转到OEP处。</p>


<p>在跳转到OEP前有一段往回退的代码，我们需要跳过这段代码执行到jmp那里。</p>
<p>单击0041E963 处的jmp u.4014E0指令对其选定，按F4就停在了这个地址处，接下来按F8往后运行一步，直接跳转到了0x4014E0地址处，这里就是OEP（程序入口点）<img src="/posts/43303/image-20241211211507576.png" class="" title="image-20241211211507576"></p>
<h2 id="2、dump出初步的脱壳程序"><a href="#2、dump出初步的脱壳程序" class="headerlink" title="2、dump出初步的脱壳程序"></a>2、dump出初步的脱壳程序</h2><p>先点击上方的断点窗口，这里会把所有断点列出来</p>


<img src="/posts/43303/image-20241211211858516.png" class="" title="image-20241211211858516">

<p>单击一下刚才设置的断点，按右键，选择删除断点</p>
<img src="/posts/43303/image-20241211211951774.png" class="" title="image-20241211211951774">

<p>回到cpu窗口，此时的程序是脱壳完成的程序，点击上面第二排的scylla工具</p>
<img src="/posts/43303/image-20241211212248223.png" class="" title="image-20241211212248223">

<img src="/posts/43303/image-20241211212600034.png" class="" title="image-20241211212600034">

<p>点击dump，会生成一个dump.exe文件.</p>
<h2 id="3、修复程序"><a href="#3、修复程序" class="headerlink" title="3、修复程序"></a>3、修复程序</h2><p>此时的生成的exe文件还是有问题的文件，可能会运行失败，因为脱壳过程可能会改变程序的数据段、导入表、导出表等内容。所以需要将这些表格和数据恢复到脱壳前的状态，确保程序能够正确加载所需的库和函数。</p>
<p>还是刚才那个Scylla插件，点击IAT Autosearch、Get Imports</p>
<img src="/posts/43303/image-20241211213131379.png" class="" title="image-20241211213131379">

<img src="/posts/43303/image-20241211213238362.png" class="" title="image-20241211213238362">

<p>此时按Fix Dump，选择刚才dump出的dump.exe文件，点打开</p>
<img src="/posts/43303/image-20241211213350764.png" class="" title="image-20241211213350764">

<p>此时会在相同目录下生成一个dump_SCY.exe文件，这个就是脱壳完成的程序。</p>
]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>GHCTF</title>
    <url>/posts/18925/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="ASM-Signin"><a href="#ASM-Signin" class="headerlink" title="ASM?Signin!"></a>ASM?Signin!</h1><p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void swap(unsigned char a[],int l,int h)&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    unsigned char temp;</span><br><span class="line">    for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">      temp=a[l];</span><br><span class="line">      a[l]=a[h];</span><br><span class="line">      a[h]=temp;</span><br><span class="line">      l++;</span><br><span class="line">      h++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned char data1[33]=&#123;0x26,0x27,0x24,0x25,0x2A,0x2B,0x28,0x00,</span><br><span class="line">        0x2E,0x2F,0x2C,0x2D,0x32,0x33,0x30,0x00,</span><br><span class="line">        0x36,0x37,0x34,0x35,0x3A,0x3B,0x38,0x39,</span><br><span class="line">        0x3E,0x3F,0x3C,0x3D,0x3F,0x27,0x34,0x11&#125;;</span><br><span class="line">    int i=0,j=0,k=0;</span><br><span class="line">    for(k=0;k&lt;8;k++)&#123;    //错位交换部分</span><br><span class="line">        j=i;</span><br><span class="line">        j+=4;</span><br><span class="line">        if(j&gt;=28) j-=28;</span><br><span class="line">        swap(data1,i,j);</span><br><span class="line">        i+=4;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char data2[]=&#123;0x69,0x77,0x77,0x66,0x73,0x72,0x4F,0x46,</span><br><span class="line">                           0x03,0x47,0x6F,0x79,0x07,0x41,0x13,0x47,</span><br><span class="line">                           0x5E,0x67,0x5F,0x09,0x0F,0x58,0x63,0x7D,</span><br><span class="line">                           0x5F,0x77,0x68,0x35,0x62,0x0D,0x0D,0x50&#125;;</span><br><span class="line">    for(i=31;i&gt;0;i-=4)&#123;     //错位异或解密部分</span><br><span class="line">        data2[i]^=data1[i];</span><br><span class="line">        data2[i-1]^=data1[i-1];</span><br><span class="line">        data2[i-2]^=data1[i-1];</span><br><span class="line">        data2[i-3]^=data1[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;32;i++) printf(&quot;%c&quot;,data2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FishingKit"><a href="#FishingKit" class="headerlink" title="FishingKit"></a>FishingKit</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void encrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k1,k2,k3;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x9E3779B9,sum=0;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=delta;</span><br><span class="line">		v0+=((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">		v1+=((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); </span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">void decrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k2,k3,k1;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x66778899,v5=0x66778899*24;</span><br><span class="line">	for(int i=0;i&lt;24;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 -= (key[(v5 &gt;&gt; 11) &amp; 3] + v5) ^ (v0 + ((v0 &gt;&gt; 5) ^ (16 * v0)));</span><br><span class="line">        v5 -= 0x66778899;</span><br><span class="line">        v0 -= (key[v5 &amp; 3] + v5) ^ (v1 + ((v1 &gt;&gt; 5) ^ (16 * v1)));</span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char s[24]=&#123;0x21, 0x56, 0x97, 0xA6, 0x1A, 0xD5, 0xC4, 0xDE, 0xA4, 0x9C, </span><br><span class="line">                        0x82, 0x4D, 0xD1, 0x45, 0xC8, 0x56, 0xA7, 0xB4, 0x96, 0x5C, </span><br><span class="line">                        0x4D, 0x49, 0x87, 0x20&#125;;</span><br><span class="line">	uint32_t key[4]=&#123;0x756C6544,0x61426578,0x7469,0x0&#125;;</span><br><span class="line">	for(int i=0;i&lt;24;i+=8)</span><br><span class="line">	&#123;</span><br><span class="line">		decrypt((uint32_t*)&amp;s[i],key);	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%s&quot;,s);		  </span><br><span class="line"> &#125; //NSSCTF&#123;Wh@t_@_b1g_F1sh&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LockedSecret"><a href="#LockedSecret" class="headerlink" title="LockedSecret"></a>LockedSecret</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void decrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k2,k3,k1;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0]^0xf,v1=v[1]^0xf;</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x5E2377FF,sum=0x5E2377FF*8;</span><br><span class="line">	for(int i=0;i&lt;8;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1-=(key[3]+(v0&gt;&gt;5))^(v0+sum)^(key[2]+16*v0);</span><br><span class="line">		v0-=(key[1]+(v1&gt;&gt;5))^(v1+sum)^(key[0]+16*v1);</span><br><span class="line">		sum-=delta;</span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t s[32]=&#123;0xDC, 0x45, 0x1E, 0x03, 0x89, 0xE9, 0x76, 0x27, 0x47, 0x48, </span><br><span class="line">        0x23, 0x01, 0x70, 0xD2, 0xCE, 0x64, 0xDA, 0x7F, 0x46, 0x33, </span><br><span class="line">        0xB1, 0x03, 0x49, 0xA3, 0x27, 0x00, 0xD1, 0x2C, 0x37, 0xB3, </span><br><span class="line">        0xBD, 0x75 &#125;;</span><br><span class="line">	uint32_t key[4]=&#123;0x423DF72D, 0x5F59A01, 0x633FCF1D, 0x77D19122&#125;;</span><br><span class="line">	for(int i=0;i&lt;4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		decrypt((uint32_t*)&amp;s[i*8],key);	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%s&quot;,s);		  </span><br><span class="line"> &#125; // NSSCTF&#123;!!!Y0u_g3t_th3_s3cr3t!!!&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF2024</title>
    <url>/posts/42198/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>去花之后重新识别得到一个加密函数，解密出来是fakeflag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void xor(unsigned char *data)&#123;</span><br><span class="line">  int i;</span><br><span class="line">  char c[]=&quot;Laughter_is_poison_to_fear&quot;;</span><br><span class="line">  for(i=0;i&lt;48;i++)&#123;</span><br><span class="line">    printf(&quot;%c&quot;,data[i]^c[i%26]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void encrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k1,k2,k3;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x9E3779B9,sum=0;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=delta;</span><br><span class="line">		v0+=((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">		v1+=((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); </span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">void decrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k2,k3,k1;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x61C88647,sum=0-0x61C88647*32;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 -= (sum + key[(sum &gt;&gt; 11) &amp; 3]) ^ (v0 + ((16 * v0) ^ (v0 &gt;&gt; 5)));</span><br><span class="line">		sum += 0x61C88647;</span><br><span class="line">		v0 -= (sum + key[sum &amp; 3]) ^ (v1 + ((16 * v1) ^ (v1 &gt;&gt; 5)));</span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char s[50]=&#123;</span><br><span class="line">    0xc2,0x39,0x3f,0xf7,0xeb,0x24,0x94,0x4d,0x99,0x41,</span><br><span class="line">    0x7e,0xfc,0x41,0x79,0xab,0xc8,0x5e,0xd0,0x3b,0xd7,</span><br><span class="line">    0x85,0x63,0xd3,0x1d,0xcb,0x98,0x5a,0x6,0x21,0x8b,</span><br><span class="line">    0xa3,0xd8,0xe3,0x86,0x1a,0x37,0x4a,0x8a,0x5c,0xd2,</span><br><span class="line">    0x53,0xcb,0x14,0x3c,0x89,0xeb,0x71,0xeb</span><br><span class="line">    &#125;;</span><br><span class="line">	char key[]=&quot;&#123;you_find_it_!?&#125;&quot;;</span><br><span class="line">	for(int i=0;i&lt;48;i+=8)</span><br><span class="line">	&#123;</span><br><span class="line">		decrypt((uint32_t*)&amp;s[i],(uint32_t*)key);	</span><br><span class="line">	&#125;</span><br><span class="line">	// printf(&quot;%s&quot;,s);	</span><br><span class="line">  xor(s);	  </span><br><span class="line"> &#125; fakeflag_plz_Try_more_hard_to_find_the_true_flag</span><br></pre></td></tr></table></figure>

<p>没有其他信息，动调看看</p>
<p>发现在执行完了该加密函数后调转到了另一个函数</p>
<img src="/posts/42198/image-20241228163913938.png" class="" title="image-20241228163913938">

<p>经过这个SMC，动调到第14行，单步步入（F7）。</p>
<p>跳转到了一堆汇编代码</p>
<img src="/posts/42198/image-20241228164136913.png" class="" title="image-20241228164136913">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug042:005D1020 db    0</span><br><span class="line">debug042:005D1021 ; ---------------------------------------------------------------------------</span><br><span class="line">debug042:005D1021 mov     ecx, 77h ; &#x27;w&#x27;</span><br><span class="line">debug042:005D1026 call    $+5   //将下一条指令入栈</span><br><span class="line">debug042:005D102B pop     ebx  // 执行完后ebx=005D102B</span><br><span class="line">debug042:005D102C mov     [ebx-0Bh], cl   // 将0x77存在[ebx-b](即005D1020)处</span><br><span class="line">debug042:005D102F push    ebp </span><br><span class="line">debug042:005D1030 pusha        		//将所有通用寄存器入栈</span><br><span class="line">debug042:005D1031 pushf				//将所有标志寄存器入栈</span><br><span class="line">debug042:005D1032 call    $+5</span><br><span class="line">debug042:005D1037 pop     eax   //将本指令地址传给eax</span><br><span class="line">debug042:005D1038 xor     edx, edx</span><br><span class="line">debug042:005D103A mov     dl, [eax-17h]  //将[eax-17](即005D1020)里面的值(0x77)赋值到edx低位</span><br><span class="line">debug042:005D1040 xor     edx, 1D82h   		</span><br><span class="line">debug042:005D1046 lea     ebx, [eax+edx]	//计算eax+edx的值，赋值给ebx</span><br><span class="line">debug042:005D1049 mov     ecx, 35h ; &#x27;5&#x27;    //将0x55赋值给ecx，为下一段汇编代码做准备</span><br><span class="line">debug042:005D104E mov     byte ptr [eax-17h], 0   //将005D1020处重新填回0</span><br><span class="line">debug042:005D1055 jmp     ebx 		//跳到005D2E2C处</span><br></pre></td></tr></table></figure>

<p>这一段汇编大部分都是为了跳转做准备，除了005D102F处的push    ebp 。接下来看005D2E2C处：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug042:005D2E2B db  35h ; 5</span><br><span class="line">debug042:005D2E2C ; ---------------------------------------------------------------------------</span><br><span class="line">debug042:005D2E2C call    $+5</span><br><span class="line">debug042:005D2E31 pop     ebx   //获取当前指令地址</span><br><span class="line">debug042:005D2E32 mov     [ebx-6], cl   //将0x35赋值给[ebx-6](即005D2E2B)处</span><br><span class="line">debug042:005D2E35 popf   		//通用寄存器出栈，对应前面一段汇编的压栈</span><br><span class="line">debug042:005D2E36 popa</span><br><span class="line">debug042:005D2E37 mov     ebp, esp</span><br><span class="line">debug042:005D2E39 pusha</span><br><span class="line">debug042:005D2E3A pushf</span><br><span class="line">debug042:005D2E3B call    $+5</span><br><span class="line">debug042:005D2E40 pop     eax</span><br><span class="line">debug042:005D2E41 xor     edx, edx</span><br><span class="line">debug042:005D2E43 mov     dl, [eax-15h]</span><br><span class="line">debug042:005D2E49 xor     edx, 1A12h</span><br><span class="line">debug042:005D2E4F lea     ebx, [eax+edx]</span><br><span class="line">debug042:005D2E52 mov     ecx, 69h ; &#x27;i&#x27;     //将0x69赋值给ecx，为下一段汇编代码做准备</span><br><span class="line">debug042:005D2E57 mov     byte ptr [eax-15h], 0</span><br><span class="line">debug042:005D2E5E jmp     ebx</span><br></pre></td></tr></table></figure>

<p>这一段也就是005D2E37处的mov     ebp, esp有用，其他就是为下一次跳转做准备</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/posts/10764/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>不使用结构体来创建完全二叉树:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">uint64_t *creat_re(char *s,int index)&#123;  // 递归方式创建完全二叉树</span><br><span class="line">	if(index&gt;=strlen(s)) return NULL;</span><br><span class="line">	uint64_t *temp=(uint64_t *)malloc(24);</span><br><span class="line">	if (temp == NULL) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Memory allocation failed!\n&quot;);</span><br><span class="line">        exit(1);  // 如果分配失败，退出程序</span><br><span class="line">    &#125;</span><br><span class="line">	*(char *)temp=s[index];</span><br><span class="line">	temp[1]=(uint64_t)creat_re(s,index*2+1);</span><br><span class="line">	temp[2]=(uint64_t)creat_re(s,index*2+2);</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">uint64_t *newnode(char c)&#123;  // 非递归方式创建完全二叉树的单个结点</span><br><span class="line">	uint64_t *temp=(uint64_t *)malloc(24);</span><br><span class="line">	*(char *)temp=c;</span><br><span class="line">	temp[1]=temp[2]=0;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">uint64_t *create(char *s)&#123;  // 非递归方式创建完全二叉树</span><br><span class="line">	uint64_t *list[100];</span><br><span class="line">	uint64_t *temp;</span><br><span class="line">	int len=strlen(s);</span><br><span class="line">	int i=1,j=1,k=0;</span><br><span class="line">	list[0]=newnode(s[0]);</span><br><span class="line">	while(i&lt;len)&#123;</span><br><span class="line">		temp=list[k++];</span><br><span class="line">		temp[1]=(uint64_t)newnode(s[i++]);</span><br><span class="line">		list[j++]=(uint64_t *)temp[1];</span><br><span class="line">		if(i&gt;=len) break;</span><br><span class="line">		temp[2]=(uint64_t)newnode(s[i++]);</span><br><span class="line">		list[j++]=(uint64_t *)temp[2];</span><br><span class="line">	&#125;</span><br><span class="line">	return list[0];</span><br><span class="line">&#125;</span><br><span class="line">void pre_travel(uint64_t *n)&#123;  // 前序遍历</span><br><span class="line">	if(n==NULL) return;</span><br><span class="line">	printf(&quot;%c&quot;,*(char *)n);</span><br><span class="line">	pre_travel((uint64_t *)n[1]);</span><br><span class="line">	pre_travel((uint64_t *)n[2]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char s[]=&quot;1234567&quot;;</span><br><span class="line">	int i;</span><br><span class="line">	uint64_t *temp;</span><br><span class="line">	// temp=creat_re(s,0);</span><br><span class="line">	temp=create(s);</span><br><span class="line">	pre_travel(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于中序遍历和后序遍历序列还原完全二叉树结构，输出层次遍历序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define num 26</span><br><span class="line">char mid[] = &quot;ja7Cws_A3daTd4qDo8&#125;F_Sd&#123;a&quot;;</span><br><span class="line">char post[] = &quot;j7aw_sC3addq4TAo&#125;8_Fda&#123;SD&quot;;</span><br><span class="line">// 目标：给出中序遍历和后序遍历序列，求出完全二叉树结构（打印出层次遍历序列）</span><br><span class="line">typedef struct tree</span><br><span class="line">&#123;</span><br><span class="line">	char c;</span><br><span class="line">	struct tree *left,*right;</span><br><span class="line">&#125;tree;</span><br><span class="line">tree *creat(int ms,int me,int ps,int pe)&#123;   // 反推树的结构</span><br><span class="line">	if(ms&gt;me||ps&gt;pe) return NULL;</span><br><span class="line">	tree *t=(tree  *)malloc(sizeof(tree));</span><br><span class="line">	char charAt=post[pe];</span><br><span class="line">	int i;</span><br><span class="line">	for(i=ms;i&lt;=me&amp;&amp;mid[i]!=charAt;i++) &#123;&#125;</span><br><span class="line">	t-&gt;c=charAt;</span><br><span class="line">	t-&gt;left=creat(ms,i-1,ps, ps + i - ms - 1);</span><br><span class="line">	t-&gt;right=creat(i+1,me, ps + i - ms,pe-1);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">void pre_travel(tree *t)&#123;    // 前序遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	printf(&quot;%c&quot;,t-&gt;c);</span><br><span class="line">	pre_travel(t-&gt;left);</span><br><span class="line">	pre_travel(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">// 层次遍历</span><br><span class="line">typedef struct q&#123;  // 创建队列</span><br><span class="line">	tree *c[num];</span><br><span class="line">	int r,f;</span><br><span class="line">&#125;queue;</span><br><span class="line">void init(queue *q)&#123;   //初始化队列</span><br><span class="line">	q-&gt;r=q-&gt;f=0;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q,tree *t) &#123; // 入队</span><br><span class="line">	if((q-&gt;f+1)%num==q-&gt;r) &#123;printf(&quot;队满！\n&quot;);return;&#125;</span><br><span class="line">	q-&gt;c[q-&gt;f]=t;</span><br><span class="line">	q-&gt;f=(q-&gt;f+1)%num;</span><br><span class="line">&#125;</span><br><span class="line">tree *dequeue(queue *q) &#123;  // 出队</span><br><span class="line">	if(q-&gt;f==q-&gt;r) &#123;printf(&quot;队空！\n&quot;);return NULL;&#125;</span><br><span class="line">	tree *temp=q-&gt;c[q-&gt;r];</span><br><span class="line">	q-&gt;r=(q-&gt;r+1)%num;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void level_travel(tree *t)&#123;  //  层次遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	queue *q=(queue *)malloc(sizeof(queue));</span><br><span class="line">	tree *temp;</span><br><span class="line">	init(q);</span><br><span class="line">	enqueue(q,t);</span><br><span class="line">	while(q-&gt;f!=q-&gt;r)&#123;</span><br><span class="line">		temp=dequeue(q);</span><br><span class="line">		printf(&quot;%c&quot;,temp-&gt;c);</span><br><span class="line">		if(temp-&gt;left!=NULL) enqueue(q,temp-&gt;left);</span><br><span class="line">		if(temp-&gt;right!=NULL) enqueue(q,temp-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	free(q);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	tree *t=creat(0,strlen(mid)-1,0,strlen(post)-1);</span><br><span class="line">	// pre_travel(t);</span><br><span class="line">	level_travel(t);</span><br><span class="line">&#125;</span><br><span class="line">//层次遍历结果: DASCTF&#123;asd48_daj7w_3adqo&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用过程</title>
    <url>/posts/24481/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int add(int a,int b)&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    x=a,y=b;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a=1,b=2;</span><br><span class="line">    printf(&quot;%d&quot;,add(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来放入x32dbg里面调试，看到：</p>
<img src="/posts/24481/image-20241204220215454.png" class="" title="image-20241204220215454">

<p>先从main函数开始看。</p>
<p>创建新的堆栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure>

<p>先把主函数堆栈中的ebp指针压入栈，在将主函数中的esp赋值给ebp经过这样的操作，会在原先的堆栈上新建一个堆栈供被调函数用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub esp,20</span><br></pre></td></tr></table></figure>

<p>为变量开辟0x20字节的新空间</p>
<img src="/posts/24481/image-20241204222756002.png" class="" title="image-20241204222756002">

<p>变量赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dword ptr ss:[esp+1C],1             //a=1</span><br><span class="line">mov dword ptr ss:[esp+18],2             //b=2</span><br></pre></td></tr></table></figure>

<p>接下来时函数调用。调用过程主要分两部分：1、主函数部分。2、被调函数部分。</p>
<h1 id="主函数部分："><a href="#主函数部分：" class="headerlink" title="主函数部分："></a>主函数部分：</h1><h2 id="1、参数压入栈"><a href="#1、参数压入栈" class="headerlink" title="1、参数压入栈"></a>1、参数压入栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040153A | 8B4424 18                  | mov eax,dword ptr ss:[esp+18]           |b-&gt;eax</span><br><span class="line">0040153E | 894424 04                  | mov dword ptr ss:[esp+4],eax            |eax-&gt;[esp+4]</span><br><span class="line">00401542 | 8B4424 1C                  | mov eax,dword ptr ss:[esp+1C]           |a-&gt;eax</span><br><span class="line">00401546 | 890424                     | mov dword ptr ss:[esp],eax              |eax-&gt;[esp]</span><br></pre></td></tr></table></figure>



<p>注意到压入栈的顺序与参数顺序是相反的，调用时add(a,b)，但是b先入栈，a后入。</p>
<h2 id="2、调用函数"><a href="#2、调用函数" class="headerlink" title="2、调用函数"></a>2、调用函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401549 | E8 B2FFFFFF                | call &lt;test.add&gt;                         |</span><br></pre></td></tr></table></figure>

<p>在执行call语句时，ESP发生了改变</p>
<img src="/posts/24481/image-20241204225304838.png" class="" title="image-20241204225304838">

<p>是将0x40154E压入了栈，而这正是00401549+5，即call指令的下一条指令。</p>
<p>所以实际上在执行“call &lt;test.add&gt; ”时，可以拆解为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x40154E</span><br><span class="line">jmp  0x401500</span><br></pre></td></tr></table></figure>

<h1 id="被调函数部分："><a href="#被调函数部分：" class="headerlink" title="被调函数部分："></a>被调函数部分：</h1><h2 id="1、创建新堆栈"><a href="#1、创建新堆栈" class="headerlink" title="1、创建新堆栈"></a>1、创建新堆栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401500 | 55                         | push ebp                                |</span><br><span class="line">00401501 | 89E5                       | mov ebp,esp                             |</span><br></pre></td></tr></table></figure>

<p>先将原栈底入栈，在将新栈底设置为原栈顶，即：</p>


<p>这个时候ESP和EBP都在0x61FE78处，再执行压栈出栈也不会影响到主函数堆栈</p>
<h2 id="2、为参数预留空间"><a href="#2、为参数预留空间" class="headerlink" title="2、为参数预留空间"></a>2、为参数预留空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401503 | 83EC 10                    | sub esp,10                       //空出0x10字节的空间</span><br></pre></td></tr></table></figure>

<h2 id="3、取出形参"><a href="#3、取出形参" class="headerlink" title="3、取出形参"></a>3、取出形参</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401506 | 8B45 08                    | mov eax,dword ptr ss:[ebp+8]            |</span><br><span class="line">00401509 | 8945 FC                    | mov dword ptr ss:[ebp-4],eax            | </span><br><span class="line">0040150C | 8B45 0C                    | mov eax,dword ptr ss:[ebp+C]            |</span><br><span class="line">0040150F | 8945 F8                    | mov dword ptr ss:[ebp-8],eax            |</span><br></pre></td></tr></table></figure>

<p>这里的[EBP+8]处是main函数压入的第二个参数（即1），[EBP+C]是main函数压入的第一个参数（即2）</p>
<img src="/posts/24481/image-20241204231114451.png" class="" title="image-20241204231114451">

<h2 id="4、返回值"><a href="#4、返回值" class="headerlink" title="4、返回值"></a>4、返回值</h2><p>在大多数情况，函数的返回值并不是压入栈，而是存储在寄存器eax之中</p>
<h2 id="5、函数结束"><a href="#5、函数结束" class="headerlink" title="5、函数结束"></a>5、函数结束</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040151A | C9                         | leave                                   |</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>

<p>ESP和EBP都调回了跳转前的位置。然后接下来还要返回main函数里面，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040151B | C3                         | ret                                     |</span><br></pre></td></tr></table></figure>

<p>在执行ret或retn时，等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure>

<p>先将之前存储的下一条指令的地址弹出到rip之中，指示 CPU 下一条指令应该从哪里开始执行，然后就会回到main函数里面（rip里的位置）</p>
<p><strong><u>经历了上面两步，ESP和EBP会回到调用函数前的位置，这就是堆栈平衡。</u></strong></p>
<h1 id="堆栈平衡与手动脱壳："><a href="#堆栈平衡与手动脱壳：" class="headerlink" title="堆栈平衡与手动脱壳："></a>堆栈平衡与手动脱壳：</h1><p>加壳原理其实与SMC自修改代码有相同之处，加壳其实就是对可执行文件进行压缩或加密，并在程序里面加入解压或解密的必要代码的过程。当程序运行起来时，壳会加载并执行一个解包过程，最终将原始代码加载到内存中并跳转到入口点开始正常执行。这类似于函数调用，于是脱壳的关键就是找到壳解包完成的时机，然后dump下来。在调用壳解包的代码时，满足函数调用的堆栈平衡定理（ESP定理），于是我们可以观察其ESP和EBP的位置，当壳解包完成时，ESP指针会回到执行解密程序之前的值，程序执行一个大的跳转跳到程序入口点(EP点），此时dump下来就可以得到脱壳后的可执行文件。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>古剑山2024wp</title>
    <url>/posts/26315/</url>
    <content><![CDATA[<h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><img src="/posts/26315/image-20241223224830088.png" class="" title="image-20241223224830088">

<p>有壳，显示vmp壳，也无法判断是不是其他壳魔改的，于是直接使用ESP定律手动脱壳。</p>
<img src="/posts/26315/image-20241223224948607.png" class="" title="image-20241223224948607">

<p>这个壳与其他的有一点不一样，上面这段汇编都是没用的，压入后立马又弹出，并没用实际压入参数，所以是混淆视听的。要等到下面那个jmp re.c9970才是壳的开始。我们单步直到它跳转:</p>
<img src="/posts/26315/image-20241223225312656.png" class="" title="image-20241223225312656">

<p>接下来就是正常的脱壳了。</p>
<img src="/posts/26315/image-20241223225911496.png" class="" title="image-20241223225911496">

<p>修复的时候有一个地方修复不了，这个地方要手动用ida修复。</p>
<img src="/posts/26315/image-20241223230212596.png" class="" title="image-20241223230212596">

<p>这里函数提前结束了，看这里的汇编指令就知道这个是垃圾代码，花指令，全部nop掉这三行，再重新分析即可</p>
<img src="/posts/26315/image-20241223230500326.png" class="" title="image-20241223230500326">

<p>反编译</p>
<img src="/posts/26315/image-20250120000614004.png" class="" title="image-20250120000614004">

<p>图中27-28这个循环是将输入存入数组v8中，然后调用sub_131150进行判断。</p>
<img src="/posts/26315/image-20250120000324099.png" class="" title="image-20250120000324099">

<p>这个函数传入了两个参数，但是看不出来是哪两个参数，于是采用动态法</p>
<img src="/posts/26315/image-20250120000428243.png" class="" title="image-20250120000428243">

<p>发现a1对应的是v8,a2对应的是v7</p>
<img src="/posts/26315/image-20250120000804414.png" class="" title="image-20250120000804414">

<p>第15行就是将v7[25]的地址赋值给v2，v7是“cedfz16az31zd2dycy65ac41flag”，v7[25]即是”f”。开始将v8的前四个字符与v7的25-28处的字符进行对比，即得到v8（也就是flag）前4位是”flag”。下面26-42是对byte_135018进行变换（’y’变为’7’，’z’变为’8’）然后将v8[5]开始的8个字符与byte_135018进行对比，至此得到：”flag{de21c847”</p>
<img src="/posts/26315/image-20250120001457692.png" class="" title="image-20250120001457692">

<p>下面的43-64是将v8[13]后面的字符与v7变换后（y变7，z变8）的前24个字符进行比较，因此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;de21c847cedf816a8318d2d7c765ac41&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>导入表、导出表、重定位表</title>
    <url>/posts/26540/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>PE文件需要用到其他库里面的函数时，需要有一个导入表来记录这些导入函数的地址。</p>
<p>导入表的的地址存储在可选PE头最后一个成员——DataDirectory数组的第二个元素，即DataDirectory[1].</p>
<p>导入表实际上是结构体<strong>数组</strong>，它由许多个<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体组成，每一个外部库需要一个结构体，在所有结构的最后,由一个内容全为0的<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体作为结束标志。每一个结构体成员如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">  union &#123;</span><br><span class="line">    DWORD  Characteristics;      </span><br><span class="line">    DWORD  OriginalFirstThunk;     // 指向导入名称表(INT，import name table)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">  DWORD  TimeDateStamp;        </span><br><span class="line">  DWORD  ForwarderChain;         </span><br><span class="line">  DWORD  Name;					// 该库名字的地址</span><br><span class="line">  DWORD  FirstThunk;           // 指向导入地址表(IAT，import address table)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>IAT(导入函数地址表)和INT(导入函数名称表)，都是是一个结构体数组，它的成员都是<code>IMAGE_THUNK_DATA</code>结构的结构体。与导入表相似，IAT、INT也是以一个全为0的结构体结尾。<code>IMAGE_THUNK_DATA</code>结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_THUNK_DATA32</span><br><span class="line">&#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD ForwarderString;      // 转发字符串的RAV</span><br><span class="line">        DWORD Function;             // 被导入函数的地址</span><br><span class="line">        DWORD Ordinal;              // 被导入函数的序号</span><br><span class="line">        DWORD AddressOfData;        // 指向输入名称表 PIMAGE_IMPORT_BY_NAME</span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p>这是一个联合体，只有一个成员有效，一共占4个字节。当结构体的最高位为1时,表示函数是以序号的方式导入的,这时结构体的低位就是函数的序号；当双字最高位为0时,表示函数以函数名方式导入,这时结构体的值是一个RVA,指向一个用来定义导入函数名称的<code>IMAGE_IMPORT_BY_NAME</code>结构,此结构定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_BY_NAME</span><br><span class="line">&#123;</span><br><span class="line">    WORD    Hint;          // 函数序号</span><br><span class="line">    CHAR   Name[1];        // 导入函数的名称</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>当dll加载进内存之后，<code>IMAGE_THUNK_DATA</code>会将导入函数地址填入Function里面，此时这个结构体的4个字节就是一个指向导入函数的地址（RVA），使得程序可以直接通过这个地址来调用函数。</p>
<p><strong>导入表在文件中时：</strong></p>
<img src="/posts/26540/88bdc5cc50237f48060afe4af0c3107f.jpeg" class="" title="img">

<p>上例中一共有4个导入函数，前3个是以名字导入，第4个是以序号导入。此时INT和IAT结构是相同的。</p>
<p><strong>导入完成后的导入表：</strong></p>
<img src="/posts/26540/00110338f2667ee48574243bcec1ccb5.jpeg" class="" title="img">

<h3 id="导入流程："><a href="#导入流程：" class="headerlink" title="导入流程："></a>导入流程：</h3><p>导入dll库分为两种方法：<strong>静态导入和动态导入</strong>。</p>
<h4 id="静态导入："><a href="#静态导入：" class="headerlink" title="静态导入："></a><strong>静态导入：</strong></h4><ol>
<li><strong>编译和链接阶段</strong>：<ul>
<li><strong>创建导入表</strong>：链接器根据对象文件中的外部符号引用，创建 PE 文件的导入表。</li>
<li><strong>添加占位符</strong>：对于每个导入的函数，在 IAT 中会有一个占位符，它将在运行时由 Windows 加载器替换为实际的函数地址。</li>
</ul>
</li>
<li><strong>每次启动时</strong>：<ul>
<li><strong>重新解析导入表</strong>：当程序启动时，Windows 加载器会读取 PE 文件中的导入表，并根据其中的信息加载所有静态导入的 DLL。</li>
<li><strong>更新 IAT</strong>：加载器会解析这些 DLL 中的导出函数地址，并用实际的地址更新 IAT 中的占位符。</li>
<li><strong>初始化</strong>：确保所有依赖的 DLL 和它们的导出函数都被正确加载并解析，使程序能够直接调用这些函数。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>自动加载</strong>：所有静态导入的 DLL 在程序启动时自动加载。</li>
<li><strong>依赖性强</strong>：如果缺少任何一个必要的 DLL，程序将无法启动。</li>
<li><strong>IAT 更新频率</strong>：每次启动程序时都需要重新解析和更新 IAT。</li>
</ul>
</li>
</ol>
<h4 id="动态导入："><a href="#动态导入：" class="headerlink" title="动态导入："></a><strong>动态导入：</strong></h4><ol>
<li><strong>编译和链接阶段</strong>：<ul>
<li><strong>不生成导入表条目</strong>：与静态导入不同，动态连接不会在编译和链接阶段为动态加载的 DLL 创建导入表条目。</li>
</ul>
</li>
<li><strong>每次启动时</strong>：<ul>
<li><strong>按需加载</strong>：动态连接的 DLL 不会在程序启动时自动加载，而是在需要时由程序显式调用 <code>LoadLibrary</code> 来加载。</li>
<li><strong>临时性导入表</strong>：每当调用 <code>LoadLibrary</code> 时，操作系统会在内存中为这个 DLL 创建一个新的导入表<!--（注意，这个导入表仅存在于内存之中，一旦程序停止运行，该导入表不复存在）-->。这包括解析该 DLL 所需的所有其他 DLL 和函数，并更新相应的 IAT。</li>
<li><strong>独立于原始PE文件</strong>：通过 <code>LoadLibrary</code> 加载的 DLL 的导入表仅存在于内存中，不会影响或改变磁盘上的原始 PE 文件。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>灵活性高</strong>：允许程序在运行时根据需要加载和卸载模块，提供了更大的灵活性。</li>
<li><strong>减少初始加载时间</strong>：因为不是所有依赖都在启动时加载，所以可以加快程序的启动速度。</li>
<li><strong>IAT 更新频率</strong>：只有在调用 <code>LoadLibrary</code> 时才会创建和更新 IAT，而不是每次启动程序时都进行。</li>
</ul>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>在静态导入dll时，编译阶段创建导入表，但在程序的启动阶段才会修正IAT表，一是因为ASLR 机制导致程序每一次启动都会分配不一样的基址，二是因为在程序开始时，dll文件才会映射到当前进程的虚拟地址中，这个时候才能知道导入函数的实际地址。启动阶段，IAT中所有导入函数（不管用没用到）的地址都会修正。</p>
<p>在动态导入时，编译阶段并不创建导入表，只会在程序启动状态在虚拟内存按需创建一个导入表，并且并不会把IAT中所有导入函数的地址都修正，而是只对需要使用的导入函数（GetProcAddress调用的）的地址进行修正。</p>
<p>对于静态导入，在编译阶段程序就已经对该dll文件进行链接和解释，并且在启动阶段会把该dll所有函数的地址进行修正，所以在程序中可以直接使用函数名对其进行调用。对于动态导入，只有在调用LoadLibrary(“example.dll”)时才会加载dll文件并创建导入表，而且并不会对IAT中函数地址进行修正，只会在调用GetProcAddress函数时对函数地址进行修正。因此动态导入一定需要用到LoadLibrary和GetProcAddress函数。</p>
<h4 id="静态链接库："><a href="#静态链接库：" class="headerlink" title="静态链接库："></a>静态链接库：</h4><p>dll文件是一种动态链接库，它并不会在编译时把代码注入到exe文件里面，而是在exe文件启动时映射到其虚拟内存中，并不会改变原exe文件。因此，它每次都启动都需要将代码映射到内存，非常依赖dll文件，一旦dll文件不存在或找到不到，则exe文件无法运行。</p>
<p>与之相反，静态链接库.lib文件会在编译时把代码注入到exe文件里面，一旦编译完成，将不在需要调用该lib文件，相比之下，其文件大小会比使用动态库的大。因为它是直接将代码注入，使以它不需要导入表来解释函数位置，而是直接当本地函数使用。</p>
<h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1>]]></content>
      <tags>
        <tag>PE文件</tag>
      </tags>
  </entry>
  <entry>
    <title>国城杯wp</title>
    <url>/posts/8147/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="Crush’s-secret"><a href="#Crush’s-secret" class="headerlink" title="Crush’s secret"></a>Crush’s secret</h2><p>有SMC，动调</p>
<img src="/posts/8147/image-20241207135656066.png" class="" title="image-20241207135656066">

<p>把它的主要逻辑简化一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encode(unsigned int *a1, int a2,unsigned int* a3)   </span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int v4; // edx</span><br><span class="line">  int v5; // edx</span><br><span class="line">  int v7; // [esp+D4h] [ebp-44h]</span><br><span class="line">  int v8; // [esp+E0h] [ebp-38h]</span><br><span class="line">  unsigned int i; // [esp+ECh] [ebp-2Ch]</span><br><span class="line">  unsigned int v10; // [esp+F8h] [ebp-20h]</span><br><span class="line">  unsigned int v11; // [esp+104h] [ebp-14h]</span><br><span class="line"></span><br><span class="line">    v8 = 32;</span><br><span class="line">    v10 = 0;</span><br><span class="line">    do   //32次循环</span><br><span class="line">    &#123;</span><br><span class="line">      v10 -= 0x61C88647;</span><br><span class="line">      v7 = (v10 &gt;&gt; 2) &amp; 3;</span><br><span class="line">      a1[0] += (((a1[1] ^ a3[v7 ^ 0 &amp; 3]) + (a1[1] ^ v10)) ^ (((16 * a1[1]) ^ (a1[1] &gt;&gt; 3))+ ((4 *a1[1]) ^ (a1[1] &gt;&gt; 5))));</span><br><span class="line">      a1[1] += (((a1[0] ^ a3[v7 ^ 1 &amp; 3]) + (a1[0] ^ v10)) ^ (((16 * a1[0]) ^ (a1[0] &gt;&gt; 3))+ ((4 *a1[0]) ^ (a1[0] &gt;&gt; 5))));</span><br><span class="line">      --v8;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v8 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是密文</p>
<img src="/posts/8147/image-20241207135840979.png" class="" title="image-20241207135840979">

<p>这是密钥：</p>
<img src="/posts/8147/image-20241207140402515.png" class="" title="image-20241207140402515">

<p>写脚本解密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void decode(unsigned int *a1, int a2,unsigned int* a3)   //a1=data,a3=key</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int v4; // edx</span><br><span class="line">  int v5; // edx</span><br><span class="line">  int v7; // [esp+D4h] [ebp-44h]</span><br><span class="line">  int v8; // [esp+E0h] [ebp-38h]</span><br><span class="line">  unsigned int i; // [esp+ECh] [ebp-2Ch]</span><br><span class="line">  unsigned int v10; // [esp+F8h] [ebp-20h]</span><br><span class="line">  unsigned int v11; // [esp+104h] [ebp-14h]</span><br><span class="line"></span><br><span class="line">    v8 = 32;</span><br><span class="line">    v10 = 0;</span><br><span class="line">    do   //32次循环</span><br><span class="line">    &#123;</span><br><span class="line">      v10 -= 0x61C88647;</span><br><span class="line">      v7 = (v10 &gt;&gt; 2) &amp; 3;</span><br><span class="line">      a1[0] += (((a1[1] ^ a3[v7 ^ 0 &amp; 3]) + (a1[1] ^ v10)) ^ (((16 * a1[1]) ^ (a1[1] &gt;&gt; 3))+ ((4 *a1[1]) ^ (a1[1] &gt;&gt; 5))));</span><br><span class="line">      a1[1] += (((a1[0] ^ a3[v7 ^ 1 &amp; 3]) + (a1[0] ^ v10)) ^ (((16 * a1[0]) ^ (a1[0] &gt;&gt; 3))+ ((4 *a1[0]) ^ (a1[0] &gt;&gt; 5))));</span><br><span class="line">      --v8;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v8 );</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned int data[]=&#123;0xf31419a2,0x2f193025,0x6e995655,0x75d355fe,0x42e6b4e8,0xf97e03e,0x9f4676d0,0x2488d889,0x8e5cf3d7,0x18c58297,0x2652c22c,0x912ccd2b&#125;;</span><br><span class="line">    unsigned int key[]=&#123;0x5201314,0x52013140,0x5201314,0x52013140&#125;;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;6;i++)&#123;</span><br><span class="line">        decode(&amp;data[i*2],2,key);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;12;i++)&#123;</span><br><span class="line">        printf(&quot;%#x,&quot;,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  //D0g3xGC&#123;The_wind_stops_at_autumn_water_and_I_stop_at_you&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/8147/image-20241207140839246.png" class="" title="image-20241207140839246">

<h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><p>安卓题，前面半段是魔改的base64加密，解密出来的结果是round_and</p>
<p>后面半段只能用爆破法来解。但是它前一个字符加密的结果会影响到下一个加密，所以必须采用逐个破解法。</p>
<p>本来一开始想各种方法出了前几个字符”_rounD“，但是后面的可能性太多了，没办法一个一个试，于是想用12个循环来暴力破解（）。</p>
<p>12个字符，每个字符有127种可能，就是127的12次方，上亿种可能了，再加上每一种情况都要调用round函数进行判断，结果很明显，代码写出来了但是运行不出结果。在尝试很多方法后无功而反。</p>
<p>最后，在看了其他师傅wp后才搞清楚怎么写爆破脚本。</p>
<p>这是其他师傅的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def makebox(s):                             # 构建数组盒</span><br><span class="line">    iArr = [1023 - i for i in range(1024)]</span><br><span class="line">    for i in range(1024):</span><br><span class="line">        iArr[i] = iArr[i] ^ ord(s[i % 12])</span><br><span class="line">    return iArr</span><br><span class="line"></span><br><span class="line">box = makebox(&quot;c9m1bRmfY5Wk&quot;)</span><br><span class="line"></span><br><span class="line">def round(iArr, str):                   # 加密函数</span><br><span class="line">    length = len(str)</span><br><span class="line">    iArr2 = [0 for _ in range(length)]</span><br><span class="line">    iArr3 = [352, 646, 752, 882, 65, 0, 122, 0, 0, 7, 350, 360]</span><br><span class="line">    i = 33</span><br><span class="line">    for i2 in range(0, length):</span><br><span class="line">        charAt = ord(str[i2])</span><br><span class="line">        for _ in range(0, 32):</span><br><span class="line">            i4 = (iArr[i] ^ charAt) % 5</span><br><span class="line">            if i4 == 0:</span><br><span class="line">                charAt = (charAt + iArr[i]) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 1:</span><br><span class="line">                charAt = ((charAt - iArr[i]) % 1024 + 1024) % 1024  # 确保结果非负</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 2:</span><br><span class="line">                charAt = (charAt ^ iArr[i]) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 3:</span><br><span class="line">                charAt = (charAt &gt;&gt; 3) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 4:</span><br><span class="line">                charAt = (charAt &lt;&lt; 3) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">        iArr2[i2] = charAt</span><br><span class="line">    return iArr2</span><br><span class="line"></span><br><span class="line">import string</span><br><span class="line">dic = string.ascii_letters + &#x27;_&#x27;            # 创建一个由大小写字母和下划线组成的字典，字符串元素由这里取</span><br><span class="line"></span><br><span class="line">iArr3 = [352, 646, 752, 882, 65, 0, 122, 0, 0, 7, 350, 360]</span><br><span class="line"></span><br><span class="line"># 使用缓存来存储中间结果</span><br><span class="line">cache = &#123;&#125;      # 字典，用来排除已经尝试过的字符串</span><br><span class="line"></span><br><span class="line">def dfs(idx, ans):          # 关键递归函数</span><br><span class="line">    if idx == len(iArr3):       # 长度达到指定值则代表找到了符合条件的</span><br><span class="line">        print(ans)  # 找到符合条件的字符串</span><br><span class="line">        return True</span><br><span class="line">    for i in dic:         #在字符数组里面找字符</span><br><span class="line">        new_ans = ans + i      # 这里一定要用一个新的字符串来承接，因为后面的步骤可能会改变字符串</span><br><span class="line">        if new_ans not in cache:     # 判断是否是尝试过的字符串</span><br><span class="line">            cache[new_ans] = round(box, new_ans)    # 没尝试过则加入字典</span><br><span class="line">        res = cache[new_ans]        # 取出经过加密后的字符串</span><br><span class="line">        if res[-1] == iArr3[idx]:       # 如果相同则继续判断下一位</span><br><span class="line">            if dfs(idx + 1, new_ans):</span><br><span class="line">                return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">if not dfs(0, &#x27;&#x27;):</span><br><span class="line">    print(&quot;No solution found&quot;)</span><br></pre></td></tr></table></figure>

<p>他是利用了虽然前一个字符会影响后一个字符，但是后一个字符不会影响前一个字符这一特点（因为在对每个字符进行加密时，i的值会不断变化），这里使用了DFS算法，递归调用，比我之前12个循环好在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、代码简短，易理解</span><br><span class="line">2、进行了剪枝，提前排除不可能满足条件的字符串</span><br></pre></td></tr></table></figure>

<p>于是他的这段代码可以在几秒内快速运行出一个结果“_rounD_we_go”。</p>
<p>在理解了这位师傅脚本的主要逻辑后，我自己写了一个脚本，主要方法还是一样的，只不过稍微修改，让他把所有结果都运行出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int data[]=&#123;352, 646, 752, 882, 65, 0, 122, 0, 0, 7, 350, 360&#125;;</span><br><span class="line">int arr[1024];char flag[13]=&quot;&quot;;</span><br><span class="line">void makebox(char *s)&#123;</span><br><span class="line">    int  i;</span><br><span class="line">    for(i=0;i&lt;1024;i++)&#123;</span><br><span class="line">      arr[i]=1023-i;</span><br><span class="line">      arr[i]^=s[i%12];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">char *Round(int *result,char *s,int len)&#123;</span><br><span class="line">    int a=33;</span><br><span class="line">    int i2,i3,i4,num2,j;</span><br><span class="line">    int at;int i;int num,rip;</span><br><span class="line">    for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">        at=s[i];</span><br><span class="line">        for(i3=0;i3&lt;32;i3++)&#123;</span><br><span class="line">            i4=((arr[a]^at)%5+5)%5;</span><br><span class="line">            if(i4==0) &#123;num=(at+arr[a])%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==1) &#123;num=((at-arr[a])%1024+1024)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==2) &#123;num=((at^arr[a])%1024+1024)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==3) &#123;num=(at&gt;&gt;3)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==4) &#123;num=(at&lt;&lt;3)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            at=num;a=rip;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i]=at;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">void DSF(int len)&#123;</span><br><span class="line">    if(len==12)&#123;printf(&quot;%s\n&quot;,flag);return;&#125;</span><br><span class="line">    int i;char temp[13];</span><br><span class="line">    int result[13];</span><br><span class="line">    for(i=33;i&lt;127;i++)&#123;</span><br><span class="line">        strcpy(temp,flag);</span><br><span class="line">        temp[len]=(char)i;</span><br><span class="line">        Round(result,temp,len+1);</span><br><span class="line">        if(result[len]==data[len]) &#123;flag[len]=(char)i;DSF(len+1);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char s[]=&quot;c9m1bRmfY5Wk&quot;;</span><br><span class="line">    makebox(s);</span><br><span class="line">    DSF(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本会把所有满足结果的字符串打印出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_roun2t$e_%o</span><br><span class="line">_roun2t$e_`o</span><br><span class="line">_roun2t$e_go</span><br><span class="line">_roun7t$e_%o</span><br><span class="line">_roun7t$e_`o</span><br><span class="line">_roun7t$e_go</span><br><span class="line">_roun&lt;&#x27;-n4TO</span><br><span class="line">_rounD_EJ4TO</span><br><span class="line">_rounD_PCi?O</span><br><span class="line">_rounD_\Ci?O</span><br><span class="line">_rounD_we_%o</span><br><span class="line">_rounD_we_`o</span><br><span class="line">_rounD_we_go</span><br></pre></td></tr></table></figure>

<p>在里面挑一个最正常的“_rounD_we_go”与前半段组成flag：D0g3xGC{round_and_rounD_we_go}</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/posts/1106/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>数据结构算法总集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【第3周实验及课后作业】</span><br><span class="line">一、编写带头结点的单链表相关算法：</span><br><span class="line">1、建表-1：输入一组数，用尾插法建表；</span><br><span class="line">如：输入1、2、3、4、5、-1，链表为：    头结点-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5^</span><br><span class="line">2、建表-2：输入一组数，用头插法建表；</span><br><span class="line">如：输入1、2、3、4、5、-1，链表为：   头结点-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1^</span><br><span class="line">3、打印输出带头结点的单链表</span><br><span class="line">4、向升序单链表h插入值为x的元素，使其依旧有序</span><br><span class="line">5、删除升序单链表h中所有值为x的元素</span><br><span class="line">6、给定升序表h1、h2，将其合并成降序表h3</span><br><span class="line"></span><br><span class="line">【第4周实验及课后作业】</span><br><span class="line">编写头指针的单链表相关算法：</span><br><span class="line">1、用头插法建表；</span><br><span class="line">2、输出单链表</span><br><span class="line">3、给定h1，将其中的所有偶数结点摘除，依次【尾插】插入h2</span><br><span class="line">4、给定h，找到其中最大值结点，将其摘除，插入h之前，并返回h</span><br><span class="line"></span><br><span class="line">【第6周实验及课后作业】</span><br><span class="line">1、设计最多能存储10个元素的循环队列，并完成初始化、入队、出队、判空、判满、计算元素个数等六个基本操作。</span><br><span class="line">2、设计如图所示的链式队列，完成初始化、入队、出队、判空四个基本操作。</span><br><span class="line">3、给定一带表头的单链表，只允许一遍扫描，定位该链表倒数第K（K&gt;0）个结点。</span><br><span class="line">4、给定一带表头的单链表，只允许一遍扫描，定位该链表中点元素，并输出共有多少元素，中点元素是第几个，值为多少。</span><br><span class="line"></span><br><span class="line">【第7周实验及课后作业】</span><br><span class="line">一、构造至多能存储100个字符的顺序表用于存储字符串，并配备以下操作：</span><br><span class="line">（1）delStr(s,i,n)：删除s从下标i开始的长度为n的子串，并返回删除后的字符串。</span><br><span class="line">         如   s=&quot;abcdefghi&quot;， delStr(s,1,5)=&quot;abcdefhi&quot;=&quot;ahi&quot;；</span><br><span class="line">（2）insertStr(s1,i,s2)：在s1的下标i处插入串s2；</span><br><span class="line">        如 s1=&quot;abc&quot;，s2=&quot;123&quot;，insertStr(s1,1,s2)=&quot;a123bc&quot;；</span><br><span class="line">（3）replaceStr(s1,i,n,s2): 用s2替换子串s1[i..n] ；</span><br><span class="line">          如 s1=&quot;abcde&quot;，s2=&quot;123&quot;，replaceStr (s1,1,4,s2)=&quot;a123&quot;；</span><br><span class="line">二、编写程序，实现朴素的模式匹配算法，并能输入数据进行验证</span><br><span class="line">三、编写程序，完成稀疏矩阵的如下程序：===这部分内容可多看看视频</span><br><span class="line">（1）通过输入相关三元组，实现稀疏矩阵的输入；</span><br><span class="line">（2）根据三元组表，以矩阵方式输出稀疏矩阵</span><br><span class="line">（3）实现稀疏矩阵的普通转置；</span><br><span class="line">（4）实现稀疏矩阵的快速转置。</span><br><span class="line"></span><br><span class="line">【第8周实验及课后作业】</span><br><span class="line">编写★★★递归程序★★★：</span><br><span class="line">1、打印课件中第17页所示各种三角的【倒置】形状</span><br><span class="line">2、在数组a[low...high]查找x，要求：</span><br><span class="line">（1）编写函数实现：若x在a中存在，则返回首次出现位置；若不出现，则返回-1；</span><br><span class="line">（2）编写函数实现：若x在a中存在，则返回最后出现位置；若不出现，则返回-1；</span><br><span class="line">（3）编写函数实现：按中点优先方式查找x，若找到，则返回其对应下标；若不出现，则返回-1。</span><br><span class="line">3、给定非空数组a[low...high]，编写递归函数返回a中最大值下标</span><br><span class="line">4、将顺序表的奇数放在顺序表的头部，偶数放在顺序表的尾部，奇数偶数不得交叉存放。</span><br><span class="line">5、按正序、逆序两种方式输出单链表。</span><br><span class="line"></span><br><span class="line">【第9周实验及课后作业】</span><br><span class="line">一、设计能存储char型数据的m度树，并完成以下函数设计：</span><br><span class="line">1、基础操作：建树、前序遍历、后序遍历；</span><br><span class="line">2、查找值为x的元素是否存在，若存在，返回指向该结点的指针；若不存在，则返回NULL。要求：在main中输出查找结果</span><br><span class="line">3、层次遍历</span><br><span class="line">4、凹入输出、</span><br><span class="line">5、括号输出（最好给出美化版算法）</span><br><span class="line">二、设计能存储int型数据的m度树，并完成以下函数设计（提示：可用0表与NULL）</span><br><span class="line">1、基础操作：建树、前序遍历、后序遍历；</span><br><span class="line">2、统计树中m度结点个数；</span><br><span class="line">3、返回指向求树中最大值结点的指针</span><br><span class="line"></span><br><span class="line">【第10周实验及课后作业】</span><br><span class="line">设计能存储char型数据的二叉树，并完成以下函数设计</span><br><span class="line">1、建树</span><br><span class="line">2、三种递归遍历：前序、中序、后序</span><br><span class="line">3、三种非递归遍历：前序遍历、中序遍历、层次遍历</span><br><span class="line">4、在二叉树t中查找值为x的结点p。若未找到，或是根的值为x，则返回空；否则，则返回p指向结点的双亲</span><br><span class="line">5、在二叉树树中找结点x，若找到，则返回值为x的结点的高度（注：根的高度为1）；若未找到，则返回0</span><br><span class="line">6、统计二叉树中叶子结点个数</span><br><span class="line">7、计算二叉树的树高</span><br><span class="line">8、输出二叉树中所有1度结点及其高度。</span><br><span class="line">9、输出二叉树前/中/后序遍历的首点、尾点</span><br><span class="line"></span><br><span class="line">【第12周实验及课后作业】</span><br><span class="line">1、创建存储int型数据的二叉树；</span><br><span class="line">2、统计二叉树中1度结点的个数</span><br><span class="line">3、返回二叉树中的最大值结点的指针</span><br><span class="line">4、判断两棵二叉树是否等价</span><br><span class="line">5、创建ppt末尾图有向图G6对应的邻接矩阵、邻接表、逆邻接表，并输出结果</span><br><span class="line">     结果：邻接矩阵，就是二维矩阵形式输出；邻接表，就是按邻接表形式输出</span><br><span class="line">6、使用邻接矩阵，计算结点x的入度、出度。</span><br><span class="line">7、使用邻接表，计算结点x的入度、出度</span><br><span class="line"></span><br><span class="line">【第13周实验及课后作业】</span><br><span class="line">1、创建ppt末尾图有向图G6对应的邻接矩阵、邻接表、逆邻接表，并输出结果；</span><br><span class="line">2、使用邻接矩阵，计算结点x的入度、出度。</span><br><span class="line">3、使用邻接表，计算结点x的入度、出度</span><br><span class="line">4、基于邻接矩阵，实施深度、广度优先遍历</span><br><span class="line">5、基于邻接表，实施深度、广度优先遍历</span><br><span class="line"></span><br><span class="line">【第14周实验及课后作业】</span><br><span class="line">1、给定顺序表L，编程实现二分法检索，给出递归实现、非递归实现两个版本。其中非递归算法中，要输出查找次数（即查找多少次发现成功/失败）以供验证。</span><br><span class="line">2、关于二叉排序树t，编写如下几个函数：</span><br><span class="line">（1）向t插入单个结点操作（递归、非递归）</span><br><span class="line">（2）输入一组数据，基于上面插入操作建树 （只需非递归）</span><br><span class="line">（3）中序遍历输出，以便验证创建的树是否为二叉排序树 （只需递归）</span><br><span class="line">（4）在二叉排序树中查找元素x，若找到，则返回指向该结点的指针；若未找到，则返回NULL；（递归、非递归）</span><br><span class="line">（5）判断给定二叉树t是否为二叉排序树（递归）</span><br><span class="line"></span><br><span class="line">【第15周实验及课后作业】</span><br><span class="line">1、判断一棵树是否为二叉排序树（递归方式）</span><br><span class="line">2、给定数据&#123;654,638,214,357,376,854,662,392&#125;，取key的十位数作哈希地址，采用线性探测法作为冲突处理方法，将数据依次放入大小为10的数组中。用-1作为空标记。输出散列表的存储示意图（第一行输出下标，第二行输出横线，第三行输出数据）。并对其进行等概率查找，输出（找到、找不到时的）查找次数，并给出找到/找不到时的平均查找长度。（注意：数据源自ppt，将存储与ppt对应，检验存储是否正确）</span><br><span class="line">3、编程实现直接插入排序，并逐行输出各趟的排序结果，如10个数据，就是9趟。</span><br><span class="line">4、编程实现希尔排序，并逐行输出各趟的排序结果。</span><br><span class="line"></span><br><span class="line">【第16周实验及课后作业】</span><br><span class="line">1、编程实现【直接插入】排序。</span><br><span class="line">2、编程实现【希尔插入】排序。</span><br><span class="line">3、编程实现【直接选择】排序。</span><br><span class="line">4、编程实现【堆选择】排序。</span><br><span class="line">5、编程实现【冒泡选择】排序。</span><br><span class="line">6、编程实现【快速选择】排序。</span><br></pre></td></tr></table></figure>



<h2 id="一、顺序表"><a href="#一、顺序表" class="headerlink" title="一、顺序表"></a>一、顺序表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define se SeqList</span><br><span class="line">#define slen L-&gt;len</span><br><span class="line">#define sarr L-&gt;a</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int a[100];</span><br><span class="line">	int len;</span><br><span class="line">&#125;SeqList;</span><br><span class="line">void input_data(se* L)			//输入数据 </span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;输入一组数，以-1结束: \n&quot;);</span><br><span class="line">	int i=0;</span><br><span class="line">	int n=0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	while(n != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		sarr[i] = n;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	slen = i;</span><br><span class="line">&#125;</span><br><span class="line">void print_data(se* L)			//打印 </span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for( i=0;i&lt;slen;i++)</span><br><span class="line">		printf(&quot;%d &quot;,sarr[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void delete_sub(se* L,int i)	//删除指定下标的数据 </span><br><span class="line">&#123;</span><br><span class="line">	if(i&gt;=slen||i&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;位置非法！\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int j;</span><br><span class="line">	for(j=i;j&lt;slen-1;j++)</span><br><span class="line">		sarr[j]=sarr[j+1];</span><br><span class="line">	slen--;</span><br><span class="line">&#125;</span><br><span class="line">void insert_data(se* L,int i)	//插入数据并排序 </span><br><span class="line">&#123;</span><br><span class="line">	int n=slen-1;</span><br><span class="line">	while(n&gt;=0)</span><br><span class="line">	&#123;</span><br><span class="line">		if(sarr[n]&gt;i)</span><br><span class="line">		&#123;</span><br><span class="line">			sarr[n+1]=sarr[n];</span><br><span class="line">			n--;</span><br><span class="line">		&#125;</span><br><span class="line">		else break;</span><br><span class="line">	&#125;</span><br><span class="line">	sarr[n+1]=i;</span><br><span class="line">	slen++;</span><br><span class="line">&#125;</span><br><span class="line">void dele_data(se* L,int x)	//升序表删除数据X</span><br><span class="line">&#123;</span><br><span class="line">	int i=0,j=0;</span><br><span class="line">	while(i&lt;slen &amp;&amp; sarr[i]&lt;x) i++;</span><br><span class="line">	if(i==slen||sarr[i]&gt;x) return;</span><br><span class="line">	j=i;</span><br><span class="line">	while(sarr[i]==x &amp;&amp; i&lt;slen) i++;</span><br><span class="line">	for(;i&lt;slen;i++,j++)</span><br><span class="line">		sarr[j]=sarr[i];</span><br><span class="line">	slen=j;</span><br><span class="line"> &#125; </span><br><span class="line">void adjust_order(se* L) //奇数放在尾部，偶数放在头部</span><br><span class="line">&#123;</span><br><span class="line">	int i=0,j=slen-1,k=0;</span><br><span class="line">	while(i&lt;j)&#123;</span><br><span class="line">		while(i&lt;j &amp;&amp; sarr[i]%2==0) i++;</span><br><span class="line">		while(j&gt;i &amp;&amp; sarr[j]%2==1) j--;</span><br><span class="line">		if(i&lt;j)&#123;</span><br><span class="line">			k=sarr[i];sarr[i]=sarr[j];sarr[j]=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dele_range(se* L,int x,int y)  //删除指定范围内的数据 </span><br><span class="line">&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	for(i=0;i&lt;slen;)</span><br><span class="line">	&#123;</span><br><span class="line">		if(sarr[i]&gt;x&amp;&amp;sarr[i]&lt;y)</span><br><span class="line">			delete_sub(L,i);</span><br><span class="line">		else i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void merge_list(se* X,se* Y,se* Z)	//两个降序合成升序  </span><br><span class="line">&#123;</span><br><span class="line">	int i=0,j=0,k=X-&gt;len+Y-&gt;len-1;</span><br><span class="line">	while(i&lt;X-&gt;len&amp;&amp;j&lt;Y-&gt;len)&#123;</span><br><span class="line">		if(X-&gt;a[i]&lt;Y-&gt;a[j])&#123;</span><br><span class="line">			Z-&gt;a[k]=Y-&gt;a[j];</span><br><span class="line">			j++;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			Z-&gt;a[k]=X-&gt;a[i];</span><br><span class="line">			i++;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(i&lt;X-&gt;len)&#123;</span><br><span class="line">		Z-&gt;a[k]=X-&gt;a[i];</span><br><span class="line">			i++;</span><br><span class="line">			k--;</span><br><span class="line">	&#125;</span><br><span class="line">	while(j&lt;Y-&gt;len)&#123;</span><br><span class="line">		Z-&gt;a[k]=Y-&gt;a[j];</span><br><span class="line">			j++;</span><br><span class="line">			k--;</span><br><span class="line">	&#125;</span><br><span class="line">	Z-&gt;len=i+j;</span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	se L;</span><br><span class="line">//	input_data(&amp;L);</span><br><span class="line">//	print_data(&amp;L);</span><br><span class="line">//	delete_sub(&amp;L,6);</span><br><span class="line">//	insert_data(&amp;L,0);</span><br><span class="line">//	dele_data(&amp;L,6); </span><br><span class="line">//	change_order(&amp;L);</span><br><span class="line">//	adjust_order(&amp;L);</span><br><span class="line">//	print_data(&amp;L);</span><br><span class="line">//	dele_range(&amp;L,10,20);</span><br><span class="line">	se X,Y,Z;</span><br><span class="line">	printf(&quot;请输入X顺序表：\n&quot;);</span><br><span class="line">	input_data(&amp;X);</span><br><span class="line">	printf(&quot;请输入Y顺序表：\n&quot;);</span><br><span class="line">	input_data(&amp;Y);</span><br><span class="line">	printf(&quot;合并后：\n&quot;);</span><br><span class="line">	merge_list(&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">	print_data(&amp;Z);</span><br><span class="line">&#125;</span><br><span class="line">//1 2 3 4 5 6 -1</span><br><span class="line">//1 2 3 4 5 7 8 -1</span><br><span class="line">//1 8 9 10 11 14 16 18 20 21 -1</span><br><span class="line">//10 8 6 4 2 -1</span><br><span class="line">//9 7 5 3 1 -1</span><br></pre></td></tr></table></figure>

<h2 id="二、单链表"><a href="#二、单链表" class="headerlink" title="二、单链表"></a>二、单链表</h2><h3 id="1、头结点型单链表"><a href="#1、头结点型单链表" class="headerlink" title="1、头结点型单链表"></a>1、头结点型单链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define newnode (node* )malloc(sizeof(node))</span><br><span class="line">typedef struct k&#123;  //定义结构体 </span><br><span class="line">	int data;</span><br><span class="line">	struct k* next;   </span><br><span class="line">&#125;node;</span><br><span class="line">node* creat()&#123;     //尾接法创建单链表</span><br><span class="line">	node *h,*t,*input;</span><br><span class="line">	int x;</span><br><span class="line">	h=newnode;h-&gt;next=NULL;</span><br><span class="line">	t=h;			//t和h都是一个指向结构体的指针，执行这个操作后，t和h将会指向同一个结构体 </span><br><span class="line">	printf(&quot;请输入一组数，以-1结束：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	while(x!=-1)&#123;</span><br><span class="line">		input=newnode,input-&gt;next=NULL;input-&gt;data=x;</span><br><span class="line">		t-&gt;next=input;</span><br><span class="line">		t=input;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">node* head_creat()&#123;    //头接法创建单链表 </span><br><span class="line">	node *h,*p;int x;</span><br><span class="line">	h=newnode;h-&gt;next=NULL;</span><br><span class="line">	printf(&quot;请输入一组数，以-1结束：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	while(x!=-1)&#123;</span><br><span class="line">		p=newnode;p-&gt;next=NULL;p-&gt;data=x;</span><br><span class="line">		p-&gt;next=h-&gt;next;h-&gt;next=p;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">void printlist(node *h)&#123;   //打印单链表 </span><br><span class="line">	node* p;</span><br><span class="line">	for(p=h-&gt;next;p!=NULL;p=p-&gt;next)&#123;</span><br><span class="line">		printf(&quot;%d-&gt;&quot;,p-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void insert_data(node *h,int x)&#123;   //升序表插入x </span><br><span class="line">	node *p;p=newnode;p-&gt;data=x;p-&gt;next=NULL;</span><br><span class="line">	node *q,*s;</span><br><span class="line">	q=h;s=h-&gt;next;</span><br><span class="line">	while(s!=NULL)&#123;</span><br><span class="line">		if(s-&gt;data&gt;=x) break;</span><br><span class="line">		s=s-&gt;next;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next=s;q-&gt;next=p;</span><br><span class="line">&#125; </span><br><span class="line">void delet_data(node *h,int x)&#123;     //升序表删除所有x </span><br><span class="line">	node *p,*q;</span><br><span class="line">	p=h;</span><br><span class="line">	while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;data&lt;x) p=p-&gt;next;  //p会停在x之前</span><br><span class="line">	if(p-&gt;next==NULL||p-&gt;next-&gt;data&gt;x) return;   //如果没有x则退出 </span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	while(q!=NULL &amp;&amp; q-&gt;data==x) q=q-&gt;next;		//q会停在x之后 </span><br><span class="line">	p-&gt;next=q;	//把q粘在p后面 </span><br><span class="line">&#125;</span><br><span class="line">node* comflate(node *h1,node *h2)&#123;	//两个升序表合成一个降序表</span><br><span class="line">	 node *h3,*a,*b,*c;</span><br><span class="line">	 h3=newnode;h3-&gt;next=NULL;</span><br><span class="line">	 a=h1-&gt;next;b=h2-&gt;next;</span><br><span class="line">	 while(a!=NULL &amp;&amp; b!=NULL)&#123;</span><br><span class="line">	 	if(a-&gt;data&lt;b-&gt;data) &#123;c=a;a=a-&gt;next;&#125;</span><br><span class="line">	 	else &#123;c=b;b=b-&gt;next;&#125;</span><br><span class="line">		c-&gt;next=h3-&gt;next;h3-&gt;next=c;</span><br><span class="line">	 &#125;</span><br><span class="line">	 if(a==NULL)</span><br><span class="line">	 	while(b!=NULL) &#123;c=b;b=b-&gt;next;c-&gt;next=h3-&gt;next;h3-&gt;next=c;&#125;</span><br><span class="line">	 else</span><br><span class="line">		while(a!=NULL) &#123;c=a;a=a-&gt;next;c-&gt;next=h3-&gt;next;h3-&gt;next=c;&#125;</span><br><span class="line">	return h3;</span><br><span class="line">&#125;</span><br><span class="line">void find_K(node *h,int k)&#123;		//一遍扫描，定位该链表倒数第K（K&gt;0）个结点</span><br><span class="line">	node *p,*q;p=q=h;int i=0;</span><br><span class="line">	while(q!=NULL)&#123;   //q先寻到第k个 </span><br><span class="line">		q=q-&gt;next;i++;</span><br><span class="line">		if(i==k) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i!=k) &#123;printf(&quot;不存在倒数第%d个&quot;,k);return;&#125;</span><br><span class="line">	//到此说明存在倒数第k个</span><br><span class="line">	while(q!=NULL)&#123;q=q-&gt;next;p=p-&gt;next;&#125;</span><br><span class="line">	printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void find_mid(node *h)&#123;//给定一带表头的单链表，只允许一遍扫描，定位该链表中点元素，并输出共有多少元素，</span><br><span class="line">					   //中点元素是第几个，值为多少</span><br><span class="line">	node *p,*q;int count =0,sum=0;</span><br><span class="line">	if(h==NULL)&#123;printf(&quot;此为空表&quot;);return;&#125;</span><br><span class="line">	p=q=h;</span><br><span class="line">	while(q!=NULL&amp;&amp;q-&gt;next!=NULL)&#123;</span><br><span class="line">		p=p-&gt;next;count++;</span><br><span class="line">		q=q-&gt;next;sum++;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">		if(q!=NULL) sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(sum%2==1)</span><br><span class="line">	    printf(&quot;有%d个元素，中点元素是第%d个，值为%d\n&quot;,sum,count,p-&gt;data);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;有%d个元素，中点元素是第%d个和第%d个，值分别为%d和%d\n&quot;,sum,count,count+1,p-&gt;data,p-&gt;next-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	node *h,*h1,*h2,*h3;</span><br><span class="line">	h=creat();</span><br><span class="line">//	h=head_creat();</span><br><span class="line">	printlist(h);</span><br><span class="line">//	insert_data(h,5);</span><br><span class="line">//	delet_data(h,5);</span><br><span class="line">//	printf(&quot;请输入h1:\n&quot;);</span><br><span class="line">//	h1=creat();</span><br><span class="line">//	printf(&quot;请输入h2:\n&quot;);</span><br><span class="line">//	h2=creat();</span><br><span class="line">//	h3=comflate(h1,h2);</span><br><span class="line">//	printlist(h3);</span><br><span class="line">//  find_K(h,5);</span><br><span class="line">	find_mid(h);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5 6 -1</span><br><span class="line">// h1 = 1 3 5 7 9 -1</span><br><span class="line">// h2 = 2 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3 id="2、头指针型单链表"><a href="#2、头指针型单链表" class="headerlink" title="2、头指针型单链表"></a>2、头指针型单链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define newnode (node *)malloc(sizeof(node))</span><br><span class="line">typedef struct k&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct k *next;</span><br><span class="line">&#125;node;</span><br><span class="line">node *creat()&#123;	//头插法创建头指针型单链表 </span><br><span class="line">	node *p,*h;</span><br><span class="line">	int x;</span><br><span class="line">	printf(&quot;请输入一组数，以-1结尾：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	if(x==-1) return NULL;</span><br><span class="line">	h=newnode;h-&gt;next=NULL;h-&gt;data=x;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	while(x!=-1)&#123;</span><br><span class="line">		p=newnode;p-&gt;data=x;</span><br><span class="line">		p-&gt;next=h;h=p; </span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">void printlist(node *h)&#123;	//输出表 </span><br><span class="line">	node *p;</span><br><span class="line">	for(p=h;p!=NULL;p=p-&gt;next)&#123;</span><br><span class="line">		printf(&quot;%d-&gt;&quot;,p-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">node *insert(node *h,int x)&#123;	//升序表插入X </span><br><span class="line">	node *p;</span><br><span class="line">	p=newnode;p-&gt;next=NULL;p-&gt;data=x;</span><br><span class="line">	if(h==NULL) return p;</span><br><span class="line">	if(x&lt;h-&gt;data)&#123;</span><br><span class="line">		p-&gt;next=h;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	node *pre,*q;</span><br><span class="line">	pre=h;q=h-&gt;next;</span><br><span class="line">	while(q!=NULL&amp;&amp;x&gt;q-&gt;data)&#123;q=q-&gt;next;pre=pre-&gt;next;&#125;;</span><br><span class="line">	pre-&gt;next=p;p-&gt;next=q;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">node *deletlist(node *h,int x)&#123;	//升序表删除 x</span><br><span class="line">	node *p,*q,*d;</span><br><span class="line">	if(h==NULL) return NULL;</span><br><span class="line">	if(h-&gt;data==x)&#123;</span><br><span class="line">		p=h;</span><br><span class="line">		while(p!=NULL&amp;&amp;p-&gt;data==x)&#123;q=p;p=p-&gt;next;free(q);&#125;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	p=h;q=h-&gt;next;</span><br><span class="line">	while(p-&gt;next!=NULL&amp;&amp;p-&gt;next-&gt;data&lt;x) p=p-&gt;next;</span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	while(q!=NULL&amp;&amp;q-&gt;data==x) &#123;d=q;q=q-&gt;next;free(d);&#125;</span><br><span class="line">	p-&gt;next=q;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">void dele_ev_insert(node **h1,node **h2)&#123;	//给定h1，将其中的所有偶数结点摘除，依次【尾插】插入h2</span><br><span class="line">	node *p,*q,*temp,*pre;int x=0; </span><br><span class="line">	if(*h2==NULL) &#123;//如果h2为空表，先创建一个暂时的头结点，后面再删掉 </span><br><span class="line">		temp=newnode;temp-&gt;next=NULL;</span><br><span class="line">		*h2=temp; x=1;  //x用来判断是否创建了结点 </span><br><span class="line">	&#125;</span><br><span class="line">	if(*h1==NULL) return; //如果h1是空表，直接结束 </span><br><span class="line">	q=*h2;</span><br><span class="line">	while(q-&gt;next!=NULL) q=q-&gt;next;//q找到末尾 </span><br><span class="line">	while(*h1!=NULL&amp;&amp;(*h1)-&gt;data%2==0)&#123;//h1第一个元素是偶数时 </span><br><span class="line">		q-&gt;next=*h1;q=*h1;		//偶数结点贴到h2 </span><br><span class="line">		*h1=(*h1)-&gt;next; 		//h1往后移 </span><br><span class="line">	&#125;</span><br><span class="line">	if(*h1==NULL) return;</span><br><span class="line">	pre=*h1;p=(*h1)-&gt;next;</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		if(p-&gt;data%2==0)&#123;</span><br><span class="line">			q-&gt;next=p;q=p;</span><br><span class="line">			p=p-&gt;next;pre-&gt;next=p;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;p=p-&gt;next;pre=pre-&gt;next;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;next=NULL;</span><br><span class="line">	if(x==1)&#123;*h2=(*h2)-&gt;next;free(temp);&#125; //如果前面创建过临时结点，那么现在删掉 </span><br><span class="line">&#125;</span><br><span class="line">node *findmax(node *h)&#123;//寻找最大结点，并插入到表头</span><br><span class="line">	node *pmax,*max,*pre,*p;//max指向最大的那个结点，pmax指向max后面，p遍历寻找 ,pre指向p后面 </span><br><span class="line">	if(h==NULL) return NULL;</span><br><span class="line">	if(h-&gt;next==NULL) return h;</span><br><span class="line">	pre=h;p=h-&gt;next;pmax=NULL;max=h;</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		if(p-&gt;data&gt;max-&gt;data)&#123;max=p;pmax=pre;&#125;</span><br><span class="line">		pre=pre-&gt;next;p=p-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	if(pmax==NULL) return h;//如果第一个元素是最大的，那么返回原样 </span><br><span class="line">	pmax-&gt;next=max-&gt;next;max-&gt;next=h;return max;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	node *h,*h1,*h2;</span><br><span class="line">//	h=creat();</span><br><span class="line">//	printlist(h);</span><br><span class="line">//	h=insert(h,4);</span><br><span class="line">//	printlist(h);</span><br><span class="line">//	h=deletlist(h,4);</span><br><span class="line">//	printlist(h);</span><br><span class="line">	h1=creat();</span><br><span class="line">	printlist(h1);</span><br><span class="line">	h2=creat();</span><br><span class="line">	printlist(h2);</span><br><span class="line">	dele_ev_insert(&amp;h1,&amp;h2); //由于函数无法同时返回两个表头，但是两个表都要修改，所以使用二级指针 </span><br><span class="line">	printf(&quot;h1表\n&quot;);</span><br><span class="line">	printlist(h1);</span><br><span class="line">	printf(&quot;h2表\n&quot;);</span><br><span class="line">	printlist(h2);</span><br><span class="line">//	h=findmax(h);</span><br><span class="line">//	printlist(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1、设计最多能存储10个元素的循环队列，并完成初始化、入队、出队、判空、判满、计算元素个数等六个基本操作。</span><br><span class="line">//2、设计链式队列，完成初始化、入队、出队、判空四个基本操作。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define newnode (node*)malloc(sizeof(node)) </span><br><span class="line">#define cycnode (cycle*)malloc(sizeof(cycle)) </span><br><span class="line">typedef struct k&#123;		//链式队列结点 </span><br><span class="line">	int data;</span><br><span class="line">	struct k *next;</span><br><span class="line">&#125;node;</span><br><span class="line">typedef struct&#123;			//链式队列头尾 </span><br><span class="line">	node *head,*tail;</span><br><span class="line">&#125;ht;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int a[11];</span><br><span class="line">	int front,rear;</span><br><span class="line">&#125;cycle; </span><br><span class="line">ht *creat()&#123;  //链式队列建表并初始化 </span><br><span class="line">	ht *qu;</span><br><span class="line">	qu=(ht*)malloc(sizeof(ht));</span><br><span class="line">	qu-&gt;head=NULL;qu-&gt;tail=NULL;</span><br><span class="line">	return qu;</span><br><span class="line">&#125;</span><br><span class="line">ht *insert(ht *q,int x)&#123;	//链式队列入队 </span><br><span class="line">	node *p;p=newnode;</span><br><span class="line">	p-&gt;data=x;p-&gt;next=NULL;</span><br><span class="line">	if(q-&gt;head==NULL) &#123;q-&gt;head=p;q-&gt;tail=p;&#125;  //如若为空 </span><br><span class="line">	else &#123;q-&gt;tail-&gt;next=p;q-&gt;tail=p;&#125;</span><br><span class="line">	return q;</span><br><span class="line">&#125;</span><br><span class="line">ht *dele(ht *q)&#123;	//链式队列出队 </span><br><span class="line">	node *p;</span><br><span class="line">	if(q-&gt;head==NULL) &#123;printf(&quot;队列为空，无法删除！&quot;);return q;&#125;</span><br><span class="line">	p=q-&gt;head;q-&gt;head=p-&gt;next;</span><br><span class="line">	free(p);</span><br><span class="line">	if(q-&gt;head==NULL) q-&gt;tail=NULL;  //如果如果队列变空 </span><br><span class="line">	return q; </span><br><span class="line">&#125;</span><br><span class="line">int empty(ht *q)&#123;		//链式队列判空 </span><br><span class="line">	return (q-&gt;head==NULL)?0:1;</span><br><span class="line">&#125;</span><br><span class="line">void print(ht *q)&#123;	    //链式队列打印</span><br><span class="line">	if(q-&gt;head==NULL) &#123;printf(&quot;队列为空\n&quot;);return;&#125;</span><br><span class="line">	node *p;p=q-&gt;head;</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">void cyc_creat(cycle *L)&#123;		//初始化循环队列 </span><br><span class="line">	 L-&gt;front=0;L-&gt;rear=0;</span><br><span class="line">&#125;</span><br><span class="line">void cyc_insert(cycle *L,int x)&#123;		//循环队列入队 </span><br><span class="line">	if((L-&gt;rear+1)%11==L-&gt;front)&#123;printf(&quot;队列已满，无法入队！\n&quot;);return;&#125;</span><br><span class="line">	int i=L-&gt;rear;</span><br><span class="line">	L-&gt;a[i]=x;</span><br><span class="line">	L-&gt;rear=(L-&gt;rear+1)%11;          ;</span><br><span class="line">&#125;</span><br><span class="line">int cyc_dele(cycle *L)&#123;	//循环队列出队 ,为空返回-1，不为空返回元素 </span><br><span class="line">	if(L-&gt;rear==L-&gt;front)&#123;printf(&quot;队列为空，无法出队！\n&quot;);return -1;&#125;</span><br><span class="line">	int i=L-&gt;front;</span><br><span class="line">	L-&gt;front=(L-&gt;front+1)%11;return L-&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">int cyc_empty(cycle *L)&#123;   //循环队列判空 ,空返回0，非空返回1 </span><br><span class="line">	if(L-&gt;rear==L-&gt;front)</span><br><span class="line">		return 0;</span><br><span class="line">	else return 1;</span><br><span class="line">&#125;</span><br><span class="line">int cyc_fill(cycle *L)&#123;  //循环队列判满，满返回1，没满返回0 </span><br><span class="line">	 return ((L-&gt;rear+1)%11==L-&gt;front)?1:0;  //满了返回1，没满返回0 </span><br><span class="line">&#125;</span><br><span class="line">int cyc_sum(cycle *L)&#123;  //循环队列计算个数</span><br><span class="line">	return (L-&gt;rear-L-&gt;front+11)%11; </span><br><span class="line">&#125;  </span><br><span class="line">void cyc_print(cycle *L)&#123;</span><br><span class="line">	while(L-&gt;rear!=L-&gt;front)&#123;</span><br><span class="line">		printf(&quot;%d &quot;,L-&gt;a[L-&gt;front]);</span><br><span class="line">		L-&gt;front=(L-&gt;front+1)%11;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	ht *q;q=creat();</span><br><span class="line">//	printf(&quot;%d\n&quot;,empty(q));</span><br><span class="line">//	q=insert(q,3);q=insert(q,3);q=insert(q,3);</span><br><span class="line">//	q=dele(q);</span><br><span class="line">//	print(q);</span><br><span class="line">	cycle L;</span><br><span class="line">	creat(&amp;L); </span><br><span class="line">	cyc_insert(&amp;L,3);cyc_insert(&amp;L,4);</span><br><span class="line">	cyc_print(&amp;L);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>蜀道山wp</title>
    <url>/posts/46980/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="Map-Maze"><a href="#Map-Maze" class="headerlink" title="Map_Maze"></a>Map_Maze</h2><p>非常好的一道迷宫题，击碎了我对指针的自信~~</p>
<p>主函数：</p>
<img src="/posts/46980/image-20241203205913912.png" class="" title="image-20241203205913912">

<p>但是建图函数和判断函数极其抽象。建图函数先截取一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl create_map(_DWORD *a1, _DWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  for ( i = 0; i &lt; 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( j = 0; j &lt; 15; ++j )</span><br><span class="line">      v5[15 * i + j] = sub_401080(0);   //先分配255个空间（不连续的），地址作为数组v5的元素（实际越界到了v6）</span><br><span class="line">  &#125;</span><br><span class="line">  for ( k = 1; k &lt; 15; ++k )</span><br><span class="line">    *(_DWORD *)v5[k] = 1;        //这里的赋值是取v5[i]的值转化为指针，将指针指向的地址赋值为1（或0）</span><br><span class="line">  for ( m = 9; m &lt; 15; ++m )</span><br><span class="line">    *(_DWORD *)v5[m + 15] = 1;</span><br><span class="line">    ......      //省略了中间的赋值环节</span><br><span class="line">    ......</span><br><span class="line">  for ( i27 = 13; i27 &lt; 15; ++i27 )</span><br><span class="line">    *(_DWORD *)v6[i27 + 90] = 1;</span><br><span class="line">  for ( i28 = 0; i28 &lt; 12; ++i28 )</span><br><span class="line">    *(_DWORD *)v6[i28 + 105] = 1;</span><br><span class="line">  for ( i29 = 0; i29 &lt; 15; ++i29 )     //这个双循环是重头戏：</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i30 = 0; i30 &lt; 15; ++i30 )     </span><br><span class="line">    &#123;     //为了方便表示，我将*v5[15 * i29 + i30]写为a[],也就是指针a等于v5对应下标的元素转化为的指针</span><br><span class="line">      if ( i29 &gt; 0 )    //i29&gt;0，说明不在第一行，意味着上方元素存在</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 4) = v5[15 * i29 - 15 + i30];  //将上方元素的地址赋值给a[1]</span><br><span class="line">      if ( i29 &lt; 14 )   //不在最后一行，即下方元素存在</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 8) = v5[15 * i29 + 15 + i30];  //将下方元素的地址赋值给a[2]</span><br><span class="line">      if ( i30 &gt; 0 )</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 12) = v5[15 * i29 - 1 + i30];  //将左方元素的地址赋值给a[3]</span><br><span class="line">      if ( i30 &lt; 14 )</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 16) = v5[15 * i29 + 1 + i30];  //将右方元素的地址赋值给a[4]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;       //下面是定义起点和终点</span><br><span class="line">  v2 = (_DWORD *)v5[0];      //先取出v5第一个元素，转化为地址赋值给v2</span><br><span class="line">  *a1 = *(_DWORD *)v5[0];    //a1是起点，将V5第一个元素指向的值传给a1指向的地址（传的是1或0）</span><br><span class="line">  a1[1] = v2[1];     		 //将v2[1]（对应前面双循环赋值的上方元素）赋值给a1[1]</span><br><span class="line">  a1[2] = v2[2];			 //将v2[2]（对应前面双循环赋值的下方元素）赋值给a1[2]</span><br><span class="line">  a1[3] = v2[3];			 //将v2[3]（对应前面双循环赋值的左方元素）赋值给a1[3]</span><br><span class="line">  a1[4] = v2[4];			 //将v2[4]（对应前面双循环赋值的右方元素）赋值给a1[4]</span><br><span class="line">  v3 = v7;		//下面就是定义终点了，逻辑与定义起点相同</span><br><span class="line">  *a2 = *v7;</span><br><span class="line">  a2[1] = v3[1];</span><br><span class="line">  a2[2] = v3[2];</span><br><span class="line">  a2[3] = v3[3];</span><br><span class="line">  result = v3[4];</span><br><span class="line">  a2[4] = result;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a[0]处存的是v5[i]指向的地址的值（0或1），a[1]~a[4]正常情况填的都是地址，如果上下左右对应的地方（地图v5里面）不存在值的话就不用填入地址</p>
<p>![屏幕截图 2024-12-03 222145](.&#x2F;蜀道山wp&#x2F;屏幕截图 2024-12-03 222145.png)</p>
<p>判断函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char __cdecl judge_path(_DWORD *a1, _DWORD *a2, int a3)  //a1是位置，a2是终点，a3是输入</span><br><span class="line">&#123;</span><br><span class="line">  for ( i = 0; *(_BYTE *)(i + a3); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *(_BYTE *)(i + a3) == &#x27;U&#x27; &amp;&amp; a1[1] &amp;&amp; !*(_DWORD *)a1[1] )   //输入&quot;U&quot;且上方元素存在</span><br><span class="line">    &#123;</span><br><span class="line">      a1 = (_DWORD *)a1[1];     //a1[1]存的是其上方的地址</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *(_BYTE *)(i + a3) == &#x27;D&#x27; &amp;&amp; a1[2] &amp;&amp; !*(_DWORD *)a1[2] )   //&quot;D&quot;则取其下方的地址</span><br><span class="line">    &#123;</span><br><span class="line">      a1 = (_DWORD *)a1[2];   </span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *(_BYTE *)(i + a3) == &#x27;L&#x27; &amp;&amp; a1[3] &amp;&amp; !*(_DWORD *)a1[3] )</span><br><span class="line">    &#123;</span><br><span class="line">      a1 = (_DWORD *)a1[3];     //a1[3]存的是其左方的地址</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(_BYTE *)(i + a3) != &#x27;R&#x27; || !a1[4] || *(_DWORD *)a1[4] )</span><br><span class="line">        return 0;</span><br><span class="line">      a1 = (_DWORD *)a1[4];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result = (char)a2;</span><br><span class="line">  if ( a1[2] == a2[2] )    //下面是判断其上下左右的值是否对的上，如果对的上，这返回1</span><br><span class="line">  &#123;</span><br><span class="line">    result = (char)a2;</span><br><span class="line">    if ( a1[1] == a2[1] )</span><br><span class="line">    &#123;</span><br><span class="line">      result = (char)a2;</span><br><span class="line">      if ( a1[3] == a2[3] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = (char)a2;</span><br><span class="line">        if ( a1[4] == a2[4] )</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以真正的地图就是v5[i]指向的位置汇成的一张15x15的地图，由0和1构成。</p>
<p>怎么提取出地图来呢？可以把伪代码复制修改再运行一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int i28; // [esp+384h] [ebp-A0h]</span><br><span class="line">  int i27; // [esp+388h] [ebp-9Ch]</span><br><span class="line">  int i26; // [esp+38Ch] [ebp-98h]</span><br><span class="line">  int i25; // [esp+390h] [ebp-94h]</span><br><span class="line">  int i24; // [esp+394h] [ebp-90h]</span><br><span class="line">  int i23; // [esp+398h] [ebp-8Ch]</span><br><span class="line">  int i22; // [esp+39Ch] [ebp-88h]</span><br><span class="line">  int i21; // [esp+3A0h] [ebp-84h]</span><br><span class="line">  int i20; // [esp+3A4h] [ebp-80h]</span><br><span class="line">  int i19; // [esp+3A8h] [ebp-7Ch]</span><br><span class="line">  int i18; // [esp+3ACh] [ebp-78h]</span><br><span class="line">  int i17; // [esp+3B0h] [ebp-74h]</span><br><span class="line">  int i16; // [esp+3B4h] [ebp-70h]</span><br><span class="line">  int i15; // [esp+3B8h] [ebp-6Ch]</span><br><span class="line">  int i14; // [esp+3BCh] [ebp-68h]</span><br><span class="line">  int i13; // [esp+3C0h] [ebp-64h]</span><br><span class="line">  int i12; // [esp+3C4h] [ebp-60h]</span><br><span class="line">  int i11; // [esp+3C8h] [ebp-5Ch]</span><br><span class="line">  int i10; // [esp+3CCh] [ebp-58h]</span><br><span class="line">  int i9; // [esp+3D0h] [ebp-54h]</span><br><span class="line">  int i8; // [esp+3D4h] [ebp-50h]</span><br><span class="line">  int i7; // [esp+3D8h] [ebp-4Ch]</span><br><span class="line">  int i6; // [esp+3DCh] [ebp-48h]</span><br><span class="line">  int i5; // [esp+3E0h] [ebp-44h]</span><br><span class="line">  int i4; // [esp+3E4h] [ebp-40h]</span><br><span class="line">  int i3; // [esp+3E8h] [ebp-3Ch]</span><br><span class="line">  int i2; // [esp+3ECh] [ebp-38h]</span><br><span class="line">  int i1; // [esp+3F0h] [ebp-34h]</span><br><span class="line">  int nn; // [esp+3F4h] [ebp-30h]</span><br><span class="line">  int mm; // [esp+3F8h] [ebp-2Ch]</span><br><span class="line">  int kk; // [esp+3FCh] [ebp-28h]</span><br><span class="line">  int jj; // [esp+400h] [ebp-24h]</span><br><span class="line">  int ii; // [esp+404h] [ebp-20h]</span><br><span class="line">  int n; // [esp+408h] [ebp-1Ch]</span><br><span class="line">  int m; // [esp+40Ch] [ebp-18h]</span><br><span class="line">  int k; // [esp+410h] [ebp-14h]</span><br><span class="line">  int j; // [esp+414h] [ebp-10h]</span><br><span class="line">  int i; // [esp+418h] [ebp-Ch]</span><br><span class="line">  int i30; // [esp+41Ch] [ebp-8h]</span><br><span class="line">  int i29; // [esp+420h] [ebp-4h]</span><br><span class="line">    int maze[225]=&#123;0&#125;;</span><br><span class="line">    int *v5=maze;</span><br><span class="line">    int *v6=maze+105;</span><br><span class="line">  for ( k = 1; k &lt; 15; ++k )</span><br><span class="line">    v5[k] = 1;</span><br><span class="line">  for ( m = 9; m &lt; 15; ++m )</span><br><span class="line">    v5[m + 15] = 1;</span><br><span class="line">  for ( n = 0; n &lt; 2; ++n )</span><br><span class="line">    v5[n + 30] = 1;</span><br><span class="line">  for ( ii = 3; ii &lt; 8; ++ii )</span><br><span class="line">    v5[ii + 30] = 1;</span><br><span class="line">  for ( jj = 9; jj &lt; 15; ++jj )</span><br><span class="line">    v5[jj + 30] = 1;</span><br><span class="line">  for ( kk = 0; kk &lt; 2; ++kk )</span><br><span class="line">    v5[kk + 45] = 1;</span><br><span class="line">  for ( mm = 3; mm &lt; 8; ++mm )</span><br><span class="line">    v5[mm + 45] = 1;</span><br><span class="line">  for ( nn = 12; nn &lt; 15; ++nn )</span><br><span class="line">    v5[nn + 45] = 1;</span><br><span class="line">  for ( i1 = 0; i1 &lt; 2; ++i1 )</span><br><span class="line">    v5[i1 + 60] = 1;</span><br><span class="line">  for ( i2 = 7; i2 &lt; 10; ++i2 )</span><br><span class="line">    v5[i2 + 60] = 0;</span><br><span class="line">  v5[67] = 1;</span><br><span class="line">  for ( i3 = 11; i3 &lt; 15; ++i3 )</span><br><span class="line">    v5[i3 + 60] = 1;</span><br><span class="line">  for ( i4 = 0; i4 &lt; 2; ++i4 )</span><br><span class="line">    v5[i4 + 75] = 1;</span><br><span class="line">  for ( i5 = 3; i5 &lt; 6; ++i5 )</span><br><span class="line">    v5[i5 + 75] = 1;</span><br><span class="line">  for ( i6 = 11; i6 &lt; 15; ++i6 )</span><br><span class="line">    v5[i6 + 75] = 1;</span><br><span class="line">  for ( i7 = 0; i7 &lt; 2; ++i7 )</span><br><span class="line">    v5[i7 + 90] = 1;</span><br><span class="line">  v5[92] = 0;</span><br><span class="line">  for ( i8 = 3; i8 &lt; 6; ++i8 )</span><br><span class="line">    v5[i8 + 90] = 1;</span><br><span class="line">  for ( i9 = 7; i9 &lt; 10; ++i9 )</span><br><span class="line">    v5[i9 + 90] = 1;</span><br><span class="line">  for ( i10 = 11; i10 &lt; 15; ++i10 )</span><br><span class="line">    v5[i10 + 90] = 1;</span><br><span class="line">  v6[0] = 1;</span><br><span class="line">  v6[1] = 0;</span><br><span class="line">  v6[2] = 0;</span><br><span class="line">  v6[3] = 1;</span><br><span class="line">  for ( i11 = 4; i11 &lt; 6; ++i11 )</span><br><span class="line">    v6[i11] = 1;</span><br><span class="line">  for ( i12 = 7; i12 &lt; 10; ++i12 )</span><br><span class="line">    v6[i12] = 1;</span><br><span class="line">  for ( i13 = 11; i13 &lt; 15; ++i13 )</span><br><span class="line">    v6[i13] = 1;</span><br><span class="line">  for ( i14 = 0; i14 &lt; 2; ++i14 )</span><br><span class="line">    v6[i14 + 15] = 1;</span><br><span class="line">  for ( i15 = 7; i15 &lt; 10; ++i15 )</span><br><span class="line">    v6[i15 + 15] = 1;</span><br><span class="line">  for ( i16 = 11; i16 &lt; 15; ++i16 )</span><br><span class="line">    v6[i16 + 15] = 1;</span><br><span class="line">  for ( i17 = 0; i17 &lt; 6; ++i17 )</span><br><span class="line">    v6[i17 + 30] = 1;</span><br><span class="line">  for ( i18 = 7; i18 &lt; 10; ++i18 )</span><br><span class="line">    v6[i18 + 30] = 1;</span><br><span class="line">  for ( i19 = 11; i19 &lt; 15; ++i19 )</span><br><span class="line">    v6[i19 + 30] = 1;</span><br><span class="line">  for ( i20 = 0; i20 &lt; 6; ++i20 )</span><br><span class="line">    v6[i20 + 45] = 1;</span><br><span class="line">  for ( i21 = 11; i21 &lt; 15; ++i21 )</span><br><span class="line">    v6[i21 + 45] = 1;</span><br><span class="line">  for ( i22 = 0; i22 &lt; 9; ++i22 )</span><br><span class="line">    v6[i22 + 60] = 1;</span><br><span class="line">  for ( i23 = 13; i23 &lt; 15; ++i23 )</span><br><span class="line">    v6[i23 + 60] = 1;</span><br><span class="line">  for ( i24 = 0; i24 &lt; 9; ++i24 )</span><br><span class="line">    v6[i24 + 75] = 1;</span><br><span class="line">  v6[84] = 0;</span><br><span class="line">  v6[85] = 1;</span><br><span class="line">  v6[86] = 1;</span><br><span class="line">  v6[87] = 0;</span><br><span class="line">  for ( i25 = 13; i25 &lt; 15; ++i25 )</span><br><span class="line">    v6[i25 + 75] = 1;</span><br><span class="line">  for ( i26 = 0; i26 &lt; 9; ++i26 )</span><br><span class="line">    v6[i26 + 90] = 1;</span><br><span class="line">  v6[99] = 0;</span><br><span class="line">  v6[100] = 1;</span><br><span class="line">  v6[101] = 1;</span><br><span class="line">  v6[102] = 0;</span><br><span class="line">  for ( i27 = 13; i27 &lt; 15; ++i27 )</span><br><span class="line">    v6[i27 + 90] = 1;</span><br><span class="line">  for ( i28 = 0; i28 &lt; 12; ++i28 )</span><br><span class="line">    v6[i28 + 105] = 1;</span><br><span class="line">  for(i=0;i&lt;15;i++)&#123;</span><br><span class="line">    for(j=0;j&lt;15;j++)&#123;</span><br><span class="line">        if(maze[i*15+j]==0) printf(&quot;  &quot;);   //这里不打印0和1是为了让打印出地图更好看</span><br><span class="line">        else printf(&quot;o &quot;,maze[i*15+j]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  o o o o o o o o o o o o o o </span><br><span class="line">                  o o o o o o</span><br><span class="line">o o   o o o o o   o o o o o o</span><br><span class="line">o o   o o o o o         o o o</span><br><span class="line">o o           o       o o o o</span><br><span class="line">o o   o o o           o o o o</span><br><span class="line">o o   o o o   o o o   o o o o</span><br><span class="line">o     o o o   o o o   o o o o</span><br><span class="line">o o           o o o   o o o o</span><br><span class="line">o o o o o o   o o o   o o o o</span><br><span class="line">o o o o o o           o o o o</span><br><span class="line">o o o o o o o o o         o o</span><br><span class="line">o o o o o o o o o   o o   o o</span><br><span class="line">o o o o o o o o o   o o   o o</span><br><span class="line">o o o o o o o o o o o o</span><br></pre></td></tr></table></figure>

<p>路径：DRRDDDDDDDRRRRDDRRRDRRRDDDRR</p>
<p>md5结果：1979869e0c4ef6c542e54ae5c48f63ec</p>
<p>flag：LZSDS{1979869e0c4ef6c542e54ae5c48f63ec}</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>楚慧杯2024wp</title>
    <url>/posts/64455/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="go-bytes"><a href="#go-bytes" class="headerlink" title="go_bytes"></a>go_bytes</h2><p>第一段加密代码：</p>
<img src="/posts/64455/image-20241220172142353.png" class="" title="image-20241220172142353">

<p>第二段加密代码：</p>
<img src="/posts/64455/image-20241220172212964.png" class="" title="image-20241220172212964">

<p>主要逻辑可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i;unsigned char v5[40];</span><br><span class="line">    unsigned int data[]=&#123;0x22b9,0xc9f8,0x8c89,0xff18,0x1439,0x4e0a,0x2a8b,0x7cb,0xbdeb,0xfaab,</span><br><span class="line">                0x3ffb,0x784b,0x9f1e,0x4feb,0x4d0b,0xd08e,0x38bb,0xcbae,0xd2ce,0x913e,</span><br><span class="line">                0xa6b,0xf03b,0x507b,0x398b,0x93de,0x3cce,0x459e,0x4abe,0x553e,0x316e,</span><br><span class="line">                0x33be,0x42fe,0xcece,0x4dde,0x982b,0xa31b,0x802e,0x12ee,0xf67a,0xeb79&#125;;</span><br><span class="line">    scanf(&quot;%s&quot;,v5);</span><br><span class="line">    for(i=0;i&lt;39;i++)</span><br><span class="line">      v5[i]=(v5[i+1]&gt;&gt;4)|(v5[i]*16);</span><br><span class="line">    v5[39]=(v5[0]&gt;&gt;4)|(v5[39]&lt;&lt;4);</span><br><span class="line">    int j;int main_tmp=0xDEAD;</span><br><span class="line">    for(j=0;j&lt;40;j++)&#123;</span><br><span class="line">        main_tmp=(unsigned __int16)(291 * main_tmp + 1110);</span><br><span class="line">          if(data[j]!=(main_tmp^v5[j]))&#123;</span><br><span class="line">              printf(&quot;wrong!&quot;);</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	printf(&quot;right!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里这个main_tmp数组我们可以直接运行得到。主要还是对第一段加密的逆向：</p>
<p>第一段加密主要逻辑是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// v5[38]=v5[38]低4位+v5[39]高4位</span><br><span class="line">// v5[37]=v5[37]低4位+v5[38]高4位</span><br><span class="line">// ······</span><br><span class="line">// v5[0]=v5[0]低4位+v5[1]高4位</span><br><span class="line">// v5[39]=v5[39]低4位+v5[0]高4位</span><br></pre></td></tr></table></figure>

<p>于是v5[38]的原高4位在v5[37]的低4位，原低四位在其高四位里，以此类推。写脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int main_tmp[]=&#123;0x22fd,0xc9ed,0x8cbd,0xff2d,0x147d,0x4e6d,0x2a3d,0x7ad,0xbdfd,0xfaed,</span><br><span class="line">                    0x3fbd,0x782d,0x9f7d,0x4f6d,0x4d3d,0xd0ad,0x38fd,0xcbed,0xd2bd,0x912d,</span><br><span class="line">                    0xa7d,0xf06d,0x503d,0x39ad,0x93fd,0x3ced,0x45bd,0x4a2d,0x557d,0x316d,</span><br><span class="line">                    0x333d,0x42ad,0xcefd,0x4ded,0x98bd,0xa32d,0x807d,0x126d,0xf63d,0xebad&#125;;</span><br><span class="line">    int i,j;</span><br><span class="line">    unsigned int data[]=&#123;0x22b9,0xc9f8,0x8c89,0xff18,0x1439,0x4e0a,0x2a8b,0x7cb,0xbdeb,0xfaab,</span><br><span class="line">                0x3ffb,0x784b,0x9f1e,0x4feb,0x4d0b,0xd08e,0x38bb,0xcbae,0xd2ce,0x913e,</span><br><span class="line">                0xa6b,0xf03b,0x507b,0x398b,0x93de,0x3cce,0x459e,0x4abe,0x553e,0x316e,</span><br><span class="line">                0x33be,0x42fe,0xcece,0x4dde,0x982b,0xa31b,0x802e,0x12ee,0xf67a,0xeb79&#125;;</span><br><span class="line">    for(i=0;i&lt;40;i++)</span><br><span class="line">        data[i]^=main_tmp[i];</span><br><span class="line">    unsigned char flag[40];</span><br><span class="line">    for(i=1;i&lt;40;i++)&#123;</span><br><span class="line">        flag[i]=(data[i]&gt;&gt;4)|(data[i-1]&lt;&lt;4);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[0]=(data[0]&gt;&gt;4)|(data[39]&lt;&lt;4);</span><br><span class="line">    for(i=0;i&lt;40;i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   //DASCTF&#123;faddff8cb4d711edbb2294085339ce84&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bouquet"><a href="#bouquet" class="headerlink" title="bouquet"></a>bouquet</h2><p>题目描述:</p>
<p><code>简单的花指令去除，二叉树的中序、后序、层次遍历代码的识别</code></p>
<p>数据结构还在追我🤣。</p>
<p>先去个花指令：</p>
<img src="/posts/64455/image-20241220173902805.png" class="" title="image-20241220173902805">

<p>重新选定，按P构造函数，反编译：</p>
<img src="/posts/64455/image-20241220174051218.png" class="" title="image-20241220174051218">

<p>一开始没看题目描述，没看懂这是干什么东西，然后进判断函数看到了递归就觉得有点可疑，去看了一下描述才发现是二叉树。上面这一段是建树。</p>
<img src="/posts/64455/image-20241220174323830.png" class="" title="image-20241220174323830">

<p>建完树之后有上面两个判断函数，一个是中序遍历，一个是后序遍历：</p>
<img src="/posts/64455/image-20241220174442323.png" class="" title="image-20241220174442323">

<img src="/posts/64455/image-20241220174500667.png" class="" title="image-20241220174500667">

<p>于是，主要逻辑就浮现出来了：</p>
<p>输入的flag进行二叉树建树，然后进入第一个函数判断中序遍历序列是否为“ja7Cws_A3daTd4qDo8}F_Sd{a”，之后进入第二个函数判断后序遍历序列是否为“j7aw_sC3addq4TAo}8_Fda{SD”。层次遍历结果就是flag。</p>
<p>写代码求中序遍历及后序遍历满足条件的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, value=&#x27;&#x27;):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line">def build_tree(inorder, postorder):</span><br><span class="line">    if not inorder or not postorder:</span><br><span class="line">        return None</span><br><span class="line">    </span><br><span class="line">    root_value = postorder.pop()</span><br><span class="line">    root = TreeNode(root_value)</span><br><span class="line">    </span><br><span class="line">    root_index = inorder.index(root_value)</span><br><span class="line">    </span><br><span class="line">    root.right = build_tree(inorder[root_index + 1:], postorder)</span><br><span class="line">    root.left = build_tree(inorder[:root_index], postorder)</span><br><span class="line">    </span><br><span class="line">    return root</span><br><span class="line"></span><br><span class="line">def preorder_traversal(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    return root.value + preorder_traversal(root.left) + preorder_traversal(root.right)</span><br><span class="line"></span><br><span class="line">def print_tree_structure(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return &quot;None&quot;</span><br><span class="line">    return f&quot;(&#123;root.value&#125;, &#123;print_tree_structure(root.left)&#125;, &#123;print_tree_structure(root.right)&#125;)&quot;</span><br><span class="line"></span><br><span class="line"># 层次遍历函数</span><br><span class="line">def level_order_traversal(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    </span><br><span class="line">    while queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        result.append(node.value)</span><br><span class="line">        </span><br><span class="line">        if node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        if node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    </span><br><span class="line">    return &quot; &quot;.join(result)</span><br><span class="line"></span><br><span class="line"># 给定的中序和后序遍历结果</span><br><span class="line">inorder = &quot;ja7Cws_A3daTd4qDo8&#125;F_Sd&#123;a&quot;</span><br><span class="line">postorder = list(&quot;j7aw_sC3addq4TAo&#125;8_Fda&#123;SD&quot;)</span><br><span class="line"></span><br><span class="line"># 构建二叉树</span><br><span class="line">root = build_tree(list(inorder), postorder)</span><br><span class="line"></span><br><span class="line"># 输出树的前序遍历结果</span><br><span class="line">preorder_result = preorder_traversal(root)</span><br><span class="line">print(f&quot;前序遍历结果: &#123;preorder_result&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 输出树的层次遍历结果</span><br><span class="line">level_order_result = level_order_traversal(root)</span><br><span class="line">print(f&quot;层次遍历结果: &#123;level_order_result&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 输出树的结构</span><br><span class="line">tree_structure = print_tree_structure(root)</span><br><span class="line">print(f&quot;树的结构: &#123;tree_structure&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 层次遍历结果: DASCTF&#123;asd48_daj7w_3adqo&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define num 26</span><br><span class="line">char mid[] = &quot;ja7Cws_A3daTd4qDo8&#125;F_Sd&#123;a&quot;;</span><br><span class="line">char post[] = &quot;j7aw_sC3addq4TAo&#125;8_Fda&#123;SD&quot;;</span><br><span class="line">// 目标：给出中序遍历和后序遍历序列，求出完全二叉树结构（打印出层次遍历序列）</span><br><span class="line">typedef struct tree</span><br><span class="line">&#123;</span><br><span class="line">	char c;</span><br><span class="line">	struct tree *left,*right;</span><br><span class="line">&#125;tree;</span><br><span class="line">tree *creat(int ms,int me,int ps,int pe)&#123;   // 反推树的结构</span><br><span class="line">	if(ms&gt;me||ps&gt;pe) return NULL;</span><br><span class="line">	tree *t=(tree  *)malloc(sizeof(tree));</span><br><span class="line">	char charAt=post[pe];</span><br><span class="line">	int i;</span><br><span class="line">	for(i=ms;i&lt;=me&amp;&amp;mid[i]!=charAt;i++) &#123;&#125;</span><br><span class="line">	t-&gt;c=charAt;</span><br><span class="line">	t-&gt;left=creat(ms,i-1,ps, ps + i - ms - 1);</span><br><span class="line">	t-&gt;right=creat(i+1,me, ps + i - ms,pe-1);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">void pre_travel(tree *t)&#123;    // 前序遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	printf(&quot;%c&quot;,t-&gt;c);</span><br><span class="line">	pre_travel(t-&gt;left);</span><br><span class="line">	pre_travel(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">// 层次遍历</span><br><span class="line">typedef struct q&#123;  // 创建队列</span><br><span class="line">	tree *c[num];</span><br><span class="line">	int r,f;</span><br><span class="line">&#125;queue;</span><br><span class="line">void init(queue *q)&#123;   //初始化队列</span><br><span class="line">	q-&gt;r=q-&gt;f=0;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q,tree *t) &#123; // 入队</span><br><span class="line">	if((q-&gt;f+1)%num==q-&gt;r) &#123;printf(&quot;队满！\n&quot;);return;&#125;</span><br><span class="line">	q-&gt;c[q-&gt;f]=t;</span><br><span class="line">	q-&gt;f=(q-&gt;f+1)%num;</span><br><span class="line">&#125;</span><br><span class="line">tree *dequeue(queue *q) &#123;  // 出队</span><br><span class="line">	if(q-&gt;f==q-&gt;r) &#123;printf(&quot;队空！\n&quot;);return NULL;&#125;</span><br><span class="line">	tree *temp=q-&gt;c[q-&gt;r];</span><br><span class="line">	q-&gt;r=(q-&gt;r+1)%num;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void level_travel(tree *t)&#123;  //  层次遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	queue *q=(queue *)malloc(sizeof(queue));</span><br><span class="line">	tree *temp;</span><br><span class="line">	init(q);</span><br><span class="line">	enqueue(q,t);</span><br><span class="line">	while(q-&gt;f!=q-&gt;r)&#123;</span><br><span class="line">		temp=dequeue(q);</span><br><span class="line">		printf(&quot;%c&quot;,temp-&gt;c);</span><br><span class="line">		if(temp-&gt;left!=NULL) enqueue(q,temp-&gt;left);</span><br><span class="line">		if(temp-&gt;right!=NULL) enqueue(q,temp-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	free(q);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	tree *t=creat(0,strlen(mid)-1,0,strlen(post)-1);</span><br><span class="line">	// pre_travel(t);</span><br><span class="line">	level_travel(t);</span><br><span class="line">&#125;</span><br><span class="line">//层次遍历结果: DASCTF&#123;asd48_daj7w_3adqo&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>调用.exe爆破</title>
    <url>/posts/64193/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h3 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h3><p>CISCN的一个题包含一个.exe文件（加密）和一个文本文件（存放密文），由于.exe文件逻辑比较复杂，如果直接进行逆向来推出flag的话，比较难，于是可以用python的subprocess模块来调用.exe文件进行逐个字符爆破。</p>
<p>.exe文件主要作用：每次读取一个字符串，进行加密，加密后会与文本文件的密文相等</p>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>使用<code>subprocess.run()</code> 调用<code>.exe</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = subprocess.run([&#x27;A&#x27;, &#x27;B&#x27;], capture_output=True, text=True)</span><br><span class="line">A: 文件地址</span><br><span class="line">B: 需要传入函数的参数</span><br><span class="line">capture_output=True: 捕获输出</span><br><span class="line">text=True: 确保输出以字符串形式而不是字节形式返回</span><br><span class="line">返回值: CompletedProcess实例</span><br></pre></td></tr></table></figure>

<p><code>CompletedProcess</code> 实例有以下几个属性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">args: 传递给 run() 的参数（通常是命令和参数列表），以供参考。</span><br><span class="line">returncode: 子进程退出时的状态码。通常，成功执行的命令会返回 0，而非零值表示发生了错误。</span><br><span class="line">stdout: 如果指定了 capture_output=True 或 stdout=PIPE，则包含标准输出的数据；否则为 None。</span><br><span class="line">text: 如果 text=True，那么 stdout 将是字符串；否则，它将是字节对象。</span><br><span class="line">stderr: 类似于 stdout，但是包含了标准错误流的数据。</span><br></pre></td></tr></table></figure>

<p>其中stdout包含了输出流，可以使用result.stdout获取输出流</p>
<p>脚本示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import string</span><br><span class="line">table = string.printable   # 可打印字符表</span><br><span class="line">data = [&quot;23&quot;, &quot;29&quot;, &quot;1e&quot;, &quot;24&quot;, &quot;38&quot;,</span><br><span class="line">       &quot;0e&quot;, &quot;15&quot;, &quot;20&quot;, &quot;37&quot;, &quot;0e&quot;,</span><br><span class="line">       &quot;05&quot;, &quot;20&quot;, &quot;00&quot;, &quot;0e&quot;, &quot;37&quot;,</span><br><span class="line">       &quot;12&quot;, &quot;1d&quot;, &quot;0f&quot;, &quot;24&quot;, &quot;01&quot;, &quot;01&quot;, &quot;39&quot;]   # 密文</span><br><span class="line"></span><br><span class="line">flag = &#x27;flag&#123;&#x27;    # 已知的前缀</span><br><span class="line">index = 5</span><br><span class="line">while index&lt;len(data):</span><br><span class="line">    if index == 14:     # 这是提示给的</span><br><span class="line">        flag += &#x27;4&#x27;</span><br><span class="line">        index += 1</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    for char in table:</span><br><span class="line">        temp = flag + char</span><br><span class="line">        result = subprocess.run([&quot;C:/Users/tzs/Desktop/bin/re.exe&quot;,temp],capture_output=True, text=True)</span><br><span class="line">        out_put = result.stdout   # 这里得到一个十六进制字符串</span><br><span class="line">        out_list = [out_put[i:i+2] for i in range(0,len(out_put),2)]         # 把每两个字符拆成一个十六进制数</span><br><span class="line">        if out_list[index] == data[index]: </span><br><span class="line">            flag += char</span><br><span class="line">            index += 1</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/posts/1079/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="第一周：模拟队列管理"><a href="#第一周：模拟队列管理" class="headerlink" title="第一周：模拟队列管理"></a>第一周：模拟队列管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 队列的管理过程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 11</span><br><span class="line">typedef struct queue&#123;</span><br><span class="line">    int rear,front;</span><br><span class="line">    int arr[max];</span><br><span class="line">&#125;queue;</span><br><span class="line">void init(queue *q)&#123;  //队列初始化</span><br><span class="line">    q-&gt;front=q-&gt;rear=0;</span><br><span class="line">&#125;</span><br><span class="line">void print_queue(queue *q)&#123;  //打印队列</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;该队列为：\n&quot;);</span><br><span class="line">    for(i=q-&gt;front;i&lt;q-&gt;rear;i++) printf(&quot;%d &quot;,q-&gt;arr[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int is_full(queue *q)&#123;  //判满</span><br><span class="line">    return (q-&gt;rear+1)%max==q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line">int is_empty(queue *q)&#123;  //判空</span><br><span class="line">    return q-&gt;front==q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">queue *creat()&#123;  // 创建队列</span><br><span class="line">    int i,num,data;</span><br><span class="line">    queue *q;</span><br><span class="line">    q=(queue *)malloc(sizeof(queue));</span><br><span class="line">    init(q);</span><br><span class="line">    printf(&quot;请输入需要创建队列的个数:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        printf(&quot;请输入你需要插入的值:&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;data);</span><br><span class="line">        if(is_full(q)==1) &#123;printf(&quot;队列已满!/n&quot;);break;&#125;</span><br><span class="line">        q-&gt;arr[q-&gt;rear]=data;</span><br><span class="line">        q-&gt;rear=(q-&gt;rear+1)%max;</span><br><span class="line">    &#125;</span><br><span class="line">    return q;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q)&#123;  // 入队</span><br><span class="line">    int data;</span><br><span class="line">    printf(&quot;请输入你需要插入的值:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;data);</span><br><span class="line">    if(is_full(q)==1) &#123;printf(&quot;队列已满!/n&quot;);return;&#125;</span><br><span class="line">    q-&gt;arr[q-&gt;rear]=data;</span><br><span class="line">    q-&gt;rear=(q-&gt;rear+1)%max;</span><br><span class="line">&#125;</span><br><span class="line">int dequeue(queue *q)&#123;  // 出队</span><br><span class="line">    int data;</span><br><span class="line">    if(is_empty(q)) &#123;printf(&quot;队列为空!\n&quot;);return -1;&#125;</span><br><span class="line">    data=q-&gt;arr[q-&gt;front];</span><br><span class="line">    q-&gt;front=(q-&gt;front+1)%max;</span><br><span class="line">    printf(&quot;出队的元素为：%d\n&quot;,data);</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">void clear(queue *q)&#123;  // 清空队列</span><br><span class="line">    q-&gt;front=q-&gt;rear=0;</span><br><span class="line">&#125;</span><br><span class="line">void print_table()&#123;  // 打印操作表</span><br><span class="line">    printf(&quot;********************************\n&quot;);</span><br><span class="line">    printf(&quot;*1、新建                       *\n&quot;);</span><br><span class="line">    printf(&quot;*2、初始化                     *\n&quot;);</span><br><span class="line">    printf(&quot;*3、出队                       *\n&quot;);</span><br><span class="line">    printf(&quot;*4、入队                       *\n&quot;);</span><br><span class="line">    printf(&quot;*5、打印队列                   *\n&quot;);</span><br><span class="line">    printf(&quot;*6、清空队列                   *\n&quot;);</span><br><span class="line">    printf(&quot;*7、队列是否为满               *\n&quot;);</span><br><span class="line">    printf(&quot;*8、队列是否空                 *\n&quot;);</span><br><span class="line">    printf(&quot;*9、退出                       *\n&quot;);</span><br><span class="line">    printf(&quot;********************************\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x;</span><br><span class="line">    queue *q;</span><br><span class="line">    print_table();</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;请选择要进行的操作:&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        switch(x)&#123;</span><br><span class="line">            case 1:q=creat();</span><br><span class="line">                   print_queue(q);</span><br><span class="line">                   break;</span><br><span class="line">            case 2:init(q);</span><br><span class="line">                    printf(&quot;队列是空的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 3:dequeue(q);</span><br><span class="line">                    print_queue(q);</span><br><span class="line">                    break;</span><br><span class="line">            case 4:enqueue(q);</span><br><span class="line">                    print_queue(q);</span><br><span class="line">                    break;</span><br><span class="line">            case 5:print_queue(q);</span><br><span class="line">                    break;</span><br><span class="line">            case 6:clear(q);</span><br><span class="line">                    if(is_empty(q)) printf(&quot;队列是空的\n&quot;);</span><br><span class="line">                    else printf(&quot;队列不是空的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 7:if(is_full(q)) printf(&quot;队列是满的\n&quot;);</span><br><span class="line">                    else printf(&quot;队列不是满的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 8:if(is_empty(q)) printf(&quot;队列是空的\n&quot;);</span><br><span class="line">                    else printf(&quot;队列不是空的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 9:exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四周：短进程优先调度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int hour;</span><br><span class="line">    int min;</span><br><span class="line">&#125; Time;</span><br><span class="line"></span><br><span class="line">typedef struct Process &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[10];</span><br><span class="line">    Time arrive;</span><br><span class="line">    int zx;</span><br><span class="line">    Time start;</span><br><span class="line">    Time finish;</span><br><span class="line">    int zz;</span><br><span class="line">    float zzxs;</span><br><span class="line">    struct Process* next;</span><br><span class="line">&#125; Process;</span><br><span class="line"></span><br><span class="line">//时间比较函数</span><br><span class="line">int time_cmp(Time a, Time b) &#123;</span><br><span class="line">    return (a.hour * 60 + a.min) - (b.hour * 60 + b.min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//增加指定分钟数</span><br><span class="line">Time add_mins(Time t, int mins) &#123;</span><br><span class="line">    int total = t.hour * 60 + t.min + mins;</span><br><span class="line">    return (Time)&#123;total / 60, total % 60&#125;;</span><br><span class="line">&#125;</span><br><span class="line">//时间差计算（分钟）</span><br><span class="line">int time_diff(Time end, Time start) &#123;</span><br><span class="line">    return (end.hour * 60 + end.min) - (start.hour * 60 + start.min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SJF调度核心算法</span><br><span class="line">void sjf_scheduler(Process** head, int n) &#123;</span><br><span class="line">    Process* scheduled_head = NULL;</span><br><span class="line">    Process* scheduled_tail = NULL;  // 新增尾指针</span><br><span class="line">    Time current_time = &#123;9, 40&#125;;</span><br><span class="line">    int processed = 0;</span><br><span class="line"></span><br><span class="line">    while (processed &lt; n) &#123;</span><br><span class="line">        Process **prev = head;</span><br><span class="line">        Process *sel = NULL;</span><br><span class="line">        int min_time = INT_MAX;</span><br><span class="line">        Process **prev_sel = NULL;</span><br><span class="line"></span><br><span class="line">        while (*prev) &#123;</span><br><span class="line">            if ((*prev)-&gt;start.hour == 0 &amp;&amp; </span><br><span class="line">                time_cmp((*prev)-&gt;arrive, current_time) &lt;= 0) &#123;</span><br><span class="line">                if ((*prev)-&gt;zx &lt; min_time) &#123;</span><br><span class="line">                    min_time = (*prev)-&gt;zx;</span><br><span class="line">                    sel = *prev;</span><br><span class="line">                    prev_sel = prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = &amp;(*prev)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sel) &#123;</span><br><span class="line">            // 设置进程时间</span><br><span class="line">            sel-&gt;start = (time_cmp(current_time, sel-&gt;arrive) &gt; 0) ? </span><br><span class="line">                        current_time : sel-&gt;arrive;</span><br><span class="line">            sel-&gt;finish = add_mins(sel-&gt;start, sel-&gt;zx);</span><br><span class="line">            sel-&gt;zz = time_diff(sel-&gt;finish, sel-&gt;arrive);</span><br><span class="line">            sel-&gt;zzxs = (float)sel-&gt;zz / sel-&gt;zx;</span><br><span class="line">            </span><br><span class="line">            current_time = sel-&gt;finish;</span><br><span class="line">            processed++;</span><br><span class="line">            </span><br><span class="line">            // 从原链表移除</span><br><span class="line">            if (prev_sel) &#123;</span><br><span class="line">                *prev_sel = sel-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 尾部插入</span><br><span class="line">            sel-&gt;next = NULL;</span><br><span class="line">            if (scheduled_head == NULL) &#123;</span><br><span class="line">                scheduled_head = scheduled_tail = sel;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scheduled_tail-&gt;next = sel;</span><br><span class="line">                scheduled_tail = sel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current_time.min++;</span><br><span class="line">            if (current_time.min &gt;= 60) &#123;</span><br><span class="line">                current_time.hour++;</span><br><span class="line">                current_time.min = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *head = scheduled_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int op, n;</span><br><span class="line">    Process *head = NULL;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        printf(&quot;请输入操作(1：开始进程调度；-1：结束进程)：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line">        </span><br><span class="line">        if(op == -1) break;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;请输入进程数：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;id号 名字 到达时间 执行时间\n&quot;);</span><br><span class="line">        for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">            Process *p = (Process*)malloc(sizeof(Process));</span><br><span class="line">            scanf(&quot;%d %s %d:%d %d&quot;, </span><br><span class="line">                 &amp;p-&gt;id, p-&gt;name, </span><br><span class="line">                 &amp;p-&gt;arrive.hour, &amp;p-&gt;arrive.min,</span><br><span class="line">                 &amp;p-&gt;zx);</span><br><span class="line">            p-&gt;start.hour = 0;  // 初始化开始时间</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            head = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sjf_scheduler(&amp;head, n);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;\n模拟短进程优先调度过程结果：\n&quot;);</span><br><span class="line">        printf(&quot;id号 名字 到达时间 执行时间(分钟) 开始时间 完成时间 周转时间(分钟) 带权周转系数\n&quot;);</span><br><span class="line">        </span><br><span class="line">        float total_zz = 0, total_zzxs = 0;</span><br><span class="line">        Process *p = head;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            printf(&quot;%-4d %-4s %02d:%02d %12d   %02d:%02d    %02d:%02d %15d %12.2f\n&quot;,</span><br><span class="line">                  p-&gt;id, p-&gt;name, </span><br><span class="line">                  p-&gt;arrive.hour, p-&gt;arrive.min,</span><br><span class="line">                  p-&gt;zx,</span><br><span class="line">                  p-&gt;start.hour, p-&gt;start.min,</span><br><span class="line">                  p-&gt;finish.hour, p-&gt;finish.min,</span><br><span class="line">                  p-&gt;zz, p-&gt;zzxs);</span><br><span class="line">            </span><br><span class="line">            total_zz += p-&gt;zz;</span><br><span class="line">            total_zzxs += p-&gt;zzxs;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;\n系统平均周转时间为：%.2f\n&quot;, total_zz / n);</span><br><span class="line">        printf(&quot;系统平均带权周转系数为：%.2f\n\n&quot;, total_zzxs / n);</span><br><span class="line">        </span><br><span class="line">        // 内存释放</span><br><span class="line">        while(head) &#123;</span><br><span class="line">            Process *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        head = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1001 p1 9:40 20</span><br><span class="line">// 1004 p4 10:10 10</span><br><span class="line">// 1058 p5 10:05 30 </span><br><span class="line">// 1002 p2 9:55 15</span><br><span class="line">// 1003 p3 9:45 25</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
