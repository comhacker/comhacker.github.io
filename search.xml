<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CISCN2024wp</title>
    <url>/posts/55463/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="ezCsky"><a href="#ezCsky" class="headerlink" title="ezCsky"></a>ezCsky</h2><p>题目描述： 某个新能源汽车使用了国产的交叉编译链对tbox的固件程序进行了编译，你能通过逆向发现其中的秘密吗？</p>
<p>用DIE查看，这是一个elf文件</p>
<p>尝试用ida打开，发现他说“不包括处理器类型mcore”，点击ok就直接退出了</p>
<img src="/posts/55463/image-20241218215831091.png" class="" title="image-20241218215831091">

<p>查了一下题目描述中提到的交叉编译：<strong>交叉编译器</strong>（英语：Cross compiler）是指一个在某个系统平台下可以产生另一个系统平台系的可执行文件的编译器。没什么信息。</p>
<p>使用虚拟机里面的readelf工具查看该elf文件的信息：</p>
<h6 id="readelf工具"><a href="#readelf工具" class="headerlink" title="readelf工具"></a>readelf工具</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：readelf -x 文件名</span><br><span class="line">-h 或 --file-header：显示 ELF 文件头部的信息。*****</span><br><span class="line">-l 或 --program-headers，有时也用 -p：显示程序头部表的内容，这描述了文件如何映射到内存中。</span><br><span class="line">-S 或 --section-headers：显示节头部表的信息，即文件中各节的基本信息。</span><br><span class="line">-s 或 --syms：显示文件的符号表内容。*****</span><br><span class="line">-r 或 --relocs：显示重定位条目。</span><br><span class="line">-d 或 --dynamic：显示动态段的信息，这对于共享库或动态链接的可执行文件尤为重要。</span><br><span class="line">-n 或 --notes：显示任何存在的注释段落。</span><br><span class="line">-u 或 --unwind：显示 unwind 表格信息。</span><br><span class="line">-x SEC 或 --hex-dump=SEC：以十六进制转储指定节的内容。</span><br></pre></td></tr></table></figure>



<img src="/posts/55463/image-20241218220926597.png" class="" title="image-20241218220926597">

<p>发现MCORE架构的，也可以使用file命令：file + 文件名</p>
<img src="/posts/55463/image-20241218221522667.png" class="" title="image-20241218221522667">

<p>发现他是Motorola RCE架构的。</p>
<h6 id="计算机架构："><a href="#计算机架构：" class="headerlink" title="计算机架构："></a>计算机架构：</h6><p>Motorola RCE (RISC Core Engine)，全称为Motorola RISC Core Engine，是由 Motorola开发，基于 RISC 架构的处理器架构。</p>
<p>RISC是一种开源指令集架构。</p>
<p>指令集架构(ISA)是指定计算机硬件如何执行基本操作的一组规则和格式，而处理器架构（如ARM 架构和x86架构）是指处理器内部的具体设计实现，处理器架构必须遵循某个特定的 ISA。ISA 是一个更高层次的概念，定义了处理器应该如何工作；而处理器架构则是更具体的设计实现，描述了实际的硬件是如何构建来满足 ISA 的要求。</p>
<p>由此可以得知，这个elf使用了RISC架构，之前IDA无法反编译是选错了架构。</p>
<p>接着，继续使用readelf查看更多信息：</p>
<p>readelf -s 文件名  ：查看符号表</p>
<img src="/posts/55463/image-2024-12-18223425.png" class="" title="image-2024-12-18223425">

<p>注意到有xor函数、check函数和RC4加密。</p>
<p>接下来使用IDA反编译，需要先手动选择RISC架构：</p>
<img src="/posts/55463/image-2024-12-18223808.png" class="" title="image-2024-12-18223808">

<img src="/posts/55463/image2024-12-18223941.png" class="" title="image2024-12-18223941">

<p>由这里的RC4加密可以推知，’testkey’就是密钥，unk_8AA0就是密文</p>
<img src="/posts/55463/image-20241218224642852.png" class="" title="image-20241218224642852">

<p>直接RC4解密得不到flag，根据前面在符号表里面看到的东西，还有一个xor函数。</p>
<p>先尝试用”flag{“头来反推异或的密钥：</p>
<img src="/posts/55463/image-20241218224927370.png" class="" title="image-20241218224927370">

<p>发现推到的密钥很像flag，意味着它是flag自身进行前后异或。写脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">/*初始化函数*/</span><br><span class="line">void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    char k[256] = &#123; 0 &#125;;</span><br><span class="line">    unsigned char tmp = 0;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = (j + s[i] + k[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[i]和s[j]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">/*加解密*/</span><br><span class="line">void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0, t = 0;</span><br><span class="line">    unsigned long k = 0;</span><br><span class="line">    unsigned char tmp;</span><br><span class="line">    for (k = 0; k&lt;Len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i = (i + 1) % 256;</span><br><span class="line">        j = (j + s[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[x]和s[y]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t = (s[i] + s[j]) % 256;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char flag[]=</span><br><span class="line">    &#123;</span><br><span class="line">     	0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,</span><br><span class="line">        0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,</span><br><span class="line">        0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,</span><br><span class="line">        0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,</span><br><span class="line">        0xED, 0xD1</span><br><span class="line">    &#125;; </span><br><span class="line">    unsigned char key[]=&quot;testkey&quot;;</span><br><span class="line">    unsigned  char s[256]=&#123;0&#125;;</span><br><span class="line">    rc4_init(s,key,7);    //第三位是key长度 </span><br><span class="line">    rc4_crypt(s,flag,42);  //第三位是s长度 </span><br><span class="line">    int i;</span><br><span class="line">    for(i=40;i&gt;=0;i--)&#123;</span><br><span class="line">        flag[i]^=flag[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;42;i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; //flag&#123;d0f5b330-9a74-11ef-9afd-acde48001122&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF2024</title>
    <url>/posts/42198/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>去花之后重新识别得到一个加密函数，解密出来是fakeflag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void xor(unsigned char *data)&#123;</span><br><span class="line">  int i;</span><br><span class="line">  char c[]=&quot;Laughter_is_poison_to_fear&quot;;</span><br><span class="line">  for(i=0;i&lt;48;i++)&#123;</span><br><span class="line">    printf(&quot;%c&quot;,data[i]^c[i%26]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void encrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k1,k2,k3;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x9E3779B9,sum=0;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=delta;</span><br><span class="line">		v0+=((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">		v1+=((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); </span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">void decrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k2,k3,k1;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x61C88647,sum=0-0x61C88647*32;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 -= (sum + key[(sum &gt;&gt; 11) &amp; 3]) ^ (v0 + ((16 * v0) ^ (v0 &gt;&gt; 5)));</span><br><span class="line">		sum += 0x61C88647;</span><br><span class="line">		v0 -= (sum + key[sum &amp; 3]) ^ (v1 + ((16 * v1) ^ (v1 &gt;&gt; 5)));</span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char s[50]=&#123;</span><br><span class="line">    0xc2,0x39,0x3f,0xf7,0xeb,0x24,0x94,0x4d,0x99,0x41,</span><br><span class="line">    0x7e,0xfc,0x41,0x79,0xab,0xc8,0x5e,0xd0,0x3b,0xd7,</span><br><span class="line">    0x85,0x63,0xd3,0x1d,0xcb,0x98,0x5a,0x6,0x21,0x8b,</span><br><span class="line">    0xa3,0xd8,0xe3,0x86,0x1a,0x37,0x4a,0x8a,0x5c,0xd2,</span><br><span class="line">    0x53,0xcb,0x14,0x3c,0x89,0xeb,0x71,0xeb</span><br><span class="line">    &#125;;</span><br><span class="line">	char key[]=&quot;&#123;you_find_it_!?&#125;&quot;;</span><br><span class="line">	for(int i=0;i&lt;48;i+=8)</span><br><span class="line">	&#123;</span><br><span class="line">		decrypt((uint32_t*)&amp;s[i],(uint32_t*)key);	</span><br><span class="line">	&#125;</span><br><span class="line">	// printf(&quot;%s&quot;,s);	</span><br><span class="line">  xor(s);	  </span><br><span class="line"> &#125; fakeflag_plz_Try_more_hard_to_find_the_true_flag</span><br></pre></td></tr></table></figure>

<p>没有其他信息，动调看看</p>
<p>发现在执行完了该加密函数后调转到了另一个函数</p>
<img src="/posts/42198/image-20241228163913938.png" class="" title="image-20241228163913938">

<p>经过这个SMC，动调到第14行，单步步入（F7）。</p>
<p>跳转到了一堆汇编代码</p>
<img src="/posts/42198/image-20241228164136913.png" class="" title="image-20241228164136913">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug042:005D1020 db    0</span><br><span class="line">debug042:005D1021 ; ---------------------------------------------------------------------------</span><br><span class="line">debug042:005D1021 mov     ecx, 77h ; &#x27;w&#x27;</span><br><span class="line">debug042:005D1026 call    $+5   //将下一条指令入栈</span><br><span class="line">debug042:005D102B pop     ebx  // 执行完后ebx=005D102B</span><br><span class="line">debug042:005D102C mov     [ebx-0Bh], cl   // 将0x77存在[ebx-b](即005D1020)处</span><br><span class="line">debug042:005D102F push    ebp </span><br><span class="line">debug042:005D1030 pusha        		//将所有通用寄存器入栈</span><br><span class="line">debug042:005D1031 pushf				//将所有标志寄存器入栈</span><br><span class="line">debug042:005D1032 call    $+5</span><br><span class="line">debug042:005D1037 pop     eax   //将本指令地址传给eax</span><br><span class="line">debug042:005D1038 xor     edx, edx</span><br><span class="line">debug042:005D103A mov     dl, [eax-17h]  //将[eax-17](即005D1020)里面的值(0x77)赋值到edx低位</span><br><span class="line">debug042:005D1040 xor     edx, 1D82h   		</span><br><span class="line">debug042:005D1046 lea     ebx, [eax+edx]	//计算eax+edx的值，赋值给ebx</span><br><span class="line">debug042:005D1049 mov     ecx, 35h ; &#x27;5&#x27;    //将0x55赋值给ecx，为下一段汇编代码做准备</span><br><span class="line">debug042:005D104E mov     byte ptr [eax-17h], 0   //将005D1020处重新填回0</span><br><span class="line">debug042:005D1055 jmp     ebx 		//跳到005D2E2C处</span><br></pre></td></tr></table></figure>

<p>这一段汇编大部分都是为了跳转做准备，除了005D102F处的push    ebp 。接下来看005D2E2C处：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug042:005D2E2B db  35h ; 5</span><br><span class="line">debug042:005D2E2C ; ---------------------------------------------------------------------------</span><br><span class="line">debug042:005D2E2C call    $+5</span><br><span class="line">debug042:005D2E31 pop     ebx   //获取当前指令地址</span><br><span class="line">debug042:005D2E32 mov     [ebx-6], cl   //将0x35赋值给[ebx-6](即005D2E2B)处</span><br><span class="line">debug042:005D2E35 popf   		//通用寄存器出栈，对应前面一段汇编的压栈</span><br><span class="line">debug042:005D2E36 popa</span><br><span class="line">debug042:005D2E37 mov     ebp, esp</span><br><span class="line">debug042:005D2E39 pusha</span><br><span class="line">debug042:005D2E3A pushf</span><br><span class="line">debug042:005D2E3B call    $+5</span><br><span class="line">debug042:005D2E40 pop     eax</span><br><span class="line">debug042:005D2E41 xor     edx, edx</span><br><span class="line">debug042:005D2E43 mov     dl, [eax-15h]</span><br><span class="line">debug042:005D2E49 xor     edx, 1A12h</span><br><span class="line">debug042:005D2E4F lea     ebx, [eax+edx]</span><br><span class="line">debug042:005D2E52 mov     ecx, 69h ; &#x27;i&#x27;     //将0x69赋值给ecx，为下一段汇编代码做准备</span><br><span class="line">debug042:005D2E57 mov     byte ptr [eax-15h], 0</span><br><span class="line">debug042:005D2E5E jmp     ebx</span><br></pre></td></tr></table></figure>

<p>这一段也就是005D2E37处的mov     ebp, esp有用，其他就是为下一次跳转做准备</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL注入</title>
    <url>/posts/522/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><p>DLL注入是一种将外部动态链接库（DLL）加载到目标进程地址空间并执行其代码的技术。其目的在于利用Windows提供的机制，在一个不属于自己的进程中强制加载并运行指定的代码。与导入表注入不同，DLL注入是强行将DLL加载进目标进程空间，不会改变原程序（不改变文件），不需要修改原程序的导入表，因此DLL注入只对此进程有效，而程序下一次运行产生的进程则不会受到影响。</p>
<p>每一个PE文件在运行时会获得操作系统分配的4GB的独立的、虚拟的空间，进程中的所有地址都是在这个空间中寻址，并且两个进程之间是独立的、分隔的，不会互相影响。而CreateRemoteThread函数可以在获取另一个进程句柄的条件下在另一个句柄中创建线程，因此，可以使用该函数在目标进程中创建一个线程，此线程运行LoadLibrary函数，将待注入DLL的路径作为参数传入，使LoadLibrary函数将待注入DLL注入进目标进程的空间中，进而触发DLL里面的DLLmain函数执行，完成我们需要的功能。但是正常来说我们无法获知目标进程中LoadLibrary函数的地址，并且目标进程中并没有存储DLL路径。于是我们需要使用API在目标进程中申请空间，写入DLL路径，将这个路径的地址作为LoadLibrary参数。由于LoadLibrary所在的DLL（kernel32.dll）在任何程序中都会加载，且是第一个被加载的模块，因此kernel32.dll会加载在它的ImageBase处，它在所有进程中的基址都相同，于是LoadLibrary函数在任何进程中的地址都相同，可用本进程的LoadLibrary地址当作目标进程LoadLibrary的地址。</p>
<h2 id="关键函数："><a href="#关键函数：" class="headerlink" title="关键函数："></a>关键函数：</h2><h3 id="1、CreateToolhelp32Snapshot"><a href="#1、CreateToolhelp32Snapshot" class="headerlink" title="1、CreateToolhelp32Snapshot"></a>1、CreateToolhelp32Snapshot</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HANDLE CreateToolhelp32Snapshot(</span><br><span class="line">  DWORD dwFlags,        // 指定快照包含的内容。这里使用TH32CS_SNAPPROCESS获取所有进程信息</span><br><span class="line">  DWORD th32ProcessID   // 目标进程ID（某些标志需要，这里不需要，故设为0）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：创建系统快照（获取当前系统状态的只读视图）。</p>
<h3 id="2、Process32FirstW"><a href="#2、Process32FirstW" class="headerlink" title="2、Process32FirstW"></a>2、Process32FirstW</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI Process32FirstW(</span><br><span class="line">  HANDLE           hSnapshot,    // CreateToolhelp32Snapshot 返回的句柄(快照句柄)</span><br><span class="line">  LPPROCESSENTRY32W lppe          // 指向 PROCESSENTRY32W 结构的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取系统快照中的第一个进程信息。</p>
<p>结构体定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32W &#123;</span><br><span class="line">  DWORD     dwSize;              // 结构体大小（必须初始化）</span><br><span class="line">  DWORD     cntUsage;            // 保留字段</span><br><span class="line">  DWORD     th32ProcessID;       // 进程标识符(PID) -------有用</span><br><span class="line">  ULONG_PTR th32DefaultHeapID;   // 默认堆ID（已废弃）</span><br><span class="line">  DWORD     th32ModuleID;        // 模块ID（已废弃）</span><br><span class="line">  DWORD     cntThreads;          // 进程拥有的线程数</span><br><span class="line">  DWORD     th32ParentProcessID; // 父进程PID</span><br><span class="line">  LONG      pcPriClassBase;      // 线程基础优先级</span><br><span class="line">  DWORD     dwFlags;             // 保留字段</span><br><span class="line">  WCHAR     szExeFile[MAX_PATH]; // 可执行文件名（含扩展名）  --------有用</span><br><span class="line">&#125; PROCESSENTRY32W;</span><br></pre></td></tr></table></figure>

<h3 id="3、Process32NextW"><a href="#3、Process32NextW" class="headerlink" title="3、Process32NextW"></a>3、Process32NextW</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI Process32NextW(</span><br><span class="line">  HANDLE           hSnapshot,    // 快照句柄</span><br><span class="line">  LPPROCESSENTRY32W lppe          // 进程条目结构指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取快照中的下一个进程信息（需要在 <code>Process32FirstW</code>之后调用）</p>
<h3 id="4、OpenProcess"><a href="#4、OpenProcess" class="headerlink" title="4、OpenProcess"></a>4、<strong>OpenProcess</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">  DWORD dwDesiredAccess,  // 你希望获得的对目标进程的操作权限。</span><br><span class="line">  BOOL  bInheritHandle,   // 句柄继承选项。通常设为 FALSE（不继承）</span><br><span class="line">  DWORD dwProcessId       // 目标进程PID</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中dwDesiredAccess参数这里需要使用的权限有：</p>
<table>
<thead>
<tr>
<th>dwDesiredAccess参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PROCESS_CREATE_THREAD</td>
<td>允许在目标进程中创建远程线程（如 <code>CreateRemoteThread</code>）</td>
</tr>
<tr>
<td>PROCESS_QUERY_INFORMATION</td>
<td>获取进程基本信息</td>
</tr>
<tr>
<td>PROCESS_VM_OPERATION</td>
<td>执行虚拟内存操作（如 <code>VirtualAllocEx</code>、<code>VirtualFreeEx</code>）</td>
</tr>
<tr>
<td>PROCESS_VM_READ</td>
<td>读取目标进程内存（如 <code>ReadProcessMemory</code>）</td>
</tr>
<tr>
<td>PROCESS_VM_WRITE</td>
<td>写入目标进程内存（如 <code>WriteProcessMemory</code>）</td>
</tr>
</tbody></table>
<p><strong>功能</strong>：通过给出的进程PID获取进程句柄，是后续对进程注入的基础</p>
<h3 id="5、VirtualAllocEx"><a href="#5、VirtualAllocEx" class="headerlink" title="5、VirtualAllocEx"></a>5、<strong>VirtualAllocEx</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,        // 目标进程句柄</span><br><span class="line">  LPVOID lpAddress,       // 期望起始地址（通常为NULL）</span><br><span class="line">  SIZE_T dwSize,          // 分配区域大小</span><br><span class="line">  DWORD  flAllocationType,// 分配类型。通常为MEM_COMMIT，分配实际物理内存</span><br><span class="line">  DWORD  flProtect        // 内存保护标志。设为PAGE_READWRITE（需写入数据）</span><br><span class="line">);  // 返回值LPVOID代表指向任意类型的指针</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：向指定进程的虚拟地址空间中申请内存区域。分配失败返回NULL，成功时返回目标进程中分配的内存区域的起始地址（指针）。</p>
<h3 id="6、WriteProcessMemory"><a href="#6、WriteProcessMemory" class="headerlink" title="6、WriteProcessMemory"></a>6、<strong>WriteProcessMemory</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">  HANDLE  hProcess,              // 目标进程句柄</span><br><span class="line">  LPVOID  lpBaseAddress,         // 目标内存起始地址</span><br><span class="line">  LPCVOID lpBuffer,              // 本地数据缓冲区指针</span><br><span class="line">  SIZE_T  nSize,                 // 写入字节数</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten// 实际写入字节数（可置NULL）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：在指定进程内存中写入数据</p>
<h3 id="7、CreateRemoteThread"><a href="#7、CreateRemoteThread" class="headerlink" title="7、CreateRemoteThread"></a>7、<strong>CreateRemoteThread</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,        // 目标进程句柄</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpThreadAttributes, // 安全属性（通常NULL）</span><br><span class="line">  SIZE_T                dwStackSize,      // 初始栈大小（0=默认）</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,  // 线程函数地址（LoadLibrary指针）</span><br><span class="line">  LPVOID                 lpParameter,     // 线程参数（DLL路径在内存中的地址）</span><br><span class="line">  DWORD                  dwCreationFlags, // 创建标志（0=立即运行）</span><br><span class="line">  LPDWORD                lpThreadId       // 线程ID（可置NULL）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中参数lpStartAddress和lpParameter最重要</p>
<p><strong>功能</strong>：在目标进程中创建一个远程线程，线程从lpStartAddress处开始运行，并传入一个参数lpParameter。这里实际上就是在目标进程创建一个远程线程，把我的DLL路径作为参数传入，使线程在运行时使用LoadLibrary函数将我的DLL载入进程空间。</p>
<h3 id="8、WaitForSingleObject"><a href="#8、WaitForSingleObject" class="headerlink" title="8、WaitForSingleObject"></a>8、WaitForSingleObject</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD WINAPI WaitForSingleObject(</span><br><span class="line">  HANDLE hHandle,      // 对象句柄（这里是线程句柄）</span><br><span class="line">  DWORD  dwMilliseconds // 超时时间（毫秒）,INFINITE代表无限等待直到结束</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：暂停当前线程的执行，持续检查 <code>hThread</code>线程的状态直到目标线程终止（进入 signaled 状态）才继续执行后续代码。</p>
<h3 id="9、VirtualFreeEx"><a href="#9、VirtualFreeEx" class="headerlink" title="9、VirtualFreeEx"></a>9、VirtualFreeEx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL VirtualFreeEx(</span><br><span class="line">  HANDLE hProcess,  // 目标进程句柄</span><br><span class="line">  LPVOID lpAddress,  // 要释放的内存起始地址</span><br><span class="line">  SIZE_T dwSize,     // 要释放的内存大小</span><br><span class="line">  DWORD  dwFreeType  // 释放类型（关键参数）。MEM_RELEASE为完全释放</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：释放目标进程空间</p>
<h3 id="10、EnumProcessModules"><a href="#10、EnumProcessModules" class="headerlink" title="10、EnumProcessModules"></a>10、EnumProcessModules</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL EnumProcessModules(</span><br><span class="line">  HANDLE  hProcess,      // 目标进程句柄</span><br><span class="line">  HMODULE *lphModule,    // 接收进程加载的模块句柄的数组</span><br><span class="line">  DWORD   cb,            // 数组缓冲区大小（字节）</span><br><span class="line">  LPDWORD lpcbNeeded     // 存储返回的实际的大小</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取指定进程加载的所有模块的句柄，存储在lphModule数组里面</p>
<h3 id="11、GetModuleFileNameExW"><a href="#11、GetModuleFileNameExW" class="headerlink" title="11、GetModuleFileNameExW"></a>11、GetModuleFileNameExW</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD GetModuleFileNameExW(</span><br><span class="line">  HANDLE  hProcess,     // 目标进程的句柄</span><br><span class="line">  HMODULE hModule,      // 模块句柄（NULL 表示进程主模块）</span><br><span class="line">  LPWSTR  lpFilename,   // 接收路径的缓冲区</span><br><span class="line">  DWORD   nSize         // 缓冲区大小（字符数）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取指定进程中某个模块（通常是 DLL ）的完整文件路径，返回写入的字符数。</p>
<h3 id="12、FreeLibrary"><a href="#12、FreeLibrary" class="headerlink" title="12、FreeLibrary"></a>12、FreeLibrary</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL FreeLibrary(</span><br><span class="line">  [in] HMODULE hLibModule   // 要释放的 DLL 模块句柄</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：卸载目标模块</p>
<h3 id="13、wcscmp"><a href="#13、wcscmp" class="headerlink" title="13、wcscmp"></a>13、wcscmp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int wcscmp(const wchar_t *str1, const wchar_t *str2);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：宽字符串的比较。返回值为0代表相等。</p>
<h3 id="14、FindWindow"><a href="#14、FindWindow" class="headerlink" title="14、FindWindow"></a>14、FindWindow</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HWND FindWindow(</span><br><span class="line">    LPCTSTR lpClassName,  // 窗口类名（这里设为NULL）</span><br><span class="line">    LPCTSTR lpWindowName  // 窗口标题</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：通过窗口标题或取窗口句柄</p>
<p>返回值：返回窗口句柄</p>
<h3 id="15、GetWindowThreadProcessId"><a href="#15、GetWindowThreadProcessId" class="headerlink" title="15、GetWindowThreadProcessId"></a>15、GetWindowThreadProcessId</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD GetWindowThreadProcessId(</span><br><span class="line">    HWND    hWnd,        // 窗口句柄</span><br><span class="line">    LPDWORD lpdwProcessId// 接收进程ID的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：通过窗口句柄获取窗口PID</p>
<h1 id="主要逻辑："><a href="#主要逻辑：" class="headerlink" title="主要逻辑："></a>主要逻辑：</h1><h2 id="装载逻辑："><a href="#装载逻辑：" class="headerlink" title="装载逻辑："></a>装载逻辑：</h2><ol>
<li>使用CreateToolhelp32Snapshot获取进程快照</li>
<li>使用Process32FirstW获取第一个进程信息</li>
<li>使用循环和Process32NextW函数迭代进程信息，依次比对其中的可执行文件名，以此找到目标进程PID</li>
<li>使用OpenProcess函数获取目标进程句柄</li>
<li>使用VirtualAllocEx申请空间</li>
<li>使用WriteProcessMemory在申请的空间中写入自定义DLL的路径</li>
<li>使用CreateRemoteThread创建线程，参数lpStartAddress和lpParameter分别填LoadLibraryW函数指针（要转换为LPTHREAD_START_ROUTINE）和DLL路径的内存地址</li>
<li>在LoadLibrary将我们的DLL载入后，DLL中的DLLmain函数会执行</li>
<li>等待线程结束后，释放空间和句柄</li>
</ol>
<h3 id="卸载逻辑："><a href="#卸载逻辑：" class="headerlink" title="卸载逻辑："></a>卸载逻辑：</h3><ol>
<li>使用OpenProcess函数获取目标进程句柄</li>
<li>使用EnumProcessModules函数获取进程所有模块的句柄</li>
<li>使用GetModuleFileNameExW函数对句柄进行判断，找到目标DLL句柄</li>
<li>使用CreateRemoteThread创建线程，参数为FreeLibrary函数地址（要转换为LPTHREAD_START_ROUTINE）和DLL句柄</li>
<li>等待线程结束后，释放空间和句柄</li>
</ol>
<h1 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h1><p>注意：目标进程、注入进程、DLL必须都是同一个位数。32为dll无法注入到64位进程中，64位进程与32位进程中LoadLibrary函数地址不同，故不可用64位注入程序注入DLL进32位目标进程</p>
<p>注入程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include &lt;tlhelp32.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;shlwapi.h&gt;</span><br><span class="line">#include &lt;psapi.h&gt;</span><br><span class="line">DWORD FindPidByName(wchar_t *s)&#123;  // 通过进程名查找进程PID</span><br><span class="line">	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);</span><br><span class="line">	if (snapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;创建进程快照失败! 错误代码:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">	PROCESSENTRY32W lppe= &#123;0&#125;;</span><br><span class="line">	lppe.dwSize = sizeof(PROCESSENTRY32W);</span><br><span class="line">	if(!Process32FirstW(snapshot,&amp;lppe))&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;无法枚举进程&quot; &lt;&lt; std::endl;</span><br><span class="line">        CloseHandle(snapshot);</span><br><span class="line">        return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	do&#123;</span><br><span class="line">		if(!wcscmp(s,lppe.szExeFile))&#123;</span><br><span class="line">			CloseHandle(snapshot);</span><br><span class="line">			return lppe.th32ProcessID;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;while(Process32NextW(snapshot,&amp;lppe));</span><br><span class="line">	CloseHandle(snapshot);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD FindPidByWindowsName(LPCWSTR WindowsName)&#123;  // 通过窗口名查找PID</span><br><span class="line">	HWND hwnd = FindWindowW(NULL,WindowsName);</span><br><span class="line">	if(hwnd)&#123;</span><br><span class="line">		DWORD PID=0;</span><br><span class="line">		GetWindowThreadProcessId(hwnd,&amp;PID);</span><br><span class="line">		return PID;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建远程线程加载dll</span><br><span class="line">void injection(DWORD pid,wchar_t path[])&#123;  // dll注入</span><br><span class="line">	// 1、打开进程</span><br><span class="line">	HANDLE phandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |</span><br><span class="line">        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,FALSE, pid);</span><br><span class="line">	if (!phandle) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;打开进程失败(代码：&quot;</span><br><span class="line">                  &lt;&lt; GetLastError() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 2、分配空间，写入dll路径</span><br><span class="line">	int size = (wcslen(path)+1)*sizeof(wchar_t);</span><br><span class="line">	LPVOID lpaddress = VirtualAllocEx(phandle, nullptr, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	if(!lpaddress)&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;申请空间失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	BOOL flag = WriteProcessMemory(phandle,lpaddress,path,size,NULL);</span><br><span class="line">	if(!flag)&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;写入失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 3、创建远程线程</span><br><span class="line">	HANDLE hThread = CreateRemoteThread(phandle,NULL,0,(LPTHREAD_START_ROUTINE)LoadLibraryW,lpaddress,0,NULL);</span><br><span class="line">	if(!hThread)&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;线程创建失败&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 4、等待线程结束</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">	// 5、释放</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	VirtualFreeEx(phandle, lpaddress, size, MEM_RELEASE);</span><br><span class="line">	CloseHandle(phandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建远程线程卸载dll</span><br><span class="line">void unloadDll(DWORD pid,wchar_t path[])&#123;</span><br><span class="line">	// 1、打开进程</span><br><span class="line">	HANDLE phandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |</span><br><span class="line">        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,FALSE, pid);</span><br><span class="line">	if (!phandle) &#123;</span><br><span class="line">        std::wcerr &lt;&lt; &quot;打开进程失败(代码：&quot;</span><br><span class="line">                  &lt;&lt; GetLastError() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 3、获取进程加载的所有模块</span><br><span class="line">	HMODULE lphModule[1000];</span><br><span class="line">	DWORD dwsize;</span><br><span class="line">	BOOL flag = EnumProcessModules(phandle,lphModule,sizeof(lphModule),&amp;dwsize);</span><br><span class="line">	if(!flag)&#123;</span><br><span class="line">		CloseHandle(phandle);</span><br><span class="line">		std::cerr &lt;&lt; &quot;读取模块失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 4、寻找目标dll的句柄</span><br><span class="line">	int i;</span><br><span class="line">	wchar_t lpFilename[MAX_PATH];</span><br><span class="line">	for(i=0;;i++)&#123;</span><br><span class="line">		if(GetModuleFileNameExW(phandle,lphModule[i],lpFilename,MAX_PATH)==0)&#123;</span><br><span class="line">			CloseHandle(phandle);</span><br><span class="line">			std::cerr &lt;&lt; &quot;未找到此模块&quot; &lt;&lt; std::endl;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!_wcsicmp(path,lpFilename)) break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 5、生成线程，卸载dll</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	hThread = CreateRemoteThread(phandle,NULL,0,(LPTHREAD_START_ROUTINE)FreeLibrary,lphModule[i],0,NULL);</span><br><span class="line">	if(!hThread)&#123;</span><br><span class="line">		CloseHandle(phandle);</span><br><span class="line">		std::cerr &lt;&lt; &quot;打开线程失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 6、等待线程结束</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">	// 7、释放</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(phandle);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	wchar_t name[] = L&quot;target.exe&quot;;</span><br><span class="line">	DWORD PID = FindPidByName(name);</span><br><span class="line">	//const wchar_t WindowsName[] = L&quot;E:\\project\\target.exe&quot;;</span><br><span class="line">	// DWORD PID = FindPidByWindowsName(WindowsName);</span><br><span class="line">	if(PID == 0) return 0;</span><br><span class="line">	wchar_t path[] = L&quot;E:\\project\\DLL注入.dll&quot;;  // dll路径</span><br><span class="line">	injection(PID,path);</span><br><span class="line">	unloadDll(PID,path);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DLL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;dllmain.h&quot;</span><br><span class="line"></span><br><span class="line">int  add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APIENTRY DllMain(</span><br><span class="line">    HMODULE hModule, </span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">) &#123;</span><br><span class="line">    switch (ul_reason_for_call) &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH:</span><br><span class="line">            // 加载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已注入!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_PROCESS_DETACH:</span><br><span class="line">            // 卸载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已卸载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_ATTACH:</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_DETACH:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注入后：</p>
<img src="/posts/undefined/image-20250717221804965.png" class="" title="image-20250717221804965">

<p>卸载后：</p>
<img src="/posts/undefined/image-20250717221831532.png" class="" title="image-20250717221831532">
]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP定律脱壳</title>
    <url>/posts/43303/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>加壳是利用特殊的算法事先对程序源代码进行压缩，并向程序里面注入解压的代码，这段解压代码会先于源代码执行。在程序执行时，会自动将原始代码进行解压，然后跳转到原程序的入口点，继续执行原程序。而在执行完解压过程后需要将栈恢复到解压前的状态，即ESP会回到解压前的位置，因此，我们可以通过判断ESP是否回到初始位置来判断程序是否已经达到入口点（OEP）。</p>
<p>接下来以脱upx壳为例：</p>
<p>程序源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char s[] = &quot;ek`fz`abcdefg|&quot;;</span><br><span class="line">	char input[15];</span><br><span class="line">	int i;</span><br><span class="line">	printf(&quot;请输入你的flag:\n&quot;);</span><br><span class="line">	scanf(&quot;%14s&quot;, input,sizeof(input));</span><br><span class="line">	for (i = 0; i &lt; 14; i++)</span><br><span class="line">		input[i] -= 1;</span><br><span class="line">	if (!strcmp(input, s))</span><br><span class="line">		printf(&quot;right!&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;wrong!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><p>一共分为三步：</p>
<ol>
<li>寻找OEP</li>
<li>dump出初步的脱壳程序</li>
<li>修复程序</li>
</ol>
<h2 id="1、寻找OEP"><a href="#1、寻找OEP" class="headerlink" title="1、寻找OEP"></a>1、寻找OEP</h2><p>使用xdbg打开</p>
<img src="/posts/43303/image-20241206232732823.png" class="" title="image-20241206232732823">

<p>可以看到开始就是pushad指令，这个指令是将所有寄存器都压入栈。</p>
<p>一般的壳都会在开始时进行压栈，然后在解压结束时进行出栈。</p>
<p>此时按F8单步步过，可以看到右边的ESP发生了变化</p>
<img src="/posts/43303/image-20241206232654462.png" class="" title="image-20241206232654462">

<p>点击右边ESP，按右键，选内存窗口中转到，内存1</p>
<img src="/posts/43303/image-20241206232906388.png" class="" title="image-20241206232906388">

<p>此时左下角的内存窗口已经转移到ESP的位置</p>
<img src="/posts/43303/image-20241206233019638.png" class="" title="image-20241206233019638">

<p>选定第一个字节，按右键，断点，硬件访问，接下来三个里面随便选一个</p>
<img src="/posts/43303/image-20241206233108832.png" class="" title="image-20241206233108832">

<p>此时下好了断点，按F9让程序一直运行直到断点处</p>
<img src="/posts/43303/image-20241211210508761.png" class="" title="image-20241211210508761">

<p>注意此时的ESP回到了刚用xdbg打开时的值0x0061FF78，此时壳已经解压完了，那么下一个大的跳转就是跳转到OEP处。</p>


<p>在跳转到OEP前有一段往回退的代码，我们需要跳过这段代码执行到jmp那里。</p>
<p>单击0041E963 处的jmp u.4014E0指令对其选定，按F4就停在了这个地址处，接下来按F8往后运行一步，直接跳转到了0x4014E0地址处，这里就是OEP（程序入口点）<img src="/posts/43303/image-20241211211507576.png" class="" title="image-20241211211507576"></p>
<h2 id="2、dump出初步的脱壳程序"><a href="#2、dump出初步的脱壳程序" class="headerlink" title="2、dump出初步的脱壳程序"></a>2、dump出初步的脱壳程序</h2><p>先点击上方的断点窗口，这里会把所有断点列出来</p>


<img src="/posts/43303/image-20241211211858516.png" class="" title="image-20241211211858516">

<p>单击一下刚才设置的断点，按右键，选择删除断点</p>
<img src="/posts/43303/image-20241211211951774.png" class="" title="image-20241211211951774">

<p>回到cpu窗口，此时的程序是脱壳完成的程序，点击上面第二排的scylla工具</p>
<img src="/posts/43303/image-20241211212248223.png" class="" title="image-20241211212248223">

<img src="/posts/43303/image-20241211212600034.png" class="" title="image-20241211212600034">

<p>点击dump，会生成一个dump.exe文件.</p>
<h2 id="3、修复程序"><a href="#3、修复程序" class="headerlink" title="3、修复程序"></a>3、修复程序</h2><p>此时的生成的exe文件还是有问题的文件，可能会运行失败，因为脱壳过程可能会改变程序的数据段、导入表、导出表等内容。所以需要将这些表格和数据恢复到脱壳前的状态，确保程序能够正确加载所需的库和函数。</p>
<p>还是刚才那个Scylla插件，点击IAT Autosearch、Get Imports</p>
<img src="/posts/43303/image-20241211213131379.png" class="" title="image-20241211213131379">

<img src="/posts/43303/image-20241211213238362.png" class="" title="image-20241211213238362">

<p>此时按Fix Dump，选择刚才dump出的dump.exe文件，点打开</p>
<img src="/posts/43303/image-20241211213350764.png" class="" title="image-20241211213350764">

<p>此时会在相同目录下生成一个dump_SCY.exe文件，这个就是脱壳完成的程序。</p>
]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>GHCTF</title>
    <url>/posts/18925/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="ASM-Signin"><a href="#ASM-Signin" class="headerlink" title="ASM?Signin!"></a>ASM?Signin!</h1><p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void swap(unsigned char a[],int l,int h)&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    unsigned char temp;</span><br><span class="line">    for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">      temp=a[l];</span><br><span class="line">      a[l]=a[h];</span><br><span class="line">      a[h]=temp;</span><br><span class="line">      l++;</span><br><span class="line">      h++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned char data1[33]=&#123;0x26,0x27,0x24,0x25,0x2A,0x2B,0x28,0x00,</span><br><span class="line">        0x2E,0x2F,0x2C,0x2D,0x32,0x33,0x30,0x00,</span><br><span class="line">        0x36,0x37,0x34,0x35,0x3A,0x3B,0x38,0x39,</span><br><span class="line">        0x3E,0x3F,0x3C,0x3D,0x3F,0x27,0x34,0x11&#125;;</span><br><span class="line">    int i=0,j=0,k=0;</span><br><span class="line">    for(k=0;k&lt;8;k++)&#123;    //错位交换部分</span><br><span class="line">        j=i;</span><br><span class="line">        j+=4;</span><br><span class="line">        if(j&gt;=28) j-=28;</span><br><span class="line">        swap(data1,i,j);</span><br><span class="line">        i+=4;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char data2[]=&#123;0x69,0x77,0x77,0x66,0x73,0x72,0x4F,0x46,</span><br><span class="line">                           0x03,0x47,0x6F,0x79,0x07,0x41,0x13,0x47,</span><br><span class="line">                           0x5E,0x67,0x5F,0x09,0x0F,0x58,0x63,0x7D,</span><br><span class="line">                           0x5F,0x77,0x68,0x35,0x62,0x0D,0x0D,0x50&#125;;</span><br><span class="line">    for(i=31;i&gt;0;i-=4)&#123;     //错位异或解密部分</span><br><span class="line">        data2[i]^=data1[i];</span><br><span class="line">        data2[i-1]^=data1[i-1];</span><br><span class="line">        data2[i-2]^=data1[i-1];</span><br><span class="line">        data2[i-3]^=data1[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;32;i++) printf(&quot;%c&quot;,data2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FishingKit"><a href="#FishingKit" class="headerlink" title="FishingKit"></a>FishingKit</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void encrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k1,k2,k3;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x9E3779B9,sum=0;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=delta;</span><br><span class="line">		v0+=((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">		v1+=((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); </span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">void decrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k2,k3,k1;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x66778899,v5=0x66778899*24;</span><br><span class="line">	for(int i=0;i&lt;24;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 -= (key[(v5 &gt;&gt; 11) &amp; 3] + v5) ^ (v0 + ((v0 &gt;&gt; 5) ^ (16 * v0)));</span><br><span class="line">        v5 -= 0x66778899;</span><br><span class="line">        v0 -= (key[v5 &amp; 3] + v5) ^ (v1 + ((v1 &gt;&gt; 5) ^ (16 * v1)));</span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char s[24]=&#123;0x21, 0x56, 0x97, 0xA6, 0x1A, 0xD5, 0xC4, 0xDE, 0xA4, 0x9C, </span><br><span class="line">                        0x82, 0x4D, 0xD1, 0x45, 0xC8, 0x56, 0xA7, 0xB4, 0x96, 0x5C, </span><br><span class="line">                        0x4D, 0x49, 0x87, 0x20&#125;;</span><br><span class="line">	uint32_t key[4]=&#123;0x756C6544,0x61426578,0x7469,0x0&#125;;</span><br><span class="line">	for(int i=0;i&lt;24;i+=8)</span><br><span class="line">	&#123;</span><br><span class="line">		decrypt((uint32_t*)&amp;s[i],key);	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%s&quot;,s);		  </span><br><span class="line"> &#125; //NSSCTF&#123;Wh@t_@_b1g_F1sh&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LockedSecret"><a href="#LockedSecret" class="headerlink" title="LockedSecret"></a>LockedSecret</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void decrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k2,k3,k1;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0]^0xf,v1=v[1]^0xf;</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x5E2377FF,sum=0x5E2377FF*8;</span><br><span class="line">	for(int i=0;i&lt;8;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1-=(key[3]+(v0&gt;&gt;5))^(v0+sum)^(key[2]+16*v0);</span><br><span class="line">		v0-=(key[1]+(v1&gt;&gt;5))^(v1+sum)^(key[0]+16*v1);</span><br><span class="line">		sum-=delta;</span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t s[32]=&#123;0xDC, 0x45, 0x1E, 0x03, 0x89, 0xE9, 0x76, 0x27, 0x47, 0x48, </span><br><span class="line">        0x23, 0x01, 0x70, 0xD2, 0xCE, 0x64, 0xDA, 0x7F, 0x46, 0x33, </span><br><span class="line">        0xB1, 0x03, 0x49, 0xA3, 0x27, 0x00, 0xD1, 0x2C, 0x37, 0xB3, </span><br><span class="line">        0xBD, 0x75 &#125;;</span><br><span class="line">	uint32_t key[4]=&#123;0x423DF72D, 0x5F59A01, 0x633FCF1D, 0x77D19122&#125;;</span><br><span class="line">	for(int i=0;i&lt;4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		decrypt((uint32_t*)&amp;s[i*8],key);	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%s&quot;,s);		  </span><br><span class="line"> &#125; // NSSCTF&#123;!!!Y0u_g3t_th3_s3cr3t!!!&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mio-Ryo-Syo"><a href="#Mio-Ryo-Syo" class="headerlink" title="Mio?Ryo?Syo?"></a>Mio?Ryo?Syo?</h1><p>必须要在python3.8的环境下才能得到两个库的pyc文件（Secret.pyc和SecretEncrypt.pyc），我电脑是3.12，所以找半天也没找到这两个文件🙌</p>
<p>使用pycdc反编译三个pyc文件，进行适当的修复，得到源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">class class0:</span><br><span class="line">    table85 = &#x27;&#x27;.join((lambda _0: [ chr(j) for j in _0 ])(range(33, 118)))</span><br><span class="line"></span><br><span class="line">    def base85(x3 = None):</span><br><span class="line">        x1 = &#x27;&#x27;</span><br><span class="line">        x2 = (4 - len(x3) % 4) % 4</span><br><span class="line">        x3 += b&#x27;\x00&#x27; * x2</span><br><span class="line">        for i in range(0, len(x3), 4):</span><br><span class="line">            x4 = x3[i:i + 4]</span><br><span class="line">            x5 = int.from_bytes(x4, &#x27;big&#x27;)</span><br><span class="line">            x6 = &#x27;&#x27;</span><br><span class="line">            for _ in range(5):</span><br><span class="line">                x6 = class0.table85[x5 % 85] + x6</span><br><span class="line">                x5 //= 85</span><br><span class="line">            x1 += x6</span><br><span class="line">        if x2:</span><br><span class="line">            x1 = x1[:-x2]</span><br><span class="line">        return x1</span><br><span class="line"></span><br><span class="line">    base85 = None(base85)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class class1:</span><br><span class="line">    table45 = &#x27;&#x27;.join((lambda _0: [ chr(i) for i in _0 ])(range(48, 93)))</span><br><span class="line"></span><br><span class="line">    def base45(str = None):</span><br><span class="line">        enc = []</span><br><span class="line">        j = 0</span><br><span class="line">        while j &lt; len(str):</span><br><span class="line">            if j + 1 &lt; len(str):</span><br><span class="line">                x0 = str[j] &lt;&lt; 8 | str[j + 1]</span><br><span class="line">                enc.append(class1.table45[x0 % 45])</span><br><span class="line">                x0 //= 45</span><br><span class="line">                enc.append(class1.table45[x0 % 45])</span><br><span class="line">                x0 //= 45</span><br><span class="line">                enc.append(class1.table45[x0])</span><br><span class="line">                j += 2</span><br><span class="line">                continue</span><br><span class="line">            x0 = str[j]</span><br><span class="line">            enc.append(class1.table45[x0 % 45])</span><br><span class="line">            x0 //= 45</span><br><span class="line">            enc.append(class1.table45[x0])</span><br><span class="line">            j += 1</span><br><span class="line">        return &#x27;&#x27;.join(enc)</span><br><span class="line"></span><br><span class="line">    base45 = None(base45)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(input_str, num):</span><br><span class="line">    arr = []</span><br><span class="line">    for char in input_str:  # 遍历每个字符</span><br><span class="line">        # 处理小写字母</span><br><span class="line">        if &#x27;a&#x27; &lt;= char &lt;= &#x27;z&#x27;:</span><br><span class="line">            shifted = (ord(char) - ord(&#x27;a&#x27;) + num) % 26</span><br><span class="line">            arr.append(chr(ord(&#x27;a&#x27;) + shifted))</span><br><span class="line">        # 处理数字</span><br><span class="line">        elif &#x27;0&#x27; &lt;= char &lt;= &#x27;9&#x27;:</span><br><span class="line">            shifted = (ord(char) - ord(&#x27;0&#x27;) - num) % 10  # 数字左移</span><br><span class="line">            arr.append(chr(ord(&#x27;0&#x27;) + shifted))</span><br><span class="line">        # 其他字符原样保留</span><br><span class="line">        else:</span><br><span class="line">            arr.append(char)</span><br><span class="line">    return &#x27;&#x27;.join(arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc = bytes([57,118,33,114,68,56,117,115,34,52,52,95,78,40,49,59,95,85,63,122,54,33,77,110,49,54,34,</span><br><span class="line">                      109,106,122,60,92,108,91,61,51,42,62,35,38,52,67,62,122,116,48,76,50,67,51,59,41,122,45,45,51,90])</span><br><span class="line"></span><br><span class="line">def l(_ = None):</span><br><span class="line">    return encrypt(class0.base85(encrypt(class1.base45(_.encode()), 7).encode()), 9)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;请输入:&#x27;, &#x27;&#x27;, **(&#x27;end&#x27;,))</span><br><span class="line">    aaaaaaaaaaaaa = input()</span><br><span class="line">    wwwwwwwwwww = l(aaaaaaaaaaaaa)</span><br><span class="line">    if enc == wwwwwwwwwww.encode():</span><br><span class="line">        print(&quot;对的&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;非也&quot;)</span><br></pre></td></tr></table></figure>

<p>主要逻辑：input -&gt; base45加密 -&gt; 移7位 -&gt; base85加密 -&gt; 移9位</p>
<p>反过来解密：密文 -&gt; 移9位 -&gt; base85解密 -&gt; 移7位 -&gt; base45解密 </p>
<p>移位的逆脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def shift(str,num):</span><br><span class="line">    arr = &#x27;&#x27;</span><br><span class="line">    for i in str:</span><br><span class="line">        if &#x27;a&#x27; &lt;= i &lt;= &#x27;z&#x27;:</span><br><span class="line">            arr += chr(97+(ord(i)-97-num+26)%26)</span><br><span class="line">        elif &#x27;0&#x27; &lt;= i &lt;= &#x27;9&#x27;:</span><br><span class="line">            arr += chr(48+(ord(i)+num-48+10)%10)</span><br><span class="line">        else:</span><br><span class="line">            arr += i</span><br><span class="line">    return arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc=[57,118,33,114,68,56,117,115,34,52,52,95,78,40,49,59,95,85,63,122,54,33,77,110,49,54,34,109,106,122,60,92,108,91,61,51,42,62,35,38,52,67,62,122,116,48,76,50,67,51,59,41,122,45,45,51,90]</span><br><span class="line">for i in enc:</span><br><span class="line">    dec+=chr(i)</span><br><span class="line">num=9</span><br><span class="line">print(shift(dec,num))</span><br></pre></td></tr></table></figure>

<img src="/posts/18925/image-20250308183254474.png" class="" title="image-20250308183254474">

<p>NSSCTF{Th3y’r3_a11_p1aY_Ba5e!}</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook技术实现！</title>
    <url>/posts/30238/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Inline Hook的主要思路如下：</p>
<p>1、获取strcmp函数的地址</p>
<p>2、获取自定义函数的地址</p>
<p>3、取消strcmp函数地址保护</p>
<p>4、计算strcmp函数与自定义函数之间的偏移offset</p>
<p>5、修改strcmp函数头5个字节，改为jmp offset</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">int __cdecl my_strcmp(char s1[],char s2[])&#123;</span><br><span class="line">    printf(&quot;hook成功!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void hook()&#123; </span><br><span class="line">        // 取消函数地址保护</span><br><span class="line">        DWORD oldProtect;  // 旧保护属性</span><br><span class="line">        VirtualProtect((LPVOID)strcmp,0x1000,PAGE_EXECUTE_READWRITE,&amp;oldProtect);</span><br><span class="line"></span><br><span class="line">        // 获取函数地址</span><br><span class="line">        byte* funcAddr = (byte*)my_strcmp;</span><br><span class="line">        byte* strcmp_add = (byte*)strcmp;</span><br><span class="line"></span><br><span class="line">        // 跳转到自定义函数</span><br><span class="line">        __asm__ __volatile__ (</span><br><span class="line">    		&quot;movl %0, %%eax \n\t&quot;</span><br><span class="line">		    &quot;movl %1, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;subl %%eax, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;subl $5, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;movb $0xe9, (%%eax) \n\t&quot;</span><br><span class="line">		    &quot;movl %%ebx, 1(%%eax)&quot;</span><br><span class="line">		    : /* 无输出操作数 */</span><br><span class="line">		    : &quot;r&quot; (strcmp_add), &quot;r&quot; (funcAddr)  // 输入操作数</span><br><span class="line">		    : &quot;eax&quot;, &quot;ebx&quot;, &quot;memory&quot;            // 破坏列表</span><br><span class="line">		);</span><br><span class="line">         DWORD floadprotect;</span><br><span class="line">         VirtualProtect((LPVOID)strcmp,0x1000,oldProtect,&amp;floadprotect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = hook();  // 使用全局变量调用，使该函数早于main函数执行</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char a[]=&quot;hello world&quot;;</span><br><span class="line">    char s[20];</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    if(!strcmp(a,s))</span><br><span class="line">        printf(&quot;right!\n&quot;);</span><br><span class="line">    else printf(&quot;wrong!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//77011C10</span><br></pre></td></tr></table></figure>

<p>Hook成功：</p>
<img src="/posts/30238/image-20250422225432814.png" class="" title="image-20250422225432814">

<h1 id="IAT-Hook"><a href="#IAT-Hook" class="headerlink" title="IAT Hook"></a>IAT Hook</h1><h2 id="留出交叉引用版"><a href="#留出交叉引用版" class="headerlink" title="留出交叉引用版"></a>留出交叉引用版</h2><p>流程：</p>
<ol>
<li>找到导入表开始位置</li>
<li>根据目标函数所在的dll的名字找到对应dll的导入表</li>
<li>根据函数名字找到对应的IAT表</li>
<li>取消IAT的地址保护，将地址修改为自定义函数</li>
<li>恢复地址保护</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">BYTE* SavedAddr = (BYTE*)MessageBoxA;  // 因为这里调用了目标函数，因此IDA中可以通过交叉引用找到全局变量，进而找到hook函数</span><br><span class="line">int WINAPI My_MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) &#123;</span><br><span class="line">    // 1. 修改参数</span><br><span class="line">    lpText = &quot;Hooked by IAT!&quot;;</span><br><span class="line"></span><br><span class="line">    // 2. 调用原始API</span><br><span class="line">    typedef int (WINAPI* OrigMsgBox)(HWND, LPCSTR, LPCSTR, UINT);</span><br><span class="line">    OrigMsgBox orig = (OrigMsgBox)SavedAddr; // SavedAddr是原始地址</span><br><span class="line">    return orig(hWnd, lpText, lpCaption, uType);</span><br><span class="line">&#125;</span><br><span class="line">int hook() &#123;</span><br><span class="line">    IMAGE_DOS_HEADER* dos;</span><br><span class="line">    IMAGE_FILE_HEADER* fheader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">    IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR * import;</span><br><span class="line">    HMODULE hMod = GetModuleHandle(NULL);</span><br><span class="line">    BYTE* base = (BYTE*)hMod;</span><br><span class="line">    BYTE* buffer = base;</span><br><span class="line">    dos = (IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    buffer += dos-&gt;e_lfanew + 4;</span><br><span class="line">    fheader = (IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_FILE_HEADER);</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    import = (IMAGE_IMPORT_DESCRIPTOR*)(base + oheader-&gt;DataDirectory[1].VirtualAddress);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0;; i++) &#123;</span><br><span class="line">        if ((import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0)</span><br><span class="line">            || (!strcmp((char*)(base + import[i].Name), &quot;USER32.dll&quot;))) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0) &#123;  // 寻找目标dll</span><br><span class="line">        printf(&quot;未找到该dll，hook失败\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    IMAGE_THUNK_DATA32 * IAT = (IMAGE_THUNK_DATA32*)(base + import[i].FirstThunk);</span><br><span class="line">    IMAGE_THUNK_DATA32 * INT = (IMAGE_THUNK_DATA32*)(base + import[i].OriginalFirstThunk);</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        DWORD address = IAT[j].u1.Function;</span><br><span class="line">        if (address == 0) &#123;</span><br><span class="line">            printf(&quot;未找到该函数!!!\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (address == (DWORD)SavedAddr) break;  // 这里使用地址寻找目标函数</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD my_func_add = (DWORD)My_MessageBoxA;</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    VirtualProtect(IAT + j, 4, PAGE_READWRITE, &amp;oldProtect);    // 取消地址保护</span><br><span class="line">    IAT[j].u1.Function = my_func_add;</span><br><span class="line">    VirtualProtect(IAT + j, 4, oldProtect, &amp;oldProtect);   // 恢复地址保护</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = hook();  // 使用全局变量调用，使该函数早于main函数执行</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MessageBoxA(NULL, &quot;This should be hooked&quot;, &quot;Original MessageBox&quot;, MB_OK);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="隐藏交叉引用版"><a href="#隐藏交叉引用版" class="headerlink" title="隐藏交叉引用版:"></a>隐藏交叉引用版:</h2><p>相比于上面这种方法，接下来这个方法只是在寻找原函数IAT位置时不使用地址判断，而是改为使用函数名判断；并且保留原函数地址时不直接引用原函数，而是获取IAT修改之前的值。这样一来，就无法通过交叉引用找到自定义函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">DWORD SavedAddr;</span><br><span class="line">int WINAPI My_MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) &#123;</span><br><span class="line">    // 1. 修改参数</span><br><span class="line">    lpText = &quot;Hooked by IAT!&quot;;</span><br><span class="line"></span><br><span class="line">    // 2. 调用原始API</span><br><span class="line">    typedef int (WINAPI* OrigMsgBox)(HWND, LPCSTR, LPCSTR, UINT);</span><br><span class="line">    OrigMsgBox orig = (OrigMsgBox)SavedAddr; // SavedAddr是原始地址</span><br><span class="line">    return orig(hWnd, lpText, lpCaption, uType);</span><br><span class="line">&#125;</span><br><span class="line">int hook() &#123;</span><br><span class="line">    IMAGE_DOS_HEADER* dos;</span><br><span class="line">    IMAGE_FILE_HEADER* fheader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">    IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR * import;</span><br><span class="line">    HMODULE hMod = GetModuleHandle(NULL);</span><br><span class="line">    BYTE* base = (BYTE*)hMod;</span><br><span class="line">    BYTE* buffer = base;</span><br><span class="line">    dos = (IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    buffer += dos-&gt;e_lfanew + 4;</span><br><span class="line">    fheader = (IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_FILE_HEADER);</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">import = (IMAGE_IMPORT_DESCRIPTOR*)(base + oheader-&gt;DataDirectory[1].VirtualAddress);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0;; i++) &#123;</span><br><span class="line">        if ((import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0)</span><br><span class="line">            || (!strcmp((char*)(base + import[i].Name), &quot;USER32.dll&quot;))) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0) &#123;</span><br><span class="line">        printf(&quot;未找到该dll，hook失败\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    IMAGE_THUNK_DATA32 * IAT = (IMAGE_THUNK_DATA32*)(base + import[i].FirstThunk);</span><br><span class="line">    IMAGE_THUNK_DATA32 * INT = (IMAGE_THUNK_DATA32*)(base + import[i].OriginalFirstThunk);</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if (INT[j].u1.Ordinal &gt;&gt; 31 == 1) continue;</span><br><span class="line">        char* s = (char*)(base + INT[j].u1.AddressOfData + 2);</span><br><span class="line">        if (INT[j].u1.AddressOfData == 0) &#123;</span><br><span class="line">            printf(&quot;未找到该函数!!!\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!strcmp(s, &quot;MessageBoxA&quot;)) break;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD my_func_add = (DWORD)My_MessageBoxA;</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    SavedAddr = IAT[j].u1.Function;   // 因为这里并没有引用原函数，而是直接通过IAT表获取原函数地址，所以交叉引用无效</span><br><span class="line">    VirtualProtect(IAT + j, 4, PAGE_READWRITE, &amp;oldProtect);</span><br><span class="line">    IAT[j].u1.Function = my_func_add;</span><br><span class="line">    VirtualProtect(IAT + j, 4, oldProtect, &amp;oldProtect);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = hook();  // 使用全局变量调用，使该函数早于main函数执行</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MessageBoxA(NULL, &quot;This should be hooked&quot;, &quot;Original MessageBox&quot;, MB_OK);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/30238/image-20250714180609215.png" class="" title="image-20250714180609215">
]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC区域赛wp</title>
    <url>/posts/54083/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="faze"><a href="#faze" class="headerlink" title="faze"></a>faze</h2><p>主逻辑就是先生成迷宫图，然后调用dM7函数寻找路径，把路径保存在v9，最后与输入进行比较，把断点设置在这:</p>
<img src="/posts/54083/image-20250510120643938.png" class="" title="image-20250510120643938">

<p>动调查看v9的值：</p>
<img src="/posts/54083/image-20250510120734428.png" class="" title="image-20250510120734428">

<p>shift+e提取，这就是flag</p>
<h2 id="greeting"><a href="#greeting" class="headerlink" title="greeting"></a>greeting</h2><p>主要加密流程：每个字节经过异或和循环左移操作，移位次数由索引值和某种除法结果决定</p>
<img src="/posts/54083/image-20250513183726985.png" class="" title="image-20250513183726985">

<p>经过上述加密后与密文比较。密文：</p>
<img src="/posts/54083/image-20250513183800011.png" class="" title="image-20250513183800011">

<img src="/posts/54083/image-20250513183838639.png" class="" title="image-20250513183838639">

<img src="/posts/54083/image-20250513183906393.png" class="" title="image-20250513183906393">

<p>写出解密脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def ror(n, shift):</span><br><span class="line">    return ((n &gt;&gt; (shift % 8)) | (n &lt;&lt; (8 - (shift % 8)))) &amp; 0xFF</span><br><span class="line"></span><br><span class="line">encrypted_data = [0x13,0x10,0x7C,0xF0,0x52,0x6C,0x56,0x10,0xA1,0x32,0x39,0x2A,0x94,0x19,0xB0,0x14]</span><br><span class="line">flag = []</span><br><span class="line">for i in range(16):</span><br><span class="line">    rol_amount = i % 5</span><br><span class="line">    byte = encrypted_data[i]</span><br><span class="line">    rotated = ror(byte, rol_amount)</span><br><span class="line">    original = rotated ^ (i + 0x5A)</span><br><span class="line">    flag.append(chr(original))</span><br><span class="line">print(&#x27;&#x27;.join(flag))</span><br></pre></td></tr></table></figure>

<h2 id="SecretGrid"><a href="#SecretGrid" class="headerlink" title="SecretGrid"></a>SecretGrid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">void decrypt(char* input, char* output) &#123;</span><br><span class="line">    char key[] = &#123;&quot;ISCC&#123;s_ale_ru_upatu_prrlaullre_&#125;&quot;&#125;;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">        if ((i &amp; 1) == 0) &#123;</span><br><span class="line">            output[i] = input[i] ^ (key[i] + 2);</span><br><span class="line">        &#125; else if (i % 3 == 0) &#123;</span><br><span class="line">            output[i] = input[i] ^ (key[i] + 5);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            output[i] = input[i] ^ key[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output[30] = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char v[] = &#123;</span><br><span class="line">        6,39,125,4,13,49,14,52,41,94,27,11,49,110,0,4,10,64,84,116,43,57,53,74,7,31,3,25,43,6</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    char t[30];</span><br><span class="line">    decrypt(v, t);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">        printf(&quot;%c&quot;, t[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有趣的小游戏"><a href="#有趣的小游戏" class="headerlink" title="有趣的小游戏"></a>有趣的小游戏</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">import struct</span><br><span class="line">from ctypes import c_uint32</span><br><span class="line">def xxtea_encrypt(n, v, key):</span><br><span class="line">    # 全部转为c_unit32格式</span><br><span class="line">    v = [c_uint32(i) for i in v]</span><br><span class="line">    r = 6 + 52 // n</span><br><span class="line">    v1 = v[n-1].value</span><br><span class="line">    delta = 0x9e3779b9</span><br><span class="line">    total = c_uint32(0)</span><br><span class="line">    for i in range(r):</span><br><span class="line">        total.value += delta</span><br><span class="line">        e = (total.value &gt;&gt; 2) &amp; 3</span><br><span class="line">        for j in range(n-1):</span><br><span class="line">            v0 = v[j+1].value</span><br><span class="line">            v[j].value += ((((v1 &gt;&gt; 5) ^ (v0 &lt;&lt; 2)) + ((v0 &gt;&gt; 3) ^ (v1 &lt;&lt; 4))) ^ ((total.value ^ v0) + (key[(j &amp; 3) ^ e] ^ v1)))</span><br><span class="line">            v1 = v[j].value</span><br><span class="line">        v0 = v[0].value</span><br><span class="line">        v[n-1].value += ((((v1 &gt;&gt; 5) ^ (v0 &lt;&lt; 2)) + ((v0 &gt;&gt; 3) ^ (v1 &lt;&lt; 4))) ^ ((total.value ^ v0) + (key[((n-1) &amp; 3) ^ e] ^ v1)))</span><br><span class="line">        v1 = v[n-1].value</span><br><span class="line">    return [i.value for i in v]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def xxtea_decrypt(n, v, key):</span><br><span class="line">    # 全部转为c_unit32格式</span><br><span class="line">    v = [c_uint32(i) for i in v]</span><br><span class="line">    r = 6 + 52 // n</span><br><span class="line">    v0 = v[0].value</span><br><span class="line">    delta = 0x9e3779b9</span><br><span class="line">    total = c_uint32(delta * r)</span><br><span class="line">    for i in range(r):</span><br><span class="line">        e = (total.value &gt;&gt; 2) &amp; 3</span><br><span class="line">        for j in range(n-1, 0, -1):</span><br><span class="line">            v1 = v[j-1].value</span><br><span class="line">            v[j].value -= ((((v1 &gt;&gt; 5) ^ (v0 &lt;&lt; 2)) + ((v0 &gt;&gt; 3) ^ (v1 &lt;&lt; 4))) ^ ((total.value ^ v0) + (key[(j &amp; 3) ^ e] ^ v1)))</span><br><span class="line">            v0 = v[j].value</span><br><span class="line">        v1 = v[n-1].value</span><br><span class="line">        v[0].value -= ((((v1 &gt;&gt; 5) ^ (v0 &lt;&lt; 2)) + ((v0 &gt;&gt; 3) ^ (v1 &lt;&lt; 4))) ^ ((total.value ^ v0) + (key[(0 &amp; 3) ^ e] ^ v1)))</span><br><span class="line">        v0 = v[0].value</span><br><span class="line">        total.value -= delta</span><br><span class="line">    return [i.value for i in v]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k = [0x12345678, 0x9ABCDEF0, 0xFEDCBA98, 0x76543210]</span><br><span class="line">l = 30</span><br><span class="line">v = [0x8f644b67,0x8dc43994,0x7baf4ebb,0xe5b92cd4,0xe540e3f2,0xb81e24dc,0x3f7addc5,0xfb7aecb0,0x65520266,0xb42f1f86,0xda99ca47,0x75869f5d,0x8ca022e6,0x1f2270ea,0x48f3183c,0xc293f7dd,0xfee027a6,0xe5e5f139,0x189cf5bd,0xdfefdb8f,0xca3e03d0,0x9423c07c,0x30653ba2,0x44334245,0xf8e760fe,0x7225fa4d,0x7c119f87,0x34718b8c,0x5751fc75,0x63080380]</span><br><span class="line">for i in range(10000):</span><br><span class="line">    v = xxtea_decrypt(l, v, k)</span><br><span class="line">    # print(list(map(hex, v)))</span><br><span class="line">    out = b&quot;&quot;.join([struct.pack(&quot;&lt;I&quot;, i) for i in v])</span><br><span class="line">    try:</span><br><span class="line">        print(out.decode())</span><br><span class="line">        print(&quot;&quot;.join([chr(out[i:i+4][0]) for i in range(0, len(out), 4)]), end=&quot;&quot;)</span><br><span class="line">    except:</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure>





<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><p>两个压缩文件part1、part2</p>
<p>part1:</p>
<p>数据区加密标志位（偶数代表未加密）：</p>
<img src="/posts/54083/image-20250512011547834.png" class="" title="image-20250512011547834">

<p>目录段加密标志位（奇数代表是伪加密）：</p>
<img src="/posts/54083/image-20250512011738345.png" class="" title="image-20250512011738345">

<p>将70 00 改为00 00 即可正常解压。</p>
<p>解压后打开文件：</p>
<img src="/posts/54083/image-20250512012430449.png" class="" title="image-20250512012430449">

<p>说明下一个压缩包是掩码爆破。开始爆破：</p>
<img src="/posts/54083/image-20250512012545795.png" class="" title="image-20250512012545795">

<p>得到密码：</p>
<img src="/posts/54083/image-20250512012531176.png" class="" title="image-20250512012531176">

<h1 id="Mobile"><a href="#Mobile" class="headerlink" title="Mobile"></a>Mobile</h1><h2 id="邦布出击"><a href="#邦布出击" class="headerlink" title="邦布出击"></a>邦布出击</h2><img src="/posts/54083/image-20250512022757837.png" class="" title="image-20250512022757837">

<p>这里发现疑似base64密文，解密一下看看</p>
<img src="/posts/54083/image-20250517011536825.png" class="" title="image-20250517011536825">

<p>从这里的结果可以看到，要对前面三个字符串进行三次base64解密。将上面前三段字符串拼接在一起，进行三次base64解密，得到数据库解密密钥：</p>
<img src="/posts/54083/image-20250512022912882.png" class="" title="image-20250512022912882">

<p>使用sqlcipher工具进行数据库解密，得到解密后的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRAGMA key = &#x27;JINGLIU&#x27;;</span><br><span class="line">ATTACH DATABASE &#x27;plaintext.db&#x27; AS plaintext KEY &#x27;&#x27;;</span><br><span class="line">SELECT sqlcipher_export(&#x27;plaintext&#x27;);</span><br><span class="line">DETACH DATABASE plaintext;</span><br></pre></td></tr></table></figure>

<img src="/posts/54083/image-20250512023105094.png" class="" title="image-20250512023105094">

<p>把得到的数据库用DB Browser for SQLCipher打开：</p>
<img src="/posts/54083/image-20250512023209496.png" class="" title="image-20250512023209496">

<p>这里面这个key后面要用到。</p>
<img src="/posts/54083/image-20250515135051283.png" class="" title="image-20250515135051283">

<p>根据主函数逻辑，先使用a.a生成密文，然后使用getiv生成密钥，DESHelper().encrypt进行加密，拿加密结果与输入进行对比。因此可以通过frida的hook来直接得到加密后的结果。先尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Hook DESHelper.encrypt</span><br><span class="line">        var cls1 = Java.use(&quot;com.example.mobile01.DESHelper&quot;);</span><br><span class="line">        cls1.encrypt.implementation = function(data, key, iv) &#123;</span><br><span class="line">            var enc_data = this.encrypt(data, key, iv);</span><br><span class="line">            console.log(&quot;Flag: ISCC&#123;&quot; + enc_data + &quot;&#125;&quot;);</span><br><span class="line">            return enc_data;</span><br><span class="line">        &#125;;</span><br><span class="line">        console.log(&quot;[+] Hooked com.example.mobile01.DESHelper.encrypt()&quot;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.error(&quot;[-] Failed to hook DESHelper.encrypt: &quot; + err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>发现程序会直接报错然后直接退出</p>
<img src="/posts/54083/image-20250515135529398.png" class="" title="image-20250515135529398">

<p>这样完全无法得到密文或者IV。采用控制变量法来探究为什么会出现报错。先hook让a.a不运行</p>
<img src="/posts/54083/image-20250515135708911.png" class="" title="image-20250515135708911">

<img src="/posts/54083/image-20250515135824540.png" class="" title="image-20250515135824540">

<p>结果发现程序不会断开，而且IV能正常得到，这就说明问题在a.a里面。继续看a.a里面调用的b.b，试一试直接打印b.b返回值：</p>
<img src="/posts/54083/image-20250515140117960.png" class="" title="image-20250515140117960">

<p>发现能正常返回，说明不是b.b的问题。继续思考，在a.a里面的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SecretKeySpec secretKeySpec = new SecretKeySpec(process(b.c()), &quot;Blowfish&quot;);</span><br></pre></td></tr></table></figure>

<p>中，b.c直接返回空字符串，然后将该空字符串设置为密钥。问题就在这，空的密钥会导致密钥填充失败，所以程序会直接报错闪退。那么拿什么填充密钥？前面数据库文件里面</p>
<img src="/posts/54083/image-20250515140458909.png" class="" title="image-20250515140458909">

<p>blowfish恰好对应a.a的加密方法，所以猜测这里面的key就是真正的key。使用frida将这个key hook到b.c的返回值，使它当key传入。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Hook com.example.mobile01.b.c() </span><br><span class="line">        var cls2 = Java.use(&quot;com.example.mobile01.b&quot;);</span><br><span class="line">        cls2.c.implementation = function() &#123;</span><br><span class="line">            var res = &quot;AtBgCfDhEjFlGqHp&quot;;//把数据库里的key放入</span><br><span class="line">            console.log(&quot;[*] com.example.mobile01.b.b() called, returned: &quot; + res);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;;</span><br><span class="line">        console.log(&quot;[+] Hooked com.example.mobile01.a.a()&quot;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.error(&quot;[-] Failed to hook com.example.mobile01.a.a(): &quot; + err);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Hook DESHelper.encrypt</span><br><span class="line">        var cls1 = Java.use(&quot;com.example.mobile01.DESHelper&quot;);</span><br><span class="line">        cls1.encrypt.implementation = function(data, key, iv) &#123;</span><br><span class="line">            var enc_data = this.encrypt(data, key, iv);</span><br><span class="line">            console.log(&quot;Flag: ISCC&#123;&quot; + enc_data + &quot;&#125;&quot;);</span><br><span class="line">            return enc_data;</span><br><span class="line">        &#125;;</span><br><span class="line">        console.log(&quot;[+] Hooked com.example.mobile01.DESHelper.encrypt()&quot;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.error(&quot;[-] Failed to hook DESHelper.encrypt: &quot; + err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输入指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -U -l hook_des.js -f com.example.mobile01</span><br></pre></td></tr></table></figure>

<p>得到flag：</p>
<img src="/posts/54083/image-20250515141140152.png" class="" title="image-20250515141140152">

<h2 id="Detective"><a href="#Detective" class="headerlink" title="Detective"></a>Detective</h2><img src="/posts/54083/image-20250513083750267.png" class="" title="image-20250513083750267">

<p>调用了native层的validatePassword函数</p>
<img src="/posts/54083/image-20250513084030558.png" class="" title="image-20250513084030558">

<p>是一个sha256，密码是4位。可以直接爆破：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">data = &quot;23213b6f905655aaf0510c9054e4b14719d07c2c17c08d826a5f9139d8c234f9&quot;</span><br><span class="line">table = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span><br><span class="line"></span><br><span class="line">for chars in itertools.product(table, repeat=4):</span><br><span class="line">    pwd = &#x27;&#x27;.join(chars)</span><br><span class="line">    sha256_hash = hashlib.sha256(pwd.encode()).hexdigest()</span><br><span class="line">    if sha256_hash == data:</span><br><span class="line">        result = pwd</span><br><span class="line">        break</span><br><span class="line">else:</span><br><span class="line">    result = None</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>得到密码SHER。再查看mainzctivity：</p>
<img src="/posts/54083/image-20250513084718675.png" class="" title="image-20250513084718675">

<p>主要在于最后一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.length() &gt;= 8 &amp;&amp; (str.length() + 1) % 2 != 0 &amp;&amp; str.substring(0, 5).equals(&quot;ISCC&#123;&quot;) &amp;&amp; str.charAt(str.length() - 1) == &#x27;&#125;&#x27; &amp;&amp; stringFromJNI(a.a(str.substring(5, str.length() - 1))).equals(&quot;105C5A31214E50520020444E2F3A&quot;);</span><br></pre></td></tr></table></figure>

<p>这里的stringFromJNI函数和a函数对输入进行了加密。a函数：</p>
<img src="/posts/54083/image-20250513085045386.png" class="" title="image-20250513085045386">

<img src="/posts/54083/image-20250513085157635.png" class="" title="image-20250513085157635">

<p>stringFromJNI函数（部分）:</p>
<img src="/posts/54083/image-20250513090334219.png" class="" title="image-20250513090334219">

<p>这里肯定用了异或，猜测Sherlock是作为密钥传入。<br>hook 4个函数，观察其行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">    const MainActivity = Java.use(&quot;com.example.detective.MainActivity&quot;);</span><br><span class="line">    const detective_a = Java.use(&quot;com.example.detective.a&quot;);</span><br><span class="line">    const detective_b = Java.use(&quot;com.example.detective.b&quot;);</span><br><span class="line">    // Hook Java 层的 a.a</span><br><span class="line">    detective_a.a.implementation = function (input) &#123;</span><br><span class="line">        const result = this.a(input);</span><br><span class="line">        console.log(&quot;[*] a.a called&quot;);</span><br><span class="line">        console.log(&quot;    Input : &quot; + input);</span><br><span class="line">        console.log(&quot;    Output: &quot; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Hook native 层的 stringFromJNI</span><br><span class="line">    MainActivity.stringFromJNI.implementation = function (input) &#123;</span><br><span class="line">        console.log(&quot;[*] stringFromJNI called&quot;);</span><br><span class="line">        console.log(&quot;    Input : &quot; + input);</span><br><span class="line">        const result = this.stringFromJNI(input);</span><br><span class="line">        console.log(&quot;    Output: &quot; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Hook Java 层的 a.c</span><br><span class="line">    detective_a.c.implementation = function (input) &#123;</span><br><span class="line">        const result = this.c(input);</span><br><span class="line">        console.log(&quot;[*] a.c called&quot;);</span><br><span class="line">        console.log(&quot;    Input : &quot; + input);</span><br><span class="line">        console.log(&quot;    Output: &quot; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Hook Java 层的 a.b</span><br><span class="line">    detective_a.b.implementation = function (input) &#123;</span><br><span class="line">        const result = this.b(input);</span><br><span class="line">        console.log(&quot;[*] a.b called&quot;);</span><br><span class="line">        console.log(&quot;    Input : &quot; + input);</span><br><span class="line">        console.log(&quot;    Output: &quot; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Hook Java 层的 b.a</span><br><span class="line">    detective_b.a.implementation = function (input) &#123;</span><br><span class="line">        const result = this.a(input);</span><br><span class="line">        console.log(&quot;[*] b.a called&quot;);</span><br><span class="line">        console.log(&quot;    Input : &quot; + input);</span><br><span class="line">        console.log(&quot;    Output: &quot; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;[+] Hooks installed on C0500a.m51a and stringFromJNI&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">// frida -U -l hook_des.js -f com.example.detective</span><br></pre></td></tr></table></figure>

<img src="/posts/54083/image-20250513142404847.png" class="" title="image-20250513142404847">

<p>拿stringFromJNI函数输入进行异或得到：</p>
<img src="/posts/54083/image-20250513142757999.png" class="" title="image-20250513142757999">

<p>与hook得到的结果完全相同，意味着这个函数的作用就是将字符串异或后再转化为16进制字符串。再仔细分析一下其他函数，a.b函数貌似是将字符串转化为16进制串，然后补0；a.c是a.b的逆过程。b.a是一个加密过程，目前看不出来，得分析源码。</p>
<p>代码中有两个String，sb和sb2，用于分别处理不同条件下的字符。外层循环遍历输入字符串的每个字符，根据i的奇偶性来决定将字符添加到sb还是sb2。这里i从0开始，所以i%2&#x3D;&#x3D;0对应的其实是奇数位置（因为索引从0开始）。不过i的初始值是0，每次循环i递增，因此在判断i%2&#x3D;&#x3D;0时，实际上是在处理偶数索引的位置（比如第0、2、4位），而奇数索引的字符被处理到sb中。</p>
<p>接下来，当i%2&#x3D;&#x3D;0时，会检查i3的值是否为1或者(i3-1)是否能被3整除，如果是的话，并且当前字符是’0’，则替换为’3’，否则保留原字符。同样，在处理奇数索引时，i2的条件是是否为0或者能被3整除，同样替换’0’为’3’。</p>
<p>然后，sb2被追加了sb的内容，合并后的结果被处理到sb3中。这里有一个循环，每次取两个字符charAt2和charAt3。如果charAt2不是’3’到’7’之间的字符，则交换这两个字符的位置，并追加”21”。否则，保持顺序不变。最后，生成的字符串通过正则表达式替换每两个字符为”$100”，然后截取去掉最后两个字符。</p>
<p>解密脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def xor_decrypt(ciphertext_hex, key_str):</span><br><span class="line">    cipher_bytes = bytes.fromhex(ciphertext_hex)</span><br><span class="line">    key_bytes = bytes(key_str, &#x27;utf-8&#x27;)</span><br><span class="line">    </span><br><span class="line">    plain_bytes = bytearray()</span><br><span class="line">    for i in range(len(cipher_bytes)):</span><br><span class="line">        plain_bytes.append(cipher_bytes[i] ^ key_bytes[i % len(key_bytes)])</span><br><span class="line">    </span><br><span class="line">    return plain_bytes.hex()</span><br><span class="line"></span><br><span class="line">def process_hex_string(hex_str):</span><br><span class="line">    print(&quot;Processing hex:&quot;, hex_str)</span><br><span class="line">    buffer = []</span><br><span class="line">    ptr = 0</span><br><span class="line">    </span><br><span class="line">    while ptr &lt; len(hex_str):</span><br><span class="line">        curr_char = hex_str[ptr]</span><br><span class="line">        next_char = hex_str[ptr+1]</span><br><span class="line">        </span><br><span class="line">        # 检查特殊标记&quot;21&quot;和处理条件</span><br><span class="line">        if ptr + 4 &lt;= len(hex_str) and hex_str[ptr+2:ptr+4] == &#x27;21&#x27; and next_char not in &#x27;34567&#x27;:</span><br><span class="line">            buffer.append(next_char)</span><br><span class="line">            buffer.append(curr_char)</span><br><span class="line">            ptr += 4</span><br><span class="line">        else:</span><br><span class="line">            buffer.append(curr_char)</span><br><span class="line">            buffer.append(next_char)</span><br><span class="line">            ptr += 2</span><br><span class="line"></span><br><span class="line">    combined_str = &#x27;&#x27;.join(buffer)</span><br><span class="line">    split_pos = len(combined_str) // 2</span><br><span class="line">    first_part = combined_str[:split_pos]</span><br><span class="line">    second_part = combined_str[split_pos:]</span><br><span class="line">    </span><br><span class="line">    print(&#x27;First part:&#x27;, first_part)</span><br><span class="line">    print(&#x27;Second part:&#x27;, second_part)</span><br><span class="line">    </span><br><span class="line">    # 重构原始字符串</span><br><span class="line">    reconstructed = []</span><br><span class="line">    first_idx = second_idx = 0</span><br><span class="line">    counter_1 = counter_2 = 0</span><br><span class="line">    </span><br><span class="line">    for pos in range(len(combined_str)):</span><br><span class="line">        if pos % 2 == 0:  # 处理第二部分</span><br><span class="line">            if second_idx &gt;= len(second_part):</span><br><span class="line">                break</span><br><span class="line">            char = second_part[second_idx]</span><br><span class="line">            second_idx += 1</span><br><span class="line">            if (counter_2 == 0 or counter_2 % 3 == 0) and char == &#x27;3&#x27;:</span><br><span class="line">                reconstructed.append(&#x27;0&#x27;)</span><br><span class="line">            else:</span><br><span class="line">                reconstructed.append(char)</span><br><span class="line">            counter_2 += 1</span><br><span class="line">        else:             # 处理第一部分</span><br><span class="line">            char = first_part[first_idx]</span><br><span class="line">            first_idx += 1</span><br><span class="line">            if (counter_1 == 1 or (counter_1 - 1) % 3 == 0) and char == &#x27;3&#x27;:</span><br><span class="line">                reconstructed.append(&#x27;0&#x27;)</span><br><span class="line">            else:</span><br><span class="line">                reconstructed.append(char)</span><br><span class="line">            counter_1 += 1</span><br><span class="line">    </span><br><span class="line">    return &#x27;&#x27;.join(reconstructed)</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">encrypted_data = &quot;105C5A31214E50520020444E2F3A&quot;</span><br><span class="line">decryption_key = &quot;Sherlock&quot;</span><br><span class="line"></span><br><span class="line"># 解密阶段</span><br><span class="line">decrypted_hex = xor_decrypt(encrypted_data, decryption_key)</span><br><span class="line">processed_hex = process_hex_string(decrypted_hex)</span><br><span class="line"></span><br><span class="line"># 最终转换</span><br><span class="line">print(&quot;\nFinal result:&quot;)</span><br><span class="line">for i in range(0, len(processed_hex), 3):</span><br><span class="line">    hex_triplet = processed_hex[i:i+3]</span><br><span class="line">    print(chr(int(hex_triplet, 16)), end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>PE解析器</title>
    <url>/posts/38541/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="PE解析器"><a href="#PE解析器" class="headerlink" title="PE解析器"></a>PE解析器</h1><p>主要功能：</p>
<ol>
<li>打印PE头</li>
<li>打印节表</li>
<li>打印数据目录表</li>
</ol>
<p>在终端中将PE文件路径传入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">void DOS_head(unsigned char *pfile)&#123;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)pfile;</span><br><span class="line">    printf(&quot;DOS头:\n&quot;);</span><br><span class="line">    printf(&quot;e_magic:%#06x\te_lfanew:%#010x\n\n&quot;,dos-&gt;e_magic,dos-&gt;e_lfanew);</span><br><span class="line">&#125;</span><br><span class="line">void file_header(unsigned char *pfile)&#123;</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)pfile;</span><br><span class="line">    printf(&quot;FILE头:\n&quot;);</span><br><span class="line">    printf(&quot;Machine: %#06x\n&quot;, fheader-&gt;Machine);</span><br><span class="line">    printf(&quot;NumberOfSections: %#06x\n&quot;, fheader-&gt;NumberOfSections);</span><br><span class="line">    printf(&quot;TimeDateStamp: %#010x\n&quot;, fheader-&gt;TimeDateStamp);</span><br><span class="line">    printf(&quot;PointerToSymbolTable: %#010x\n&quot;, fheader-&gt;PointerToSymbolTable);</span><br><span class="line">    printf(&quot;NumberOfSymbols: %#010x\n&quot;, fheader-&gt;NumberOfSymbols);</span><br><span class="line">    printf(&quot;SizeOfOptionalHeader: %#06x\n&quot;, fheader-&gt;SizeOfOptionalHeader);</span><br><span class="line">    printf(&quot;Characteristics: %#06x\n\n\n&quot;, fheader-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line">void optional_header(unsigned char* pfile)&#123;</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)pfile;</span><br><span class="line">    printf(&quot;optional头:\n&quot;);</span><br><span class="line">    printf(&quot;SizeOfCode:%#010x\n&quot;,oheader-&gt;SizeOfCode);</span><br><span class="line">    printf(&quot;SizeOfInitializedData:%#010x\n&quot;,oheader-&gt;SizeOfInitializedData);</span><br><span class="line">    printf(&quot;SizeOfUninitializedData:%#010x\n&quot;,oheader-&gt;SizeOfUninitializedData);</span><br><span class="line">    printf(&quot;AddressOfEntryPoint:%#010x\n&quot;,oheader-&gt;AddressOfEntryPoint);</span><br><span class="line">    printf(&quot;BaseOfCode:%#010x\n&quot;,oheader-&gt;BaseOfCode);</span><br><span class="line">    printf(&quot;BaseOfData:%#010x\n&quot;,oheader-&gt;BaseOfData);</span><br><span class="line">    printf(&quot;ImageBase:%#010x\n&quot;,oheader-&gt;ImageBase);</span><br><span class="line">    printf(&quot;SectionAlignment:%#010x\n&quot;,oheader-&gt;SectionAlignment);</span><br><span class="line">    printf(&quot;FileAlignment:%#010x\n&quot;,oheader-&gt;FileAlignment);</span><br><span class="line">    printf(&quot;SizeOfImage:%#010x\n&quot;,oheader-&gt;SizeOfImage);</span><br><span class="line">    printf(&quot;SizeOfHeaders:%#010x\n\n\n&quot;,oheader-&gt;SizeOfHeaders);</span><br><span class="line">&#125;</span><br><span class="line">void directory_print()&#123;</span><br><span class="line">    printf(&quot;Directory:\n&quot;);</span><br><span class="line">    printf(&quot;Name                           RVA              size\n&quot;);</span><br><span class="line">    printf(&quot;Export Directory               %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[0].VirtualAddress,oheader-&gt;DataDirectory[0].Size);</span><br><span class="line">    printf(&quot;Import Directory               %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[1].VirtualAddress,oheader-&gt;DataDirectory[1].Size);</span><br><span class="line">    printf(&quot;Resource Directory             %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[2].VirtualAddress,oheader-&gt;DataDirectory[2].Size);</span><br><span class="line">    printf(&quot;Exception Directory            %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[3].VirtualAddress,oheader-&gt;DataDirectory[3].Size);</span><br><span class="line">    printf(&quot;Security Directory             %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[4].VirtualAddress,oheader-&gt;DataDirectory[4].Size);</span><br><span class="line">    printf(&quot;Base Relocation Table          %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[5].VirtualAddress,oheader-&gt;DataDirectory[5].Size);</span><br><span class="line">    printf(&quot;Debug Directory                %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[6].VirtualAddress,oheader-&gt;DataDirectory[6].Size);</span><br><span class="line">    printf(&quot;Architecture Specific Data     %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[7].VirtualAddress,oheader-&gt;DataDirectory[7].Size);</span><br><span class="line">    printf(&quot;RVA of GP                      %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[8].VirtualAddress,oheader-&gt;DataDirectory[8].Size);</span><br><span class="line">    printf(&quot;TLS Directory                  %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[9].VirtualAddress,oheader-&gt;DataDirectory[9].Size);</span><br><span class="line">    printf(&quot;Load Config Directory          %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[10].VirtualAddress,oheader-&gt;DataDirectory[10].Size);</span><br><span class="line">    printf(&quot;Bound Import Directory         %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[11].VirtualAddress,oheader-&gt;DataDirectory[11].Size);</span><br><span class="line">    printf(&quot;Import Address Table           %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[12].VirtualAddress,oheader-&gt;DataDirectory[12].Size);</span><br><span class="line">    printf(&quot;Delay Import Descriptors       %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[13].VirtualAddress,oheader-&gt;DataDirectory[13].Size);</span><br><span class="line">    printf(&quot;COM Runtime descriptor         %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[14].VirtualAddress,oheader-&gt;DataDirectory[14].Size);</span><br><span class="line">    printf(&quot;Reserved                       %#010x       %#010x\n&quot;,oheader-&gt;DataDirectory[15].VirtualAddress,oheader-&gt;DataDirectory[15].Size);</span><br><span class="line">&#125;</span><br><span class="line">void section_header(unsigned char *pfile)&#123;</span><br><span class="line">    int num = fheader-&gt;NumberOfSections;</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)pfile;</span><br><span class="line">    int i=0;</span><br><span class="line">    IMAGE_SECTION_HEADER* p=NULL;</span><br><span class="line">    printf(&quot;节表:\n&quot;);</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        p = &amp;sheader[i];</span><br><span class="line">        printf(&quot;name:%s\n&quot;,p-&gt;Name);</span><br><span class="line">        printf(&quot;VirtualSize:%#010x\n&quot;,p-&gt;Misc);</span><br><span class="line">        printf(&quot;VirtualAddress:%#010x\n&quot;,p-&gt;VirtualAddress);</span><br><span class="line">        printf(&quot;SizeOfRawData:%#010x\n&quot;,p-&gt;SizeOfRawData);</span><br><span class="line">        printf(&quot;PointerToRawData:%#010x\n&quot;,p-&gt;PointerToRawData);</span><br><span class="line">        printf(&quot;Characteristics:%#010x\n\n&quot;,p-&gt;Characteristics);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    if(argc != 2) &#123;</span><br><span class="line">        printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    const char* pe_path = argv[1];</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    int psize=ftell(pf);</span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(psize);</span><br><span class="line">    fread(file_buf,1,psize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    DOS_head(file_buf);</span><br><span class="line">    unsigned char* offset = file_buf + dos-&gt;e_lfanew;</span><br><span class="line">    if (memcmp(offset, &quot;PE\0\0&quot;, 4) != 0) &#123;</span><br><span class="line">        printf(&quot;不是有效的PE文件\n&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        free(dos);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += 4; // 定位到file头</span><br><span class="line">    file_header(offset);</span><br><span class="line">    offset += sizeof(IMAGE_FILE_HEADER); // 定位到可选头</span><br><span class="line">    optional_header(offset);</span><br><span class="line">    offset += sizeof(IMAGE_OPTIONAL_HEADER32);  // 定位到节表</span><br><span class="line">    section_header(offset);</span><br><span class="line">    directory_print();</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RVA与FOA转化器"><a href="#RVA与FOA转化器" class="headerlink" title="RVA与FOA转化器"></a>RVA与FOA转化器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">DWORD FOA_to_RVA(DWORD foa)&#123;</span><br><span class="line">    DWORD rva=0;</span><br><span class="line">    if(foa&lt;oheader-&gt;SizeOfHeaders) &#123;</span><br><span class="line">        rva = foa;</span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;fheader-&gt;NumberOfSections;i++)&#123;</span><br><span class="line">        if(foa&gt;=sheader[i].PointerToRawData&amp;&amp;foa&lt;(sheader[i].PointerToRawData+sheader[i].SizeOfRawData))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=foa-sheader[i].PointerToRawData;</span><br><span class="line">    rva = sheader[i].VirtualAddress + offset;</span><br><span class="line">    return rva;</span><br><span class="line">&#125;</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">    DWORD foa=0;</span><br><span class="line">    if(rva&lt;oheader-&gt;SizeOfHeaders) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;fheader-&gt;NumberOfSections;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == fheader-&gt;NumberOfSections) &#123;printf(&quot;没有对应的FOA\n&quot;);return 0;&#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">    return foa;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    if(argc != 2) &#123;</span><br><span class="line">        printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    const char* pe_path = argv[1];</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    int fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize);</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *buffer=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    buffer+=dos-&gt;e_lfanew+4;  // 定位文件头</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer+=20;      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    int size = fheader-&gt;NumberOfSections * sizeof(IMAGE_SECTION_HEADER);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    int flag=0;</span><br><span class="line">    DWORD foa=0,rva=0;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;请输入你需要进行的操作（FOA-&gt;RVA选择1,RVA-&gt;FOA选择2,退出选择-1）:\n&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;flag);</span><br><span class="line">        switch(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            case 1:&#123;</span><br><span class="line">                printf(&quot;请输入FOA：&quot;);</span><br><span class="line">                scanf(&quot;%x&quot;,&amp;foa);</span><br><span class="line">                if(foa&gt;fsize||foa&lt;0) &#123;printf(&quot;超出范围!!!&quot;);return 0;&#125;</span><br><span class="line">                rva=FOA_to_RVA(foa);</span><br><span class="line">                printf(&quot;RVA为：%#x,VA为：%#x\n&quot;,rva,rva+oheader-&gt;ImageBase);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 2:&#123;</span><br><span class="line">                printf(&quot;请输入RVA：&quot;);</span><br><span class="line">                scanf(&quot;%x&quot;,&amp;rva);</span><br><span class="line">                if(rva&lt;0||rva&gt;oheader-&gt;SizeOfImage) &#123;printf(&quot;超出范围!!!&quot;);return 0;&#125;</span><br><span class="line">                foa=RVA_to_FOA(rva);</span><br><span class="line">                printf(&quot;FOA为：%#x\n&quot;,foa);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default:</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>TGCTF</title>
    <url>/posts/40555/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="randomsystem"><a href="#randomsystem" class="headerlink" title="randomsystem"></a>randomsystem</h2><p>主函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 sub_412370()</span><br><span class="line">&#123;</span><br><span class="line">  v23 = 0;</span><br><span class="line">  v24 = 0;</span><br><span class="line">  v25 = 0;</span><br><span class="line">  v26 = 0;</span><br><span class="line">  v27 = 0;</span><br><span class="line">  j_memset(v19, 0, 0x100u);</span><br><span class="line">  j_memset(v18, 0, sizeof(v18));</span><br><span class="line">  strcpy(key, &quot;KeYkEy!!&quot;);</span><br><span class="line">  v17[0] = 376;</span><br><span class="line">  v17[1] = 356;</span><br><span class="line">  v17[2] = 169;</span><br><span class="line">  v17[3] = 501;</span><br><span class="line">  v17[4] = 277;</span><br><span class="line">  v17[5] = 329;</span><br><span class="line">  v17[6] = 139;</span><br><span class="line">  v17[7] = 342;</span><br><span class="line">  v17[8] = 380;</span><br><span class="line">  v17[9] = 365;</span><br><span class="line">  v17[10] = 162;</span><br><span class="line">  v17[11] = 258;</span><br><span class="line">  v17[12] = 381;</span><br><span class="line">  v17[13] = 339;</span><br><span class="line">  v17[14] = 347;</span><br><span class="line">  v17[15] = 307;</span><br><span class="line">  v17[16] = 263;</span><br><span class="line">  v17[17] = 359;</span><br><span class="line">  v17[18] = 162;</span><br><span class="line">  v17[19] = 484;</span><br><span class="line">  v17[20] = 310;</span><br><span class="line">  v17[21] = 333;</span><br><span class="line">  v17[22] = 346;</span><br><span class="line">  v17[23] = 339;</span><br><span class="line">  v17[24] = 150;</span><br><span class="line">  v17[25] = 194;</span><br><span class="line">  v17[26] = 175;</span><br><span class="line">  v17[27] = 344;</span><br><span class="line">  v17[28] = 158;</span><br><span class="line">  v17[29] = 250;</span><br><span class="line">  v17[30] = 128;</span><br><span class="line">  v17[31] = 175;</span><br><span class="line">  v17[32] = 158;</span><br><span class="line">  v17[33] = 173;</span><br><span class="line">  v17[34] = 152;</span><br><span class="line">  v17[35] = 379;</span><br><span class="line">  v17[36] = 158;</span><br><span class="line">  v17[37] = 292;</span><br><span class="line">  v17[38] = 130;</span><br><span class="line">  v17[39] = 365;</span><br><span class="line">  v17[40] = 197;</span><br><span class="line">  v17[41] = 20;</span><br><span class="line">  v17[42] = 197;</span><br><span class="line">  v17[43] = 161;</span><br><span class="line">  v17[44] = 198;</span><br><span class="line">  v17[45] = 10;</span><br><span class="line">  v17[46] = 207;</span><br><span class="line">  v17[47] = 244;</span><br><span class="line">  v17[48] = 202;</span><br><span class="line">  v17[49] = 14;</span><br><span class="line">  v17[50] = 204;</span><br><span class="line">  v17[51] = 176;</span><br><span class="line">  v17[52] = 193;</span><br><span class="line">  v17[53] = 255;</span><br><span class="line">  v17[54] = 35;</span><br><span class="line">  v17[55] = 7;</span><br><span class="line">  v17[56] = 158;</span><br><span class="line">  v17[57] = 181;</span><br><span class="line">  v17[58] = 145;</span><br><span class="line">  v17[59] = 353;</span><br><span class="line">  v17[60] = 153;</span><br><span class="line">  v17[61] = 357;</span><br><span class="line">  v17[62] = 246;</span><br><span class="line">  v17[63] = 151;</span><br><span class="line">  sub_4110EB(&quot;Welcome to HZNUCTF!!!\n&quot;, v4);</span><br><span class="line">  sub_4110EB(&quot;Enter something: \n&quot;, v5);</span><br><span class="line">  sub_411037(&quot;%64s&quot;, (char)v29);</span><br><span class="line">  sub_411339(v29, v28);</span><br><span class="line">  sub_41128F(v28[0], v28[1], &amp;v23);</span><br><span class="line">  if ( (char)v23 == 53</span><br><span class="line">    &amp;&amp; SBYTE1(v23) == 50</span><br><span class="line">    &amp;&amp; SBYTE2(v23) == 54</span><br><span class="line">    &amp;&amp; SHIBYTE(v23) == 53</span><br><span class="line">    &amp;&amp; (char)v24 == 53</span><br><span class="line">    &amp;&amp; SBYTE1(v24) == 54</span><br><span class="line">    &amp;&amp; SBYTE2(v24) == 54</span><br><span class="line">    &amp;&amp; SHIBYTE(v24) == 53</span><br><span class="line">    &amp;&amp; (char)v25 == 53</span><br><span class="line">    &amp;&amp; SBYTE1(v25) == 50</span><br><span class="line">    &amp;&amp; SBYTE2(v25) == 54</span><br><span class="line">    &amp;&amp; SHIBYTE(v25) == 53</span><br><span class="line">    &amp;&amp; (char)v26 == 53</span><br><span class="line">    &amp;&amp; SBYTE1(v26) == 51</span><br><span class="line">    &amp;&amp; SBYTE2(v26) == 54</span><br><span class="line">    &amp;&amp; SHIBYTE(v26) == 53 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_4110EB(&quot;good_job!!!\n&quot;, v6);</span><br><span class="line">    sub_4110EB(&quot;So, Plz input the flag:\n&quot;, v7);</span><br><span class="line">    sub_411037(&quot;%73s&quot;, (char)&amp;v21);</span><br><span class="line">    strncpy_s(Destination, 0x41u, Source, 0x40u);</span><br><span class="line">    sub_41127B();</span><br><span class="line">    srand(Seed);</span><br><span class="line">    sub_41127B();</span><br><span class="line">    j_memset(v15, 0, 0x80u);</span><br><span class="line">    for ( i = 0; i &lt; 32; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        rand();</span><br><span class="line">        v1 = sub_41127B() % 32;</span><br><span class="line">        v13 = 1;</span><br><span class="line">        for ( j = 0; j &lt; i; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          if ( v15[j] == v1 )</span><br><span class="line">          &#123;</span><br><span class="line">            v13 = 0;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( !v13 );</span><br><span class="line">      v15[i] = v1;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(Destination, v15);  //换位</span><br><span class="line">    strcpy(v19, Destination);  //复制</span><br><span class="line">    int_key(&amp;v23, key);   //密钥生成</span><br><span class="line">    matrix_dot(&amp;matrix, v19, v18);   //矩阵乘法</span><br><span class="line">    v11 = 0;</span><br><span class="line">    for ( k = 0; k &lt; 8; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      for ( m = 0; m &lt; 8; ++m )</span><br><span class="line">      &#123;</span><br><span class="line">        *((_DWORD *)&amp;v18[2 * k] + m) ^= key[v11 % j_strlen(key)];  //异或</span><br><span class="line">        ++v11;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( sub_411078((int)v18, (int)v17) == 1 )  //比较</span><br><span class="line">      sub_4110EB(&quot;Congratulation!!!\n&quot;, v8);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    sub_4110EB(&quot;wrong_wrong!!!\n&quot;, v6);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_41120D(&amp;savedregs, &amp;dword_412D48, 0, v0);</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要逻辑就是输入经过换位、矩阵乘法、异或后于数据进行比较。从后往前逆向：</p>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或是与key进行的，需要先求出key的值。一开始定义了strcpy(key, “KeYkEy!!”);然后在int_key函数对key进行了修改，该函数传入的第一个参数v23在前面一个if语句中进行了判断，等于是直接将v23的值给出了。进去init_key函数看看修改过程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl sub_412110(char *s, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  int i; // [esp+D0h] [ebp-14h]</span><br><span class="line">  size_t v4; // [esp+DCh] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = j_strlen(s);</span><br><span class="line">  for ( i = 0; i &lt; (int)(v4 - 1); i += 2 )</span><br><span class="line">    *(_BYTE *)(a2 + i / 2) = (s[i + 1] - 48) | (16 * (s[i] - 48));</span><br><span class="line">  result = 8;</span><br><span class="line">  *(_BYTE *)(a2 + 8) = 0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段可以直接复制运行得到key，然后拿验证数据与密钥异或来解密:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char v23[]=&#123;53,50,54,53,53,54,54,53,53,50,54,53,53,51,54,53&#125;;</span><br><span class="line">	char key[10]=&quot;KeYkEy!!&quot;;</span><br><span class="line">	for(int i=0;i&lt;15;i+=2)&#123;</span><br><span class="line">		key[i/2]= (v23[i + 1] - 48) | (16 * (v23[i] - 48));</span><br><span class="line">	&#125;</span><br><span class="line">	key[8]=0;</span><br><span class="line">	int enc[64];</span><br><span class="line">	enc[0] = 376;</span><br><span class="line">  enc[1] = 356;</span><br><span class="line">  enc[2] = 169;</span><br><span class="line">  enc[3] = 501;</span><br><span class="line">  enc[4] = 277;</span><br><span class="line">  enc[5] = 329;</span><br><span class="line">  enc[6] = 139;</span><br><span class="line">  enc[7] = 342;</span><br><span class="line">  enc[8] = 380;</span><br><span class="line">  enc[9] = 365;</span><br><span class="line">  enc[10] = 162;</span><br><span class="line">  enc[11] = 258;</span><br><span class="line">  enc[12] = 381;</span><br><span class="line">  enc[13] = 339;</span><br><span class="line">  enc[14] = 347;</span><br><span class="line">  enc[15] = 307;</span><br><span class="line">  enc[16] = 263;</span><br><span class="line">  enc[17] = 359;</span><br><span class="line">  enc[18] = 162;</span><br><span class="line">  enc[19] = 484;</span><br><span class="line">  enc[20] = 310;</span><br><span class="line">  enc[21] = 333;</span><br><span class="line">  enc[22] = 346;</span><br><span class="line">  enc[23] = 339;</span><br><span class="line">  enc[24] = 150;</span><br><span class="line">  enc[25] = 194;</span><br><span class="line">  enc[26] = 175;</span><br><span class="line">  enc[27] = 344;</span><br><span class="line">  enc[28] = 158;</span><br><span class="line">  enc[29] = 250;</span><br><span class="line">  enc[30] = 128;</span><br><span class="line">  enc[31] = 175;</span><br><span class="line">  enc[32] = 158;</span><br><span class="line">  enc[33] = 173;</span><br><span class="line">  enc[34] = 152;</span><br><span class="line">  enc[35] = 379;</span><br><span class="line">  enc[36] = 158;</span><br><span class="line">  enc[37] = 292;</span><br><span class="line">  enc[38] = 130;</span><br><span class="line">  enc[39] = 365;</span><br><span class="line">  enc[40] = 197;</span><br><span class="line">  enc[41] = 20;</span><br><span class="line">  enc[42] = 197;</span><br><span class="line">  enc[43] = 161;</span><br><span class="line">  enc[44] = 198;</span><br><span class="line">  enc[45] = 10;</span><br><span class="line">  enc[46] = 207;</span><br><span class="line">  enc[47] = 244;</span><br><span class="line">  enc[48] = 202;</span><br><span class="line">  enc[49] = 14;</span><br><span class="line">  enc[50] = 204;</span><br><span class="line">  enc[51] = 176;</span><br><span class="line">  enc[52] = 193;</span><br><span class="line">  enc[53] = 255;</span><br><span class="line">  enc[54] = 35;</span><br><span class="line">  enc[55] = 7;</span><br><span class="line">  enc[56] = 158;</span><br><span class="line">  enc[57] = 181;</span><br><span class="line">  enc[58] = 145;</span><br><span class="line">  enc[59] = 353;</span><br><span class="line">  enc[60] = 153;</span><br><span class="line">  enc[61] = 357;</span><br><span class="line">  enc[62] = 246;</span><br><span class="line">  enc[63] = 151;</span><br><span class="line">  for(int i=0;i&lt;64;i++)&#123;</span><br><span class="line">	  enc[i]^=key[i%8];</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0;i&lt;8;i++)&#123;</span><br><span class="line">		printf(&quot;[&quot;);</span><br><span class="line">		for(int j=0;j&lt;8;j++)&#123;</span><br><span class="line">			printf(&quot;%d&quot;,enc[i*8+j]);</span><br><span class="line">			if(j!=7) printf(&quot;,&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;],\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//这里打印矩阵格式是为了后续矩阵解密更方便</span><br><span class="line">///[298,257,255,400,327,300,216,307],</span><br><span class="line">[302,264,244,359,303,310,264,342],</span><br><span class="line">[341,258,244,385,356,296,265,310],</span><br><span class="line">[196,167,249,317,204,159,211,202],</span><br><span class="line">[204,200,206,286,204,321,209,264],</span><br><span class="line">[151,113,147,196,148,111,156,145],</span><br><span class="line">[152,107,154,213,147,154,112,98],</span><br><span class="line">[204,208,199,260,203,256,165,242]///</span><br></pre></td></tr></table></figure>

<h3 id="矩阵逆向"><a href="#矩阵逆向" class="headerlink" title="矩阵逆向"></a>矩阵逆向</h3><p>源代码中是数据与矩阵matrix进行乘法得到上面的结果（设置为矩阵B），那么要得到数据，就需要将矩阵B与matrix的逆矩阵相乘。对matrix矩阵交叉引用可以追踪到TLS函数里面</p>
<img src="/posts/40555/image-20250418184949999.png" class="" title="image-20250418184949999">

<p>根据TLS函数，可以知道矩阵matrix的值。解密脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个方阵</span></span><br><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">A_inv = np.linalg.inv(A)  <span class="comment"># 计算逆矩阵</span></span><br><span class="line">A_int = A_inv.astype(<span class="built_in">int</span>)  <span class="comment"># 逆矩阵转化为整数矩阵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;逆矩阵:\n&quot;</span>, A_int)</span><br><span class="line">B = np.array([[<span class="number">298</span>,<span class="number">257</span>,<span class="number">255</span>,<span class="number">400</span>,<span class="number">327</span>,<span class="number">300</span>,<span class="number">216</span>,<span class="number">307</span>],</span><br><span class="line">            [<span class="number">302</span>,<span class="number">264</span>,<span class="number">244</span>,<span class="number">359</span>,<span class="number">303</span>,<span class="number">310</span>,<span class="number">264</span>,<span class="number">342</span>],</span><br><span class="line">            [<span class="number">341</span>,<span class="number">258</span>,<span class="number">244</span>,<span class="number">385</span>,<span class="number">356</span>,<span class="number">296</span>,<span class="number">265</span>,<span class="number">310</span>],</span><br><span class="line">            [<span class="number">196</span>,<span class="number">167</span>,<span class="number">249</span>,<span class="number">317</span>,<span class="number">204</span>,<span class="number">159</span>,<span class="number">211</span>,<span class="number">202</span>],</span><br><span class="line">            [<span class="number">204</span>,<span class="number">200</span>,<span class="number">206</span>,<span class="number">286</span>,<span class="number">204</span>,<span class="number">321</span>,<span class="number">209</span>,<span class="number">264</span>],</span><br><span class="line">            [<span class="number">151</span>,<span class="number">113</span>,<span class="number">147</span>,<span class="number">196</span>,<span class="number">148</span>,<span class="number">111</span>,<span class="number">156</span>,<span class="number">145</span>],</span><br><span class="line">            [<span class="number">152</span>,<span class="number">107</span>,<span class="number">154</span>,<span class="number">213</span>,<span class="number">147</span>,<span class="number">154</span>,<span class="number">112</span>,<span class="number">98</span>],</span><br><span class="line">            [<span class="number">204</span>,<span class="number">208</span>,<span class="number">199</span>,<span class="number">260</span>,<span class="number">203</span>,<span class="number">256</span>,<span class="number">165</span>,<span class="number">242</span>]])</span><br><span class="line">C = np.dot(A_int,B);  <span class="comment"># 求矩阵乘积</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵乘法:\n&quot;</span>, C)</span><br></pre></td></tr></table></figure>



<p>转换为字符就是fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-</p>
<h3 id="换位"><a href="#换位" class="headerlink" title="换位"></a>换位</h3><p>换位函数传入了两个参数，第一个是输入，第二个一个数组v15。这个v15由前面的循环生成</p>
<img src="/posts/40555/image-20250418190757983.png" class="" title="image-20250418190757983">

<p>这个循环ida反汇编似乎有点问题，去看看汇编代码就会发现，实际上sub_41127B函数实际上是一个检查栈平衡的函数，没有返回值(返回值不存在eax寄存器)，只有rand函数才会把返回值存到eax里面，所以这里实际上是v1&#x3D;rand()%32。</p>
<p>这一整个循环其实就是生成32个不重复的伪随机数，srand在TLS函数就已经种下，为2025。交换函数优化后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size_t __cdecl sub_413360(char *Str, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  size_t result; // eax</span><br><span class="line">  char v3; // [esp+D3h] [ebp-1Dh]</span><br><span class="line">  size_t i; // [esp+DCh] [ebp-14h]</span><br><span class="line">  size_t v5; // [esp+E8h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = 64;</span><br><span class="line">  for ( i = 0;i&lt;32 ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( a2[i] &gt;= 0 &amp;&amp; a2[i] &lt; 64 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = Str[i];</span><br><span class="line">      Str[i] = Str[64 - a2[i] - 1];</span><br><span class="line">      Str[64 - a2[i] - 1] = v3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解密:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> Str[],<span class="type">int</span> a2[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">31</span>;</span><br><span class="line">	<span class="type">char</span> v3;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		v3 = Str[i];</span><br><span class="line">      	Str[i] = Str[<span class="number">64</span> - a2[i] - <span class="number">1</span>];</span><br><span class="line">      	Str[<span class="number">64</span> - a2[i] - <span class="number">1</span>] = v3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,Str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> seed=<span class="number">2025</span>;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">32</span>];</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="type">int</span> zero=<span class="number">1</span>;</span><br><span class="line">	srand(seed);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			temp=rand()%<span class="number">32</span>;</span><br><span class="line">			zero=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">				<span class="keyword">if</span>(temp==a[j])&#123;</span><br><span class="line">					zero=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(zero==<span class="number">0</span>);</span><br><span class="line">		a[i]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> str[]=<span class="string">&quot;fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-&quot;</span>;</span><br><span class="line">	swap(str,a);</span><br><span class="line">&#125;#<span class="number">3</span>zfb899ac5c256d<span class="number">-7</span>a8r59f0tccd<span class="number">-4f</span>a6b8vfd111-a44ffy4r0<span class="number">-6</span>dce5679da58</span><br></pre></td></tr></table></figure>

<p>HZNUCTF{3zfb899ac5c256d-7a8r59f0tccd-4fa6b8vfd111-a44ffy4r0-6dce5679da58}</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode中文乱码问题解决</title>
    <url>/posts/27687/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>​	尝试了网上的很多方法，都有各种各样的问题，有将编码全改为utf-8的（缺点：外部运行时乱码，输入中文后输出为乱码），有将编码全改为gbk的（缺点：输入中文为乱码），有直接调用外部终端的（缺点：程序运行结束会直接关闭终端，导致看不到运行结果）。唯一一个貌似行得通的方法就是第三个，但是找了好久都没有让终端停下来的方法，最后在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/m0_73657663/article/details/134698209?ops_request_misc=%257B%2522request%255Fid%2522%253A%25229fea31e854124f56bd09f3e9533c4251%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=9fea31e854124f56bd09f3e9533c4251&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-5-134698209-null-null.nonecase&amp;utm_term=vscode&amp;spm=1018.2226.3001.4450</span><br></pre></td></tr></table></figure>

<p>这篇博客里面才知道可以将”type”改为”cppvsdbg”来使程序暂停。</p>
<h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><p>1、右下角文件编码改为gbk</p>
<p>2、tasks.json文件里面args加一个参数”-fexec-charset&#x3D;GBK”</p>
<p>3、launch.json文件里面改为：”type”: “cppvsdbg”，”externalConsole”: true改为”console”: “externalTerminal”</p>
<p>最后tasks.json：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;cppbuild&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;D:\\down\\mingw64\\bin\\g++.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-fdiagnostics-color=always&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">                &quot;-fexec-charset=GBK&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;detail&quot;: &quot;编译器: D:\\down\\mingw64\\bin\\g++.exe&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>launch.json文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;C/C++: g++.exe 终端运行&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppvsdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;console&quot;: &quot;externalTerminal&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>iscc</title>
    <url>/posts/40580/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="练武题"><a href="#练武题" class="headerlink" title="练武题"></a>练武题</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p>脱壳之后打开</p>
<img src="/posts/40580/image-20250501195702098.png" class="" title="image-20250501195702098">

<p>在比较函数处设置断点，动调得到flag</p>
<img src="/posts/40580/image-20250501195758440.png" class="" title="image-20250501195758440">

<h3 id="我爱看小品"><a href="#我爱看小品" class="headerlink" title="我爱看小品"></a>我爱看小品</h3><img src="/posts/40580/image-20250501202304564.png" class="" title="image-20250501202304564">

<p>python写的elf文件，使用pyinstxtractor.py脚本处理（注意，必须要在3.8的环境）</p>
<img src="/posts/40580/image-20250501202614840.png" class="" title="image-20250501202614840">

<p>使用pycdc反编译pyc文件：</p>
<img src="/posts/40580/image-20250501202730601.png" class="" title="image-20250501202730601">

<p>引用了mypy和yourpy两个库。去PYZ-00.pyz_extracted文件夹下找，没找到同名pyc文件，但是有.pyc.encrypted文件</p>
<p>。这种文件是加了密的pyc文件，加密密钥在pyimod00_crypto_key.pyc文件里面：</p>


<p>使用解密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import zlib, tinyaes</span><br><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line"># 配置参数</span><br><span class="line">CRYPT_BLOCK_SIZE = 16</span><br><span class="line">key = bytes(&#x27;yibaibayibei1801&#x27;, &#x27;utf-8&#x27;)  # 直接使用你的密钥</span><br><span class="line">input_file = Path(&quot;D:\\Re\\python逆向\\mypy.pyc.encrypted&quot;)   # 要运行两次脚本得到两个pyc文件</span><br><span class="line">output_file = input_file.with_suffix(&#x27;&#x27;)  # 输出路径为 mypy.pyc</span><br><span class="line"></span><br><span class="line"># 解密核心逻辑</span><br><span class="line">with open(input_file, &#x27;rb&#x27;) as inf, open(output_file, &#x27;wb&#x27;) as outf:</span><br><span class="line">    iv = inf.read(CRYPT_BLOCK_SIZE)  # 读取初始向量</span><br><span class="line">    cipher = tinyaes.AES(key, iv)</span><br><span class="line">    encrypted_data = inf.read()  # 读取加密数据</span><br><span class="line">    decrypted_data = cipher.CTR_xcrypt_buffer(encrypted_data)  # AES-CTR解密</span><br><span class="line">    plaintext = zlib.decompress(decrypted_data)  # 解压数据</span><br><span class="line">    </span><br><span class="line">    # 修复pyc文件头（需根据Python版本调整！）</span><br><span class="line">    # Python 3.8 示例：b&#x27;\x55\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0&#x27;</span><br><span class="line">    pyc_header = b&#x27;\x55\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0&#x27;  </span><br><span class="line">    outf.write(pyc_header + plaintext)</span><br><span class="line"></span><br><span class="line">print(f&quot;[+] 解密完成: &#123;output_file&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>得到两个.pyc文件</p>
<img src="/posts/40580/image-20250501203831664.png" class="" title="image-20250501203831664">

<p>分别反编译</p>
<p>mypy.pyc:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def myfun():</span><br><span class="line">    part1 = &#x27;ISCC&#123;&#x27;</span><br><span class="line">    part2 = &#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;</span><br><span class="line">    part3 = &#x27;&#125;&#x27;</span><br><span class="line">    tmp = &#x27;&#x27;</span><br><span class="line">    part2_1 = part2[:11]</span><br><span class="line">    part2_2 = part2[11:15]</span><br><span class="line">    part2_3 = part2[15:20]</span><br><span class="line">    part2_4 = part2[20:]</span><br><span class="line">    for i in range(len(part2_1)):</span><br><span class="line">        tmp += chr(ord(part2_1[i]) + 1)</span><br><span class="line">    for i in range(len(part2_2)):</span><br><span class="line">        if part2_2[i].isalpha():</span><br><span class="line">            tmp += chr(ord(part2_2[i]) ^ 32)</span><br><span class="line">            continue</span><br><span class="line">        tmp += chr(ord(part2_2[i]) + 0)</span><br><span class="line">    for i in range(len(part2_3)):</span><br><span class="line">        tmp += chr(ord(part2_3[i]) - 1)</span><br><span class="line">    for i in range(len(part2_4)):</span><br><span class="line">        tmp += chr(ord(part2_4[i]) + i % 2)</span><br><span class="line">    cipher = &#x27;qzjotubmmfs_IS_udqx^iotfrfsuiog&#x27;</span><br><span class="line">    true_flag = part1 + part2 + part3</span><br><span class="line">    print(time.strftime(&#x27;%Y-%m-%d %H:%M&#x27;, time.localtime(time.time())))</span><br><span class="line">    return true_flag</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    ss = myfun()</span><br><span class="line">    print(ss)</span><br></pre></td></tr></table></figure>

<p>yourpy.pyc:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def next():</span><br><span class="line">Unsupported opcode: BEGIN_FINALLY</span><br><span class="line">    useful = &#x27;\n\n                                                                                       ,---,\n                                                                                    ,`--.\&#x27; |\n  ,--,                            ,-.           ,---,                               |   :  :\n,--.\&#x27;|                        ,--/ /|         ,--.\&#x27; |                               \&#x27;   \&#x27;  ;\n|  | :     ,---.     ,---.  ,--. :/ |         |  |  :                __  ,-.        |   |  |\n:  : \&#x27;    \&#x27;   ,\&#x27;\\   \&#x27;   ,\&#x27;\\ :  : \&#x27; /          :  :  :              ,\&#x27; ,\&#x27;/ /|        \&#x27;   :  ;\n|  \&#x27; |   /   /   | /   /   ||  \&#x27;  /           :  |  |,--.   ,---.  \&#x27;  | |\&#x27; | ,---.  |   |  \&#x27;\n\&#x27;  | |  .   ; ,. :.   ; ,. :\&#x27;  |  :           |  :  \&#x27;   |  /     \\ |  |   ,\&#x27;/     \\ \&#x27;   :  |\n|  | :  \&#x27;   | |: :\&#x27;   | |: :|  |   \\          |  |   /\&#x27; : /    /  |\&#x27;  :  / /    /  |;   |  ;\n\&#x27;  : |__\&#x27;   | .; :\&#x27;   | .; :\&#x27;  : |. \\         \&#x27;  :  | | |.    \&#x27; / ||  | \&#x27; .    \&#x27; / |`---\&#x27;. |\n|  | \&#x27;.\&#x27;|   :    ||   :    ||  | \&#x27; \\ \\        |  |  \&#x27; | :\&#x27;   ;   /|;  : | \&#x27;   ;   /| `--..`;\n;  :    ;\\   \\  /  \\   \\  / \&#x27;  : |--\&#x27;         |  :  :_:,\&#x27;\&#x27;   |  / ||  , ; \&#x27;   |  / |.--,_\n|  ,   /  `----\&#x27;    `----\&#x27;  ;  |,\&#x27;            |  | ,\&#x27;    |   :    | ---\&#x27;  |   :    ||    |`.\n ---`-\&#x27;                     \&#x27;--\&#x27;              `--\&#x27;\&#x27;       \\   \\  /         \\   \\  / `-- -`, ;\n                                                           `----\&#x27;           `----\&#x27;    \&#x27;---`&quot;\n\n\n    \n&#x27;</span><br><span class="line">    tips = &#x27;Congratulations, you found the hidden tip!&#x27;</span><br><span class="line">    your_id = &#x27;TIPO&#x27; + str(len(tips)) + &#x27;PCDL&#x27;</span><br><span class="line"># WARNING: Decompyle incomplete</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    next()</span><br></pre></td></tr></table></figure>

<img src="/posts/40580/image-20250501204050505.png" class="" title="image-20250501204050505">

<p>flag和yourpy.pyc无关，只需要解mypy.pyc里面的加密就行，稍微改一下加密脚本就能实现解密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def myfun():</span><br><span class="line">    part1 = &#x27;ISCC&#123;&#x27;</span><br><span class="line">    part2 = &#x27;qzjotubmmfs_IS_udqx^iotfrfsuiog&#x27;</span><br><span class="line">    part3 = &#x27;&#125;&#x27;</span><br><span class="line">    tmp = &#x27;&#x27;</span><br><span class="line">    part2_1 = part2[:11]</span><br><span class="line">    part2_2 = part2[11:15]</span><br><span class="line">    part2_3 = part2[15:20]</span><br><span class="line">    part2_4 = part2[20:]</span><br><span class="line">    for i in range(len(part2_1)):</span><br><span class="line">        tmp += chr(ord(part2_1[i]) - 1)</span><br><span class="line">    for i in range(len(part2_2)):</span><br><span class="line">        if part2_2[i].isalpha():</span><br><span class="line">            tmp += chr(ord(part2_2[i]) ^ 32)</span><br><span class="line">            continue</span><br><span class="line">        tmp += chr(ord(part2_2[i]) + 0)</span><br><span class="line">    for i in range(len(part2_3)):</span><br><span class="line">        tmp += chr(ord(part2_3[i]) + 1)</span><br><span class="line">    for i in range(len(part2_4)):</span><br><span class="line">        tmp += chr(ord(part2_4[i]) - i % 2)</span><br><span class="line">    cipher = &#x27;qzjotubmmfs_IS_udqx^iotfrfsuiog&#x27;</span><br><span class="line">    true_flag = part1 + part2 + part3</span><br><span class="line">    print(time.strftime(&#x27;%Y-%m-%d %H:%M&#x27;, time.localtime(time.time())))</span><br><span class="line">    return tmp</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    ss = myfun()</span><br><span class="line">    print(ss)</span><br><span class="line"> //ISCC&#123;pyinstaller_is_very_interesting&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="书法大师"><a href="#书法大师" class="headerlink" title="书法大师"></a>书法大师</h3><p>使用binwalk提取图片：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -e attachment-5.jpg</span><br></pre></td></tr></table></figure>

<p>得到_attachment-5.jpg.extracted文件夹。里面有一个压缩包，需要密码。使用在线网站查看图片注释，得到解压密码：</p>
<img src="/posts/40580/image-20250502174522457.png" class="" title="image-20250502174522457">

<p>解压得到message45.txt文件，里面是乱码</p>
<img src="/posts/40580/image-20250502174725308.png" class="" title="image-20250502174725308">

<p>每两个汉字的笔划组成一个字节，比如“右女”笔划数分别为5和3，组成0x53（这里的O代表笔划为0），通过此方法得到：</p>
<p>SVNDQ3swVzdVTnpBZ0NofQ&#x3D;&#x3D;</p>
<p>解码</p>
<img src="/posts/40580/image-20250502182009921.png" class="" title="image-20250502182009921">

<h2 id="mobile-安卓"><a href="#mobile-安卓" class="headerlink" title="mobile(安卓)"></a>mobile(安卓)</h2><h3 id="三进制战争"><a href="#三进制战争" class="headerlink" title="三进制战争"></a>三进制战争</h3><p>使用frida hook得flag，注入代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">hook_code = &quot;&quot;&quot;</span><br><span class="line">Java.perform(function () &#123;</span><br><span class="line">    let MainActivity = Java.use(&quot;com.example.mobile02.MainActivity&quot;);</span><br><span class="line">    let flag1 = &#x27;&#x27;;</span><br><span class="line">    let key2 = &#x27;&#x27;;</span><br><span class="line">    let flag2_enc = &#x27;&#x27;;</span><br><span class="line">    let flag2 = &#x27;&#x27;;</span><br><span class="line">    var dictionary = [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">    let context;</span><br><span class="line">    </span><br><span class="line">    // ====================================================</span><br><span class="line">    // 1. 修复：正确保存原始方法引用</span><br><span class="line">    // ====================================================</span><br><span class="line">    // 获取原始方法引用（未 Hook 前）</span><br><span class="line">    const stringFromJNlMethod = MainActivity[&quot;stringFromJNl&quot;].overload(</span><br><span class="line">        &#x27;java.lang.String&#x27;,</span><br><span class="line">        &#x27;java.lang.String&#x27;</span><br><span class="line">    );</span><br><span class="line">    const stringFromJNlMethod_1 = MainActivity[&quot;stringFromJNI&quot;].overload(</span><br><span class="line">        &#x27;java.lang.String&#x27;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    // ====================================================</span><br><span class="line">    // 2. Hook CHECK1 修改输入</span><br><span class="line">    // ====================================================</span><br><span class="line">    MainActivity[&quot;CHECK1&quot;].overload(&#x27;java.lang.String&#x27;).implementation = function (str) &#123;</span><br><span class="line">        console.log(`[CHECK1] Original input: $&#123;str&#125;`);</span><br><span class="line">        let fakeStr = &quot;ISCC&#123;BBBBBBBBBB&#125;&quot;; // 长度=5+10+1=16 &gt;13</span><br><span class="line">        </span><br><span class="line">        if (str.startsWith(&quot;ISCC&#123;&quot;) &amp;&amp; str.endsWith(&quot;&#125;&quot;)) &#123;</span><br><span class="line">            fakeStr = str;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        context = this;</span><br><span class="line">        console.log(`[CHECK1] Modified input: $&#123;fakeStr&#125;`);</span><br><span class="line">        this[&quot;CHECK2&quot;].call(this, fakeStr);</span><br><span class="line">        return this[&quot;CHECK1&quot;](fakeStr);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // ====================================================</span><br><span class="line">    // 3. Hook stringFromJNl 并调用原始方法</span><br><span class="line">    // ====================================================</span><br><span class="line">    stringFromJNlMethod.implementation = function (key, input) &#123;</span><br><span class="line">        console.log(`\\n===== Hooked stringFromJNl: key=$&#123;key&#125;, input=$&#123;input&#125; =====`);</span><br><span class="line">        if (key.length == 32) &#123;</span><br><span class="line">            key2 = key;</span><br><span class="line">        &#125;</span><br><span class="line">        return stringFromJNlMethod.call(this, key, input);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    stringFromJNlMethod_1.implementation = function (key) &#123;</span><br><span class="line">        flag1 = stringFromJNlMethod_1.call(this, key);</span><br><span class="line">        console.log(`flag1: $&#123;flag1&#125;`);</span><br><span class="line">        return flag1;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    let Intrinsics = Java.use(&quot;kotlin.jvm.internal.Intrinsics&quot;);</span><br><span class="line">    Intrinsics[&quot;areEqual&quot;].overload(&#x27;java.lang.Object&#x27;, &#x27;java.lang.Object&#x27;).implementation = </span><br><span class="line">        function (obj, obj2) &#123;</span><br><span class="line">            console.log(`[areEqual] Comparing: $&#123;obj&#125; vs $&#123;obj2&#125;`);</span><br><span class="line">            </span><br><span class="line">            if (String(obj2).length == 36) &#123;</span><br><span class="line">                flag2_enc = String(obj2);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            const visibleChars = [];</span><br><span class="line">            </span><br><span class="line">            if (key2.length == 32 &amp;&amp; flag2_enc.length == 36) &#123;</span><br><span class="line">                for (let i = 0x20; i &lt;= 0x7e; i++) &#123;</span><br><span class="line">                    visibleChars.push(String.fromCharCode(i));</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                visibleChars.forEach(char =&gt; &#123;</span><br><span class="line">                    const inputStr = char.repeat(6);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        const result = stringFromJNlMethod.call(context, key2, inputStr);</span><br><span class="line">                        console.log(result);</span><br><span class="line">                        </span><br><span class="line">                        for (let i = 0; i &lt; 6; i += 1) &#123;</span><br><span class="line">                            dictionary[i][result.substring(i * 6, (i + 1) * 6)] = inputStr.at(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        console.log(`输入 &#x27;$&#123;inputStr&#125;&#x27; 加密失败: $&#123;e&#125;`);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">                for (let i = 0; i &lt; 6; i += 1) &#123;</span><br><span class="line">                    flag2 += dictionary[i][flag2_enc.substring(i * 6, (i + 1) * 6)];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                console.log(`flag2: $&#123;flag2&#125;`);</span><br><span class="line">                console.log(`flag: ISCC&#123;$&#123;flag1 + flag2&#125;&#125;`);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return this[&quot;areEqual&quot;](obj, obj2);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_message(msg, data):</span><br><span class="line">    if msg[&quot;type&quot;] == &#x27;send&#x27;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(msg[&#x27;payload&#x27;]))</span><br><span class="line">    else:</span><br><span class="line">        print(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    device = frida.get_usb_device()</span><br><span class="line">    pid = device.spawn([&quot;com.example.mobile02&quot;])</span><br><span class="line">    session = device.attach(pid)</span><br><span class="line">    script = session.create_script(hook_code)</span><br><span class="line">    script.on(&quot;message&quot;, handle_message)</span><br><span class="line">    script.load()</span><br><span class="line">    device.resume(pid)</span><br><span class="line">    sys.stdin.read()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(f&quot;Error: &#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>注入流程：</p>
<p>先打开模拟器</p>
<p>然后电脑开启终端，依次输入以下指令来运行模拟器里面的frida_server：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cd data/local/tmp</span><br><span class="line">./f16</span><br></pre></td></tr></table></figure>

<img src="/posts/40580/image-20250507123646619.png" class="" title="image-20250507123646619">

<p>模拟器安装题目的apk文件，运行</p>
<p>电脑运行脚本</p>
<p>模拟器点击特定事件（比如submit)</p>
<p>在终端上观察</p>
<img src="/posts/40580/image-20250507124104236.png" class="" title="image-20250507124104236">
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/posts/10764/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>不使用结构体来创建完全二叉树:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">uint64_t *creat_re(char *s,int index)&#123;  // 递归方式创建完全二叉树</span><br><span class="line">	if(index&gt;=strlen(s)) return NULL;</span><br><span class="line">	uint64_t *temp=(uint64_t *)malloc(24);</span><br><span class="line">	if (temp == NULL) &#123;</span><br><span class="line">        fprintf(stderr, &quot;Memory allocation failed!\n&quot;);</span><br><span class="line">        exit(1);  // 如果分配失败，退出程序</span><br><span class="line">    &#125;</span><br><span class="line">	*(char *)temp=s[index];</span><br><span class="line">	temp[1]=(uint64_t)creat_re(s,index*2+1);</span><br><span class="line">	temp[2]=(uint64_t)creat_re(s,index*2+2);</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">uint64_t *newnode(char c)&#123;  // 非递归方式创建完全二叉树的单个结点</span><br><span class="line">	uint64_t *temp=(uint64_t *)malloc(24);</span><br><span class="line">	*(char *)temp=c;</span><br><span class="line">	temp[1]=temp[2]=0;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">uint64_t *create(char *s)&#123;  // 非递归方式创建完全二叉树</span><br><span class="line">	uint64_t *list[100];</span><br><span class="line">	uint64_t *temp;</span><br><span class="line">	int len=strlen(s);</span><br><span class="line">	int i=1,j=1,k=0;</span><br><span class="line">	list[0]=newnode(s[0]);</span><br><span class="line">	while(i&lt;len)&#123;</span><br><span class="line">		temp=list[k++];</span><br><span class="line">		temp[1]=(uint64_t)newnode(s[i++]);</span><br><span class="line">		list[j++]=(uint64_t *)temp[1];</span><br><span class="line">		if(i&gt;=len) break;</span><br><span class="line">		temp[2]=(uint64_t)newnode(s[i++]);</span><br><span class="line">		list[j++]=(uint64_t *)temp[2];</span><br><span class="line">	&#125;</span><br><span class="line">	return list[0];</span><br><span class="line">&#125;</span><br><span class="line">void pre_travel(uint64_t *n)&#123;  // 前序遍历</span><br><span class="line">	if(n==NULL) return;</span><br><span class="line">	printf(&quot;%c&quot;,*(char *)n);</span><br><span class="line">	pre_travel((uint64_t *)n[1]);</span><br><span class="line">	pre_travel((uint64_t *)n[2]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char s[]=&quot;1234567&quot;;</span><br><span class="line">	int i;</span><br><span class="line">	uint64_t *temp;</span><br><span class="line">	// temp=creat_re(s,0);</span><br><span class="line">	temp=create(s);</span><br><span class="line">	pre_travel(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于中序遍历和后序遍历序列还原完全二叉树结构，输出层次遍历序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define num 26</span><br><span class="line">char mid[] = &quot;ja7Cws_A3daTd4qDo8&#125;F_Sd&#123;a&quot;;</span><br><span class="line">char post[] = &quot;j7aw_sC3addq4TAo&#125;8_Fda&#123;SD&quot;;</span><br><span class="line">// 目标：给出中序遍历和后序遍历序列，求出完全二叉树结构（打印出层次遍历序列）</span><br><span class="line">typedef struct tree</span><br><span class="line">&#123;</span><br><span class="line">	char c;</span><br><span class="line">	struct tree *left,*right;</span><br><span class="line">&#125;tree;</span><br><span class="line">tree *creat(int ms,int me,int ps,int pe)&#123;   // 反推树的结构</span><br><span class="line">	if(ms&gt;me||ps&gt;pe) return NULL;</span><br><span class="line">	tree *t=(tree  *)malloc(sizeof(tree));</span><br><span class="line">	char charAt=post[pe];</span><br><span class="line">	int i;</span><br><span class="line">	for(i=ms;i&lt;=me&amp;&amp;mid[i]!=charAt;i++) &#123;&#125;</span><br><span class="line">	t-&gt;c=charAt;</span><br><span class="line">	t-&gt;left=creat(ms,i-1,ps, ps + i - ms - 1);</span><br><span class="line">	t-&gt;right=creat(i+1,me, ps + i - ms,pe-1);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">void pre_travel(tree *t)&#123;    // 前序遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	printf(&quot;%c&quot;,t-&gt;c);</span><br><span class="line">	pre_travel(t-&gt;left);</span><br><span class="line">	pre_travel(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">// 层次遍历</span><br><span class="line">typedef struct q&#123;  // 创建队列</span><br><span class="line">	tree *c[num];</span><br><span class="line">	int r,f;</span><br><span class="line">&#125;queue;</span><br><span class="line">void init(queue *q)&#123;   //初始化队列</span><br><span class="line">	q-&gt;r=q-&gt;f=0;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q,tree *t) &#123; // 入队</span><br><span class="line">	if((q-&gt;f+1)%num==q-&gt;r) &#123;printf(&quot;队满！\n&quot;);return;&#125;</span><br><span class="line">	q-&gt;c[q-&gt;f]=t;</span><br><span class="line">	q-&gt;f=(q-&gt;f+1)%num;</span><br><span class="line">&#125;</span><br><span class="line">tree *dequeue(queue *q) &#123;  // 出队</span><br><span class="line">	if(q-&gt;f==q-&gt;r) &#123;printf(&quot;队空！\n&quot;);return NULL;&#125;</span><br><span class="line">	tree *temp=q-&gt;c[q-&gt;r];</span><br><span class="line">	q-&gt;r=(q-&gt;r+1)%num;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void level_travel(tree *t)&#123;  //  层次遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	queue *q=(queue *)malloc(sizeof(queue));</span><br><span class="line">	tree *temp;</span><br><span class="line">	init(q);</span><br><span class="line">	enqueue(q,t);</span><br><span class="line">	while(q-&gt;f!=q-&gt;r)&#123;</span><br><span class="line">		temp=dequeue(q);</span><br><span class="line">		printf(&quot;%c&quot;,temp-&gt;c);</span><br><span class="line">		if(temp-&gt;left!=NULL) enqueue(q,temp-&gt;left);</span><br><span class="line">		if(temp-&gt;right!=NULL) enqueue(q,temp-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	free(q);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	tree *t=creat(0,strlen(mid)-1,0,strlen(post)-1);</span><br><span class="line">	// pre_travel(t);</span><br><span class="line">	level_travel(t);</span><br><span class="line">&#125;</span><br><span class="line">//层次遍历结果: DASCTF&#123;asd48_daj7w_3adqo&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用过程</title>
    <url>/posts/24481/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int add(int a,int b)&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    x=a,y=b;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a=1,b=2;</span><br><span class="line">    printf(&quot;%d&quot;,add(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来放入x32dbg里面调试，看到：</p>
<img src="/posts/24481/image-20241204220215454.png" class="" title="image-20241204220215454">

<p>先从main函数开始看。</p>
<p>创建新的堆栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure>

<p>先把主函数堆栈中的ebp指针压入栈，在将主函数中的esp赋值给ebp经过这样的操作，会在原先的堆栈上新建一个堆栈供被调函数用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub esp,20</span><br></pre></td></tr></table></figure>

<p>为变量开辟0x20字节的新空间</p>
<img src="/posts/24481/image-20241204222756002.png" class="" title="image-20241204222756002">

<p>变量赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dword ptr ss:[esp+1C],1             //a=1</span><br><span class="line">mov dword ptr ss:[esp+18],2             //b=2</span><br></pre></td></tr></table></figure>

<p>接下来时函数调用。调用过程主要分两部分：1、主函数部分。2、被调函数部分。</p>
<h1 id="主函数部分："><a href="#主函数部分：" class="headerlink" title="主函数部分："></a>主函数部分：</h1><h2 id="1、参数压入栈"><a href="#1、参数压入栈" class="headerlink" title="1、参数压入栈"></a>1、参数压入栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040153A | 8B4424 18                  | mov eax,dword ptr ss:[esp+18]           |b-&gt;eax</span><br><span class="line">0040153E | 894424 04                  | mov dword ptr ss:[esp+4],eax            |eax-&gt;[esp+4]</span><br><span class="line">00401542 | 8B4424 1C                  | mov eax,dword ptr ss:[esp+1C]           |a-&gt;eax</span><br><span class="line">00401546 | 890424                     | mov dword ptr ss:[esp],eax              |eax-&gt;[esp]</span><br></pre></td></tr></table></figure>



<p>注意到压入栈的顺序与参数顺序是相反的，调用时add(a,b)，但是b先入栈，a后入。</p>
<h2 id="2、调用函数"><a href="#2、调用函数" class="headerlink" title="2、调用函数"></a>2、调用函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401549 | E8 B2FFFFFF                | call &lt;test.add&gt;                         |</span><br></pre></td></tr></table></figure>

<p>在执行call语句时，ESP发生了改变</p>
<img src="/posts/24481/image-20241204225304838.png" class="" title="image-20241204225304838">

<p>是将0x40154E压入了栈，而这正是00401549+5，即call指令的下一条指令。</p>
<p>所以实际上在执行“call &lt;test.add&gt; ”时，可以拆解为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x40154E</span><br><span class="line">jmp  0x401500</span><br></pre></td></tr></table></figure>

<h1 id="被调函数部分："><a href="#被调函数部分：" class="headerlink" title="被调函数部分："></a>被调函数部分：</h1><h2 id="1、创建新堆栈"><a href="#1、创建新堆栈" class="headerlink" title="1、创建新堆栈"></a>1、创建新堆栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401500 | 55                         | push ebp                                |</span><br><span class="line">00401501 | 89E5                       | mov ebp,esp                             |</span><br></pre></td></tr></table></figure>

<p>先将原栈底入栈，在将新栈底设置为原栈顶，即：</p>


<p>这个时候ESP和EBP都在0x61FE78处，再执行压栈出栈也不会影响到主函数堆栈</p>
<h2 id="2、为参数预留空间"><a href="#2、为参数预留空间" class="headerlink" title="2、为参数预留空间"></a>2、为参数预留空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401503 | 83EC 10                    | sub esp,10                       //空出0x10字节的空间</span><br></pre></td></tr></table></figure>

<h2 id="3、取出形参"><a href="#3、取出形参" class="headerlink" title="3、取出形参"></a>3、取出形参</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00401506 | 8B45 08                    | mov eax,dword ptr ss:[ebp+8]            |</span><br><span class="line">00401509 | 8945 FC                    | mov dword ptr ss:[ebp-4],eax            | </span><br><span class="line">0040150C | 8B45 0C                    | mov eax,dword ptr ss:[ebp+C]            |</span><br><span class="line">0040150F | 8945 F8                    | mov dword ptr ss:[ebp-8],eax            |</span><br></pre></td></tr></table></figure>

<p>这里的[EBP+8]处是main函数压入的第二个参数（即1），[EBP+C]是main函数压入的第一个参数（即2）</p>
<img src="/posts/24481/image-20241204231114451.png" class="" title="image-20241204231114451">

<h2 id="4、返回值"><a href="#4、返回值" class="headerlink" title="4、返回值"></a>4、返回值</h2><p>在大多数情况，函数的返回值并不是压入栈，而是存储在寄存器eax之中</p>
<h2 id="5、函数结束"><a href="#5、函数结束" class="headerlink" title="5、函数结束"></a>5、函数结束</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040151A | C9                         | leave                                   |</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>

<p>ESP和EBP都调回了跳转前的位置。然后接下来还要返回main函数里面，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0040151B | C3                         | ret                                     |</span><br></pre></td></tr></table></figure>

<p>在执行ret或retn时，等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure>

<p>先将之前存储的下一条指令的地址弹出到rip之中，指示 CPU 下一条指令应该从哪里开始执行，然后就会回到main函数里面（rip里的位置）</p>
<p><strong><u>经历了上面两步，ESP和EBP会回到调用函数前的位置，这就是堆栈平衡。</u></strong></p>
<h1 id="堆栈平衡与手动脱壳："><a href="#堆栈平衡与手动脱壳：" class="headerlink" title="堆栈平衡与手动脱壳："></a>堆栈平衡与手动脱壳：</h1><p>加壳原理其实与SMC自修改代码有相同之处，加壳其实就是对可执行文件进行压缩或加密，并在程序里面加入解压或解密的必要代码的过程。当程序运行起来时，壳会加载并执行一个解包过程，最终将原始代码加载到内存中并跳转到入口点开始正常执行。这类似于函数调用，于是脱壳的关键就是找到壳解包完成的时机，然后dump下来。在调用壳解包的代码时，满足函数调用的堆栈平衡定理（ESP定理），于是我们可以观察其ESP和EBP的位置，当壳解包完成时，ESP指针会回到执行解密程序之前的值，程序执行一个大的跳转跳到程序入口点(EP点），此时dump下来就可以得到脱壳后的可执行文件。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>古剑山2024wp</title>
    <url>/posts/26315/</url>
    <content><![CDATA[<h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><img src="/posts/26315/image-20241223224830088.png" class="" title="image-20241223224830088">

<p>有壳，显示vmp壳，也无法判断是不是其他壳魔改的，于是直接使用ESP定律手动脱壳。</p>
<img src="/posts/26315/image-20241223224948607.png" class="" title="image-20241223224948607">

<p>这个壳与其他的有一点不一样，上面这段汇编都是没用的，压入后立马又弹出，并没用实际压入参数，所以是混淆视听的。要等到下面那个jmp re.c9970才是壳的开始。我们单步直到它跳转:</p>
<img src="/posts/26315/image-20241223225312656.png" class="" title="image-20241223225312656">

<p>接下来就是正常的脱壳了。</p>
<img src="/posts/26315/image-20241223225911496.png" class="" title="image-20241223225911496">

<p>修复的时候有一个地方修复不了，这个地方要手动用ida修复。</p>
<img src="/posts/26315/image-20241223230212596.png" class="" title="image-20241223230212596">

<p>这里函数提前结束了，看这里的汇编指令就知道这个是垃圾代码，花指令，全部nop掉这三行，再重新分析即可</p>
<img src="/posts/26315/image-20241223230500326.png" class="" title="image-20241223230500326">

<p>反编译</p>
<img src="/posts/26315/image-20250120000614004.png" class="" title="image-20250120000614004">

<p>图中27-28这个循环是将输入存入数组v8中，然后调用sub_131150进行判断。</p>
<img src="/posts/26315/image-20250120000324099.png" class="" title="image-20250120000324099">

<p>这个函数传入了两个参数，但是看不出来是哪两个参数，于是采用动态法</p>
<img src="/posts/26315/image-20250120000428243.png" class="" title="image-20250120000428243">

<p>发现a1对应的是v8,a2对应的是v7</p>
<img src="/posts/26315/image-20250120000804414.png" class="" title="image-20250120000804414">

<p>第15行就是将v7[25]的地址赋值给v2，v7是“cedfz16az31zd2dycy65ac41flag”，v7[25]即是”f”。开始将v8的前四个字符与v7的25-28处的字符进行对比，即得到v8（也就是flag）前4位是”flag”。下面26-42是对byte_135018进行变换（’y’变为’7’，’z’变为’8’）然后将v8[5]开始的8个字符与byte_135018进行对比，至此得到：”flag{de21c847”</p>
<img src="/posts/26315/image-20250120001457692.png" class="" title="image-20250120001457692">

<p>下面的43-64是将v8[13]后面的字符与v7变换后（y变7，z变8）的前24个字符进行比较，因此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;de21c847cedf816a8318d2d7c765ac41&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>国城杯wp</title>
    <url>/posts/8147/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="Crush’s-secret"><a href="#Crush’s-secret" class="headerlink" title="Crush’s secret"></a>Crush’s secret</h2><p>有SMC，动调</p>
<img src="/posts/8147/image-20241207135656066.png" class="" title="image-20241207135656066">

<p>把它的主要逻辑简化一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void encode(unsigned int *a1, int a2,unsigned int* a3)   </span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int v4; // edx</span><br><span class="line">  int v5; // edx</span><br><span class="line">  int v7; // [esp+D4h] [ebp-44h]</span><br><span class="line">  int v8; // [esp+E0h] [ebp-38h]</span><br><span class="line">  unsigned int i; // [esp+ECh] [ebp-2Ch]</span><br><span class="line">  unsigned int v10; // [esp+F8h] [ebp-20h]</span><br><span class="line">  unsigned int v11; // [esp+104h] [ebp-14h]</span><br><span class="line"></span><br><span class="line">    v8 = 32;</span><br><span class="line">    v10 = 0;</span><br><span class="line">    do   //32次循环</span><br><span class="line">    &#123;</span><br><span class="line">      v10 -= 0x61C88647;</span><br><span class="line">      v7 = (v10 &gt;&gt; 2) &amp; 3;</span><br><span class="line">      a1[0] += (((a1[1] ^ a3[v7 ^ 0 &amp; 3]) + (a1[1] ^ v10)) ^ (((16 * a1[1]) ^ (a1[1] &gt;&gt; 3))+ ((4 *a1[1]) ^ (a1[1] &gt;&gt; 5))));</span><br><span class="line">      a1[1] += (((a1[0] ^ a3[v7 ^ 1 &amp; 3]) + (a1[0] ^ v10)) ^ (((16 * a1[0]) ^ (a1[0] &gt;&gt; 3))+ ((4 *a1[0]) ^ (a1[0] &gt;&gt; 5))));</span><br><span class="line">      --v8;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v8 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是密文</p>
<img src="/posts/8147/image-20241207135840979.png" class="" title="image-20241207135840979">

<p>这是密钥：</p>
<img src="/posts/8147/image-20241207140402515.png" class="" title="image-20241207140402515">

<p>写脚本解密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void decode(unsigned int *a1, int a2,unsigned int* a3)   //a1=data,a3=key</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int v4; // edx</span><br><span class="line">  int v5; // edx</span><br><span class="line">  int v7; // [esp+D4h] [ebp-44h]</span><br><span class="line">  int v8; // [esp+E0h] [ebp-38h]</span><br><span class="line">  unsigned int i; // [esp+ECh] [ebp-2Ch]</span><br><span class="line">  unsigned int v10; // [esp+F8h] [ebp-20h]</span><br><span class="line">  unsigned int v11; // [esp+104h] [ebp-14h]</span><br><span class="line"></span><br><span class="line">    v8 = 32;</span><br><span class="line">    v10 = 0;</span><br><span class="line">    do   //32次循环</span><br><span class="line">    &#123;</span><br><span class="line">      v10 -= 0x61C88647;</span><br><span class="line">      v7 = (v10 &gt;&gt; 2) &amp; 3;</span><br><span class="line">      a1[0] += (((a1[1] ^ a3[v7 ^ 0 &amp; 3]) + (a1[1] ^ v10)) ^ (((16 * a1[1]) ^ (a1[1] &gt;&gt; 3))+ ((4 *a1[1]) ^ (a1[1] &gt;&gt; 5))));</span><br><span class="line">      a1[1] += (((a1[0] ^ a3[v7 ^ 1 &amp; 3]) + (a1[0] ^ v10)) ^ (((16 * a1[0]) ^ (a1[0] &gt;&gt; 3))+ ((4 *a1[0]) ^ (a1[0] &gt;&gt; 5))));</span><br><span class="line">      --v8;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v8 );</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned int data[]=&#123;0xf31419a2,0x2f193025,0x6e995655,0x75d355fe,0x42e6b4e8,0xf97e03e,0x9f4676d0,0x2488d889,0x8e5cf3d7,0x18c58297,0x2652c22c,0x912ccd2b&#125;;</span><br><span class="line">    unsigned int key[]=&#123;0x5201314,0x52013140,0x5201314,0x52013140&#125;;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;6;i++)&#123;</span><br><span class="line">        decode(&amp;data[i*2],2,key);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;12;i++)&#123;</span><br><span class="line">        printf(&quot;%#x,&quot;,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  //D0g3xGC&#123;The_wind_stops_at_autumn_water_and_I_stop_at_you&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/8147/image-20241207140839246.png" class="" title="image-20241207140839246">

<h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><p>安卓题，前面半段是魔改的base64加密，解密出来的结果是round_and</p>
<p>后面半段只能用爆破法来解。但是它前一个字符加密的结果会影响到下一个加密，所以必须采用逐个破解法。</p>
<p>本来一开始想各种方法出了前几个字符”_rounD“，但是后面的可能性太多了，没办法一个一个试，于是想用12个循环来暴力破解（）。</p>
<p>12个字符，每个字符有127种可能，就是127的12次方，上亿种可能了，再加上每一种情况都要调用round函数进行判断，结果很明显，代码写出来了但是运行不出结果。在尝试很多方法后无功而反。</p>
<p>最后，在看了其他师傅wp后才搞清楚怎么写爆破脚本。</p>
<p>这是其他师傅的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def makebox(s):                             # 构建数组盒</span><br><span class="line">    iArr = [1023 - i for i in range(1024)]</span><br><span class="line">    for i in range(1024):</span><br><span class="line">        iArr[i] = iArr[i] ^ ord(s[i % 12])</span><br><span class="line">    return iArr</span><br><span class="line"></span><br><span class="line">box = makebox(&quot;c9m1bRmfY5Wk&quot;)</span><br><span class="line"></span><br><span class="line">def round(iArr, str):                   # 加密函数</span><br><span class="line">    length = len(str)</span><br><span class="line">    iArr2 = [0 for _ in range(length)]</span><br><span class="line">    iArr3 = [352, 646, 752, 882, 65, 0, 122, 0, 0, 7, 350, 360]</span><br><span class="line">    i = 33</span><br><span class="line">    for i2 in range(0, length):</span><br><span class="line">        charAt = ord(str[i2])</span><br><span class="line">        for _ in range(0, 32):</span><br><span class="line">            i4 = (iArr[i] ^ charAt) % 5</span><br><span class="line">            if i4 == 0:</span><br><span class="line">                charAt = (charAt + iArr[i]) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 1:</span><br><span class="line">                charAt = ((charAt - iArr[i]) % 1024 + 1024) % 1024  # 确保结果非负</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 2:</span><br><span class="line">                charAt = (charAt ^ iArr[i]) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 3:</span><br><span class="line">                charAt = (charAt &gt;&gt; 3) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">            elif i4 == 4:</span><br><span class="line">                charAt = (charAt &lt;&lt; 3) % 1024</span><br><span class="line">                i = (i + charAt) % 1024</span><br><span class="line">        iArr2[i2] = charAt</span><br><span class="line">    return iArr2</span><br><span class="line"></span><br><span class="line">import string</span><br><span class="line">dic = string.ascii_letters + &#x27;_&#x27;            # 创建一个由大小写字母和下划线组成的字典，字符串元素由这里取</span><br><span class="line"></span><br><span class="line">iArr3 = [352, 646, 752, 882, 65, 0, 122, 0, 0, 7, 350, 360]</span><br><span class="line"></span><br><span class="line"># 使用缓存来存储中间结果</span><br><span class="line">cache = &#123;&#125;      # 字典，用来排除已经尝试过的字符串</span><br><span class="line"></span><br><span class="line">def dfs(idx, ans):          # 关键递归函数</span><br><span class="line">    if idx == len(iArr3):       # 长度达到指定值则代表找到了符合条件的</span><br><span class="line">        print(ans)  # 找到符合条件的字符串</span><br><span class="line">        return True</span><br><span class="line">    for i in dic:         #在字符数组里面找字符</span><br><span class="line">        new_ans = ans + i      # 这里一定要用一个新的字符串来承接，因为后面的步骤可能会改变字符串</span><br><span class="line">        if new_ans not in cache:     # 判断是否是尝试过的字符串</span><br><span class="line">            cache[new_ans] = round(box, new_ans)    # 没尝试过则加入字典</span><br><span class="line">        res = cache[new_ans]        # 取出经过加密后的字符串</span><br><span class="line">        if res[-1] == iArr3[idx]:       # 如果相同则继续判断下一位</span><br><span class="line">            if dfs(idx + 1, new_ans):</span><br><span class="line">                return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">if not dfs(0, &#x27;&#x27;):</span><br><span class="line">    print(&quot;No solution found&quot;)</span><br></pre></td></tr></table></figure>

<p>他是利用了虽然前一个字符会影响后一个字符，但是后一个字符不会影响前一个字符这一特点（因为在对每个字符进行加密时，i的值会不断变化），这里使用了DFS算法，递归调用，比我之前12个循环好在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、代码简短，易理解</span><br><span class="line">2、进行了剪枝，提前排除不可能满足条件的字符串</span><br></pre></td></tr></table></figure>

<p>于是他的这段代码可以在几秒内快速运行出一个结果“_rounD_we_go”。</p>
<p>在理解了这位师傅脚本的主要逻辑后，我自己写了一个脚本，主要方法还是一样的，只不过稍微修改，让他把所有结果都运行出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int data[]=&#123;352, 646, 752, 882, 65, 0, 122, 0, 0, 7, 350, 360&#125;;</span><br><span class="line">int arr[1024];char flag[13]=&quot;&quot;;</span><br><span class="line">void makebox(char *s)&#123;</span><br><span class="line">    int  i;</span><br><span class="line">    for(i=0;i&lt;1024;i++)&#123;</span><br><span class="line">      arr[i]=1023-i;</span><br><span class="line">      arr[i]^=s[i%12];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">char *Round(int *result,char *s,int len)&#123;</span><br><span class="line">    int a=33;</span><br><span class="line">    int i2,i3,i4,num2,j;</span><br><span class="line">    int at;int i;int num,rip;</span><br><span class="line">    for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">        at=s[i];</span><br><span class="line">        for(i3=0;i3&lt;32;i3++)&#123;</span><br><span class="line">            i4=((arr[a]^at)%5+5)%5;</span><br><span class="line">            if(i4==0) &#123;num=(at+arr[a])%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==1) &#123;num=((at-arr[a])%1024+1024)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==2) &#123;num=((at^arr[a])%1024+1024)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==3) &#123;num=(at&gt;&gt;3)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            if(i4==4) &#123;num=(at&lt;&lt;3)%1024;rip=(a+num)%1024;&#125;</span><br><span class="line">            at=num;a=rip;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i]=at;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">void DSF(int len)&#123;</span><br><span class="line">    if(len==12)&#123;printf(&quot;%s\n&quot;,flag);return;&#125;</span><br><span class="line">    int i;char temp[13];</span><br><span class="line">    int result[13];</span><br><span class="line">    for(i=33;i&lt;127;i++)&#123;</span><br><span class="line">        strcpy(temp,flag);</span><br><span class="line">        temp[len]=(char)i;</span><br><span class="line">        Round(result,temp,len+1);</span><br><span class="line">        if(result[len]==data[len]) &#123;flag[len]=(char)i;DSF(len+1);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char s[]=&quot;c9m1bRmfY5Wk&quot;;</span><br><span class="line">    makebox(s);</span><br><span class="line">    DSF(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本会把所有满足结果的字符串打印出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_roun2t$e_%o</span><br><span class="line">_roun2t$e_`o</span><br><span class="line">_roun2t$e_go</span><br><span class="line">_roun7t$e_%o</span><br><span class="line">_roun7t$e_`o</span><br><span class="line">_roun7t$e_go</span><br><span class="line">_roun&lt;&#x27;-n4TO</span><br><span class="line">_rounD_EJ4TO</span><br><span class="line">_rounD_PCi?O</span><br><span class="line">_rounD_\Ci?O</span><br><span class="line">_rounD_we_%o</span><br><span class="line">_rounD_we_`o</span><br><span class="line">_rounD_we_go</span><br></pre></td></tr></table></figure>

<p>在里面挑一个最正常的“_rounD_we_go”与前半段组成flag：D0g3xGC{round_and_rounD_we_go}</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>图形化界面</title>
    <url>/posts/21586/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h1><h2 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h2><p>事件是操作系统或应用程序中发生的某个特定的、可由系统检测到的行为或状态改变。在Windows中，事件通常与线程或进程的执行、用户的操作（如点击按钮、按键）、硬件的状态变化等相关联。事件分为两类：</p>
<ul>
<li><strong>系统事件（如硬件事件等）</strong>：操作系统监视这些事件。</li>
<li><strong>应用程序事件</strong>：应用程序定义的事件，如用户点击按钮、窗口失去焦点等。</li>
</ul>
<h2 id="消息："><a href="#消息：" class="headerlink" title="消息："></a>消息：</h2><p>消息是Windows应用程序与操作系统和其他应用程序之间进行通信的基本单位。Windows是一个基于消息的系统，所有的用户输入、系统事件和应用程序之间的交互都是通过消息传递的（其实就是用来描述事件的）。每个消息都包含特定的信息，例如鼠标位置、按键信息等。</p>
<ul>
<li><strong>类型</strong>：每个消息有一个唯一的标识符，称为“消息类型”，例如<code>WM_PAINT</code>表示窗口需要重绘，<code>WM_KEYDOWN</code>表示用户按下键盘的一个键。</li>
<li><strong>传递机制</strong>：消息是通过消息队列传递的，消息队列是每个线程维护的一个队列，操作系统将消息放入队列，应用程序从队列中获取消息并进行处理。</li>
</ul>
<h3 id="MSG结构"><a href="#MSG结构" class="headerlink" title="MSG结构"></a>MSG结构</h3><p><code>MSG</code>结构体用于存储Windows消息的详细信息。它包含了以下几个重要字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct tagMSG &#123;</span><br><span class="line">    HWND hwnd;       // 消息的目标窗口的句柄(谁处理这个消息)</span><br><span class="line">    UINT message;    // 消息的类型（是点击左键还是敲击键盘）</span><br><span class="line">    WPARAM wParam;   // 消息的附加信息。16位整数</span><br><span class="line">    LPARAM lParam;   // 消息的附加信息。32位整数</span><br><span class="line">    DWORD time;      // 消息产生的时间</span><br><span class="line">    POINT pt;        // 消息发生时鼠标的坐标</span><br><span class="line">&#125; MSG;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hwnd</code>：该消息所关联的目标窗口的句柄。每个窗口都有一个唯一的句柄，它指示消息应该传递给哪个窗口。</li>
<li><code>message</code>：表示消息的类型（如<code>WM_MOUSEMOVE</code>、<code>WM_KEYDOWN</code>等）。消息类型本来是有编号的，但是由于编号难记，就将编号定义为了宏。</li>
<li><code>wParam</code> 和 <code>lParam</code>：这些是消息的附加参数，通常用于传递更多的上下文信息。</li>
<li><code>time</code>：消息的产生时间。</li>
<li><code>pt</code>：事件发生时鼠标位置的坐标。</li>
</ul>
<h2 id="消息流程："><a href="#消息流程：" class="headerlink" title="消息流程："></a>消息流程：</h2><p>Windows应用程序的消息处理流程大致如下：</p>
<ol>
<li><strong>操作系统产生消息</strong>：操作系统根据外部事件（如用户输入、系统变化等）生成消息。</li>
<li><strong>消息放入消息队列</strong>：每个线程有一个消息队列，操作系统将消息放入队列中。</li>
<li><strong>消息获取</strong>：应用程序通过<code>GetMessage</code>、<code>PeekMessage</code>等函数从消息队列中获取消息。如果队列为空，<code>GetMessage</code>会阻塞等待消息。</li>
<li><strong>消息分发</strong>：应用程序调用<code>DispatchMessage</code>函数将消息分发到适当的窗口过程（窗口的消息处理函数）。窗口过程根据消息类型做出相应的处理。</li>
<li><strong>窗口过程处理消息</strong>：每个窗口有一个窗口过程，它是一个函数，负责处理该窗口的消息。例如，<code>WM_PAINT</code>消息可以在窗口过程中的<code>WM_PAINT</code>分支下进行处理，重新绘制窗口。</li>
<li><strong>返回结果</strong>：窗口过程完成消息处理后，返回结果到操作系统。如果是响应用户输入或其他事件，可能会引发新的消息。</li>
</ol>
<img src="/posts/undefined/draw.drawio.png" class="" title="draw.drawio">

<h1 id="第一个图形界面程序："><a href="#第一个图形界面程序：" class="headerlink" title="第一个图形界面程序："></a>第一个图形界面程序：</h1><h2 id="关键函数和结构体"><a href="#关键函数和结构体" class="headerlink" title="关键函数和结构体"></a>关键函数和结构体</h2><h3 id="WNDCLASS"><a href="#WNDCLASS" class="headerlink" title="WNDCLASS"></a>WNDCLASS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct tagWNDCLASSA &#123;</span><br><span class="line">  UINT      style;  // 类样式</span><br><span class="line">  WNDPROC   lpfnWndProc;  // 窗口回调函数指针***</span><br><span class="line">  int       cbClsExtra;  // 要按照窗口类结构分配的额外字节数</span><br><span class="line">  int       cbWndExtra;  // 在窗口实例之后分配的额外字节数</span><br><span class="line">  HINSTANCE hInstance;  // 创建窗口的应用进程句柄***</span><br><span class="line">  HICON     hIcon;   // 类图标的句柄</span><br><span class="line">  HCURSOR   hCursor;  // 类游标的句柄</span><br><span class="line">  HBRUSH    hbrBackground;  // 类背景画笔的句柄</span><br><span class="line">  LPCSTR    lpszMenuName;  // 类菜单的资源名称</span><br><span class="line">  LPCSTR    lpszClassName;  // 窗口类名***</span><br><span class="line">&#125; WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;</span><br></pre></td></tr></table></figure>

<p>作用：定义窗口类</p>
<h3 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HWND CreateWindow(</span><br><span class="line">  [in, optional] LPCWSTR   lpClassName,		// 类名</span><br><span class="line">  [in, optional] LPCWSTR   lpWindowName,	// 窗口名称</span><br><span class="line">  [in]           DWORD     dwStyle,      // 窗口的样式</span><br><span class="line">  [in]           int       x,			// 窗口的初始水平位置</span><br><span class="line">  [in]           int       y,			// 窗口的初始垂直位置</span><br><span class="line">  [in]           int       nWidth,		// 宽度</span><br><span class="line">  [in]           int       nHeight,     // 高度</span><br><span class="line">  [in, optional] HWND      hWndParent,		// 父进程句柄</span><br><span class="line">  [in, optional] HMENU     hMenu,			// 菜单句柄</span><br><span class="line">  [in, optional] HINSTANCE hInstance,		// 当前应用程序的句柄  </span><br><span class="line">  [in, optional] LPVOID    lpParam			// 附加信息，一般为NULL	</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：注册窗口类</p>
<h3 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL ShowWindow(</span><br><span class="line">  [in] HWND hWnd,		// 窗口的句柄</span><br><span class="line">  [in] int  nCmdShow	// 窗口的显示方式。SW_SHOW代表激活窗口并以当前大小和位置显示窗口</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：展示窗口</p>
<h3 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL GetMessage(</span><br><span class="line">  [out]          LPMSG lpMsg,			// 接收消息的指针</span><br><span class="line">  [in, optional] HWND  hWnd,			// 目标窗口的句柄。若为NULL，则当前线程的任何窗口的消息</span><br><span class="line">  [in]           UINT  wMsgFilterMin,	// 要检索的最低消息值的整数值。</span><br><span class="line">  [in]           UINT  wMsgFilterMax	// 要检索的最高消息值的整数值。</span><br><span class="line">);    // 若wMsgFilterMin和wMsgFilterMax都为0，则返回所有可用消息</span><br></pre></td></tr></table></figure>

<p>作用：读取消息</p>
<h3 id="TranslateMessage"><a href="#TranslateMessage" class="headerlink" title="TranslateMessage"></a>TranslateMessage</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL TranslateMessage(</span><br><span class="line">  [in] const MSG *lpMsg			// 消息指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：加工、转换消息</p>
<h3 id="DispatchMessage"><a href="#DispatchMessage" class="headerlink" title="DispatchMessage"></a>DispatchMessage</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LRESULT DispatchMessage(</span><br><span class="line">  [in] const MSG *lpMsg			// 消息指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：将消息分发到对应的回调函数</p>
<h3 id="WndProc"><a href="#WndProc" class="headerlink" title="WndProc"></a>WndProc</h3><p>这个是自编的窗口回调函数，但是此函数有固定的格式，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LRESULT CALLBACK DefWindowProc(</span><br><span class="line">	HWND hwnd, 		 // 窗口句柄</span><br><span class="line">	UINT msg, 		// 消息类型</span><br><span class="line">	WPARAM wParam, 		// 消息附加信息</span><br><span class="line">	LPARAM lParam		// 消息附加信息</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>返回值：如果返回0则代表已处理，否者传给系统处理(调用DefWindowProc函数，参数与此函数相同)</p>
<p>作用：处理消息</p>
<h2 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h2><p>win32窗口应用程序不再有终端来打印调试，不能使用printf函数，但是提供另一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void OutputDebugStringA(</span><br><span class="line">  [in, optional] LPCSTR lpOutputString   // 传入字符串指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个函数传入字符串指针，在调试控制台打印字符串。但是参数只有一个，没办法打印变量的值，可以进行封装使之具备打印变量的能力:</p>
<p>Debug.h</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">void DebugLogA(const char* format, ...);  // 窄字符打印</span><br><span class="line">void DebugLogW(const wchar_t* format, ...); // 宽字符打印</span><br></pre></td></tr></table></figure>

<p>DebugLog.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;Debug.h&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">/*</span><br><span class="line">函数功能：实现格式化打印</span><br><span class="line">参数1：format，格式化字符串，类似于&quot;Error %d: %s&quot;</span><br><span class="line">参数2：&quot;...&quot;，可变数量的参数，对应格式化字符串中的占位符</span><br><span class="line">使用方式：与printf函数完全相同</span><br><span class="line">*/</span><br><span class="line">void DebugLogA(const char* format, ...) &#123; // 窄字符版本</span><br><span class="line">    char buf[512] = &#123; 0 &#125;;</span><br><span class="line">    va_list args;				//  声明va_list 类型的变量 args</span><br><span class="line">    va_start(args, format);		// 初始化可变参数列表，使 args 指向 format 后的第一个可变参数</span><br><span class="line">    _vsnprintf_s(buf, _countof(buf), _TRUNCATE, format, args);	// 将格式化字符串和参数组合成最终字符串</span><br><span class="line">    OutputDebugStringA(buf);		// 打印组合后的字符串</span><br><span class="line">    va_end(args);					 // 清理可变参数列表资源，避免资源泄漏</span><br><span class="line">&#125;</span><br><span class="line">void DebugLogW(const wchar_t* format, ...) &#123;  // 宽字符版本</span><br><span class="line">    wchar_t buf[512] = &#123; 0 &#125;;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    _vsnwprintf_s(buf, _countof(buf), _TRUNCATE, format, args);</span><br><span class="line">    OutputDebugStringW(buf);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了封装。在WinMain函数里面需要使用时，要把头文件包含进去。</p>
<p>程序如果出现了错误就只是不会弹窗，并不会告诉你错在哪，需要使用GetLastError函数获取错误码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_Post_equals_last_error_ DWORD GetLastError();  // 返回一个错误码</span><br></pre></td></tr></table></figure>

<p>正常来说错误码还需要拿到Windows官方网站去查找对应的错误信息，这里也封装一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PrintLastError() &#123;</span><br><span class="line">    DWORD err = GetLastError();  // 获取错误码</span><br><span class="line">    LPSTR msg = NULL;  // 存储错误信息</span><br><span class="line">    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,</span><br><span class="line">        NULL, err, 0, (LPSTR)&amp;msg, 0, NULL);  // 查找错误信息</span><br><span class="line">    DebugLog(&quot;Error %d: %s&quot;, err, msg);   // 打印</span><br><span class="line">    LocalFree(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h2><ol>
<li>自定义窗口类</li>
<li>注册窗口类</li>
<li>创建窗口</li>
<li>显示窗口</li>
<li>设置消息循环，捕获事件</li>
<li>生成消息，交给系统</li>
<li>创建回调函数</li>
</ol>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// FirstWindow.cpp : 定义应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;framework.h&quot;</span><br><span class="line">#include &quot;FirstWindow.h&quot;</span><br><span class="line">#include &quot;Debug.h&quot;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);</span><br><span class="line"></span><br><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">                     _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">                     _In_ LPWSTR    lpCmdLine,</span><br><span class="line">                     _In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    // 1、注册窗口类</span><br><span class="line">    TCHAR Name[] = L&quot;My First Window&quot;;</span><br><span class="line">    WNDCLASS wnd = &#123; 0 &#125;;</span><br><span class="line">    wnd.lpfnWndProc = WndProc;          // 回调函数</span><br><span class="line">    wnd.lpszClassName = Name;           // 类名</span><br><span class="line">    wnd.hInstance = hInstance;         // 进程句柄</span><br><span class="line">    wnd.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // 背景色(白色)</span><br><span class="line">    wnd.hCursor = LoadCursor(NULL, IDC_ARROW);   // 箭头光标</span><br><span class="line">    RegisterClass(&amp;wnd);</span><br><span class="line"></span><br><span class="line">    // 2、创建窗口</span><br><span class="line">    HWND hwnd = CreateWindow(</span><br><span class="line">        Name,                   // 类名</span><br><span class="line">        TEXT(&quot;我的Win32窗口&quot;),          // 窗口标题</span><br><span class="line">        WS_OVERLAPPEDWINDOW,     // 标准窗口样式</span><br><span class="line">        CW_USEDEFAULT,     // 初始水平位置（默认居中）</span><br><span class="line">        CW_USEDEFAULT,      // 初始垂直位置</span><br><span class="line">        500,                // 宽度500px</span><br><span class="line">        300,                // 高度300px</span><br><span class="line">        NULL,       // 父窗口</span><br><span class="line">        NULL,       // 菜单</span><br><span class="line">        hInstance,  // 实例句柄</span><br><span class="line">        NULL</span><br><span class="line">        );</span><br><span class="line">    if (hwnd == NULL) &#123;</span><br><span class="line">        MessageBoxW(NULL, L&quot;窗口创建失败!&quot;, L&quot;错误&quot;, MB_OK | MB_ICONERROR);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 显示窗口</span><br><span class="line">    ShowWindow(hwnd, SW_SHOW); // 显示窗口</span><br><span class="line">   </span><br><span class="line">    // 4. 消息循环</span><br><span class="line">    MSG msg;</span><br><span class="line">    while (GetMessage(&amp;msg, NULL, 0, 0) &gt; 0) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg); // 转换键盘消息</span><br><span class="line">        DispatchMessage(&amp;msg);  // 分发到窗口过程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  </span><br><span class="line">函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span><br><span class="line">目标: 处理主窗口的消息。</span><br><span class="line">*/ </span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    switch (message)</span><br><span class="line">    &#123;</span><br><span class="line">        case WM_CREATE:</span><br><span class="line">        &#123;</span><br><span class="line">            CREATESTRUCT* info = (CREATESTRUCT*)lParam;</span><br><span class="line">            DebugLogW(L&quot;窗口创建成功，窗口类名为%s\n&quot;, info-&gt;lpszClass);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_MOVE:</span><br><span class="line">        &#123;</span><br><span class="line">            POINTS point = MAKEPOINTS(lParam);</span><br><span class="line">            DebugLogA(&quot;窗口移动到了(%d,%d)\n&quot;, point.x, point.y);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_LBUTTONDOWN:</span><br><span class="line">        &#123;</span><br><span class="line">            POINTS point2 = MAKEPOINTS(lParam);</span><br><span class="line">            DebugLogA(&quot;按下了左键,坐标为(%d,%d)\n&quot;, point2.x, point2.y);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_KEYDOWN:</span><br><span class="line">            DebugLogA(&quot;按下了键盘，wParam：%#x，lParam：%#x\n&quot;, wParam, lParam);</span><br><span class="line">            return 0;</span><br><span class="line">        case WM_CLOSE:</span><br><span class="line">            DebugLogA(&quot;关闭窗口\n&quot;);</span><br><span class="line">            DestroyWindow(hWnd); // 销毁窗口</span><br><span class="line">            return 0;</span><br><span class="line">        case WM_DESTROY:</span><br><span class="line">            DebugLogA(&quot;销毁窗口\n&quot;);</span><br><span class="line">            PostQuitMessage(0);   // 关闭程序</span><br><span class="line">            return 0;</span><br><span class="line">        default:</span><br><span class="line">            return DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息类型："><a href="#消息类型：" class="headerlink" title="消息类型："></a>消息类型：</h2><h3 id="WM-CREATE-窗口创建通知"><a href="#WM-CREATE-窗口创建通知" class="headerlink" title="WM_CREATE - 窗口创建通知"></a><strong>WM_CREATE</strong> - 窗口创建通知</h3><p>代表窗口创建成功。</p>
<ul>
<li><p><em>wParam</em></p>
<p>未使用此参数。</p>
</li>
<li><p><em>lParam</em></p>
<p>指向CREATESTRUCTA 结构的指针，该结构包含有关所创建窗口的信息。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct tagCREATESTRUCT &#123;</span><br><span class="line">  LPVOID    lpCreateParams;  // 创建时传递的额外参数</span><br><span class="line">  HINSTANCE hInstance;       // 程序实例句柄</span><br><span class="line">  HMENU     hMenu;           // 菜单句柄或控件ID</span><br><span class="line">  HWND      hwndParent;      // 父窗口句柄</span><br><span class="line">  int       cy;              // 初始高度</span><br><span class="line">  int       cx;              // 初始宽度</span><br><span class="line">  int       y;               // 初始Y位置</span><br><span class="line">  int       x;               // 初始X位置</span><br><span class="line">  LONG      style;           // 窗口样式</span><br><span class="line">  LPCSTR    lpszName;        // 窗口标题（名称）</span><br><span class="line">  LPCSTR    lpszClass;       // 窗口类名</span><br><span class="line">  DWORD     dwExStyle;       // 扩展样式</span><br><span class="line">&#125; CREATESTRUCT;</span><br></pre></td></tr></table></figure>

<p>这个结构体信息与CreateWindow函数参数信息完全相同</p>
<h3 id="WM-MOVE-窗口移动通知"><a href="#WM-MOVE-窗口移动通知" class="headerlink" title="WM_MOVE - 窗口移动通知"></a><strong>WM_MOVE</strong> - 窗口移动通知</h3><ul>
<li><strong>wParam</strong>：未使用（值为0）</li>
<li><strong>lParam</strong>：包含新窗口位置的 坐标信息<ul>
<li>**LOWORD(lParam)**：屏幕坐标下的 X 位置</li>
<li>**HIWORD(lParam)**：屏幕坐标下的 Y 位置</li>
</ul>
</li>
</ul>
<p>可使用POINTS point &#x3D; MAKEPOINTS(lParam)来获取坐标</p>
<h3 id="WM-LBUTTONDOWN-鼠标左键按下"><a href="#WM-LBUTTONDOWN-鼠标左键按下" class="headerlink" title="WM_LBUTTONDOWN - 鼠标左键按下"></a>WM_LBUTTONDOWN - 鼠标左键按下</h3><ul>
<li><p><strong>wParam</strong>：<strong>修饰键状态标志</strong>（按位组合）</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>MK_LBUTTON</code></td>
<td align="center">0x0001</td>
<td align="center">鼠标左键按下状态</td>
</tr>
<tr>
<td align="center"><code>MK_RBUTTON</code></td>
<td align="center">0x0002</td>
<td align="center">鼠标右键按下状态</td>
</tr>
<tr>
<td align="center"><code>MK_SHIFT</code></td>
<td align="center">0x0004</td>
<td align="center">Shift键按下</td>
</tr>
<tr>
<td align="center"><code>MK_CONTROL</code></td>
<td align="center">0x0008</td>
<td align="center">Ctrl键按下</td>
</tr>
<tr>
<td align="center"><code>MK_MBUTTON</code></td>
<td align="center">0x0010</td>
<td align="center">鼠标中键按下</td>
</tr>
<tr>
<td align="center"><code>MK_XBUTTON1</code></td>
<td align="center">0x0020</td>
<td align="center">鼠标侧键1按下</td>
</tr>
<tr>
<td align="center"><code>MK_XBUTTON2</code></td>
<td align="center">0x0040</td>
<td align="center">鼠标侧键2按下</td>
</tr>
</tbody></table>
</li>
<li><p><strong>lParam</strong>：<strong>鼠标位置坐标</strong></p>
<ul>
<li>**LOWORD(lParam)**：X 坐标（相对于窗口客户区左上角）</li>
<li>**HIWORD(lParam)**：Y 坐标（相对于窗口客户区左上角）</li>
</ul>
</li>
</ul>
<h3 id="WM-KEYDOWN-键盘按键按下"><a href="#WM-KEYDOWN-键盘按键按下" class="headerlink" title="WM_KEYDOWN - 键盘按键按下"></a><strong>WM_KEYDOWN</strong> - 键盘按键按下</h3><ul>
<li><p><strong>wParam</strong>：<strong>虚拟键码</strong> (Virtual-Key Code) - 标识按下的物理键<br>常用虚拟键码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VK_SPACE  (32)    // 空格键</span><br><span class="line">VK_ESCAPE (27)    // Esc键</span><br><span class="line">VK_RETURN (13)    // Enter回车键</span><br><span class="line">VK_TAB    (9)     // Tab键</span><br><span class="line">VK_LEFT   (37)    // 左方向键</span><br><span class="line">VK_RIGHT  (39)    // 右方向键</span><br><span class="line">VK_UP     (38)    // 上方向键</span><br><span class="line">VK_DOWN   (40)    // 下方向键</span><br><span class="line">&#x27;A&#x27;-&#x27;Z&#x27;   (65-90) // 字母键</span><br><span class="line">&#x27;0&#x27;-&#x27;9&#x27;   (48-57) // 数字键</span><br><span class="line">F1-F24    (112-135) // 功能键</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>lParam</strong>：<strong>按键状态和重复信息</strong>（32位，按位解析）：</p>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">说明</th>
<th align="center">获取方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0-15</td>
<td align="center">重复计数（连续按下的次数）</td>
<td align="center"><code>LOBYTE(LOWORD(lParam))</code></td>
</tr>
<tr>
<td align="center">16-23</td>
<td align="center">扫描码（硬件相关）</td>
<td align="center"><code>HIWORD(lParam) &amp; 0xFF</code></td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">扩展键标志（1&#x3D;小键盘&#x2F;扩展键）</td>
<td align="center"><code>(lParam &amp; 0x01000000) ? true : false</code></td>
</tr>
<tr>
<td align="center">25-28</td>
<td align="center">保留</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">上下文键状态（1&#x3D;Alt键按下）</td>
<td align="center"><code>(lParam &amp; 0x20000000) ? true : false</code></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">前一个键状态（1&#x3D;之前已按下）</td>
<td align="center"><code>(lParam &amp; 0x40000000) ? true : false</code></td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">转换状态（0&#x3D;按下，1&#x3D;释放）</td>
<td align="center"><code>(lParam &amp; 0x80000000) ? false : true</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="WM-CLOSE-窗口关闭请求"><a href="#WM-CLOSE-窗口关闭请求" class="headerlink" title="WM_CLOSE - 窗口关闭请求"></a><strong>WM_CLOSE</strong> - 窗口关闭请求</h3><ul>
<li><strong>wParam</strong>：未使用（值为0）</li>
<li><strong>lParam</strong>：未使用（值为0）</li>
</ul>
]]></content>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集与编码</title>
    <url>/posts/27450/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>字符集是一个预定义的字符集合，每个字符被分配一个唯一的编号，称为码点。字符集类似于一个字典，将字符资源进行编号。</p>
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>ASCII（美国信息交换标准码）是最早出现的字符集，包含 128 个字符（0-127），包括英文大小写字母、数字、标点及控制字符（如换行符）。它将给这些字符分配码点，例如A的码点是 65。</p>
<p>ASCII字符集设计初衷只是为了美国使用，仅支持英文、数字及基本符号，世界上其他语言或表情符号无法用ASCII字符集来表示，于是后续出现了许多扩展字符集。</p>
<h2 id="本地化字符集："><a href="#本地化字符集：" class="headerlink" title="本地化字符集："></a>本地化字符集：</h2><p>为了解决ASCII字符集的局限性，各国开发了扩展字符集，以支持他们的语言和地区需求：</p>
<h3 id="GB2312-GBK："><a href="#GB2312-GBK：" class="headerlink" title="GB2312&#x2F;GBK："></a>GB2312&#x2F;GBK：</h3><p>GB2312是中国在1981年发布的国家标准，旨在收录大部分常用的中文字符。GBK是中国于1995年发布的字符集，兼容前面的GB2312，是对GB2312的扩充。</p>
<p>GBK作为ASCII的扩展字符集，完全兼容于ASCII。</p>
<h2 id="Unicode："><a href="#Unicode：" class="headerlink" title="Unicode："></a>Unicode：</h2><p>由于各国都使用了各自的本地化字符集，这些字符集各有冲突，互不兼容，可能一个码点在不同地区表示不同的字符，于是同一文件在不同地区打开可能出现乱码，单一编码也无法同时支持多语言（如中文 + 阿拉伯文 + 表情符号）。</p>
<p>在1991年，国际组织尝试将世界上所有语言符号（如汉字和表情）编在同一个字符集中，每一个字符分配全球唯一的一个码点，以解决互不兼容的问题。例如汉字“你”的码点是U+4F60。</p>
<p>Unicode目前一共U+0000~U+10FFFF的码位区（其中有一部分作为保留区，不分配给字符）。其中U+0000<code>~</code>U+FFFF包含绝大多数常用字符（拉丁字母、汉字、日韩文、标点等）；U+10000<code>~</code>U+10FFFF包含生僻汉字、历史文字、表情符号、专业符号等。</p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>编码是将字符的码点转换为二进制数据（字节序列）的规则，是上述字符集在计算中存储和传输的方式。</p>
<h2 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h2><p>使用1字节定长二进制数来表示ASCII字符集里面的字符。8比特中第一个比特置为0，后7个比特使用字符的码点。</p>
<h2 id="ANSI编码："><a href="#ANSI编码：" class="headerlink" title="ANSI编码："></a>ANSI编码：</h2><p>ANSI编码是指本地化的扩展ASCII编码，在Win32编程中，窄字符（char）就使用这种编码方式。</p>
<p>常用的ANSI编码有GBK编码，这是对GBK字符集的具体实现，此编码方式完全兼容于ASCII编码，属于变长编码方式。</p>
<ul>
<li>0~127个字符与ASCII完全相同，使用一个字节表示</li>
<li>绝大多数的汉字等扩展字符使用2字节来表示， 首字节在 <code>0x81</code> 到 <code>0xFE</code> (十进制 129 到 254) 之间，第二字节在 <code>0x40</code> 到 <code>0xFE</code> (十进制 64 到 254) 之间。</li>
</ul>
<p>Windows在不同的地区采用了不同的本地化字符，例如在中国大陆，使用GBK。GBK的优点是在中文环境下编码效率相对较高，仅需两个字节即可表示一个中文字符。但是不同地区的字符集和编码方式不同，并且Linux等其他系统使用的是utf-8，所以在跨地区或跨系统时，GBK不兼容。</p>
<h2 id="Unicode-编码："><a href="#Unicode-编码：" class="headerlink" title="Unicode 编码："></a>Unicode 编码：</h2><p>此类编码是对Unicode 字符集的实现，包括utf-8、utf-16、utf-32，其中utf-8是里面编码效率最高的，也是目前国际实际的标准。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8是可变长编码，之所以要选择可变长，是为了增加编码效率，让常用的字符占尽量少的字节，同时又要实现Unicode的全包含 ，以达到全球兼容的目的。</p>
<p>UTF-8采用了从1~4字节的不等编码，变长编码需要解决的主要问题是如何划定一个字符的结束位置，UTF-8给出的方案是将Unicode 字符集划分为4个范围：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">码点范围            | 字节布局</span><br><span class="line">U+0000 ~ U+007F    | 0xxxxxxx</span><br><span class="line">U+0080 ~ U+07FF    | 110xxxxx 10xxxxxx</span><br><span class="line">U+0800 ~ U+FFFF    | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">U+10000 ~ U+10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>

<p>其中码点在U+0000 ~ U+007F  的占一个字节，与ASCII完全兼容，所以以前使用ASCII的程序在UTF-8的环境下也能正常运行。每一个字符的第一个字节前面有几个比特连续的1，就代表这个字符由多少字节组成，首字节后的字节前两个比特都是“10”，是为了与ASCII字符区分出来。去掉首字符与后续字符的前缀，得到的比特位拼接在一起形成的二进制数在数值上等同于该字符Unicode 中的码点。</p>
<p>假设已知一个字符，需要将其编码为UTF-8，正确流程是：</p>
<ol>
<li>获取字符在Unicode 中的码点</li>
<li>判断该码点落在哪个范围内，以确定由几个字节组成及其字节前缀</li>
<li>将码点转化为二进制数，从右往左填充除前缀外的位置（上面的”x”），得到的就是UTF-8编码</li>
</ol>
<p>而解码则是：</p>
<ol>
<li>读取首字节，判断前几个比特位为1，代表该字符由几个字节组成</li>
<li>这几个字节的转化为二进制，前缀去掉，将剩余比特位拼接位二进制数，此即是其码点</li>
</ol>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 是可变长编码，字符的编码方式根据码点的范围决定。常见字符使用 2 字节表示，而超出该范围的字符（如表情符号）需要使用 4 字节，通过代理对（surrogate pairs）来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">U+0000~U+FFFF： 直接存储 0000~FFFF</span><br><span class="line"></span><br><span class="line">U+10000~U+10FFFF：由高位代理（2字节，起标识作用）和低位代理（2字节）组成的4字节代理对表示</span><br><span class="line">高位代理范围：0xD800~0xDBFF</span><br><span class="line">低位代理范围：0xDC00~0xDFFF</span><br><span class="line">这两个代理区是Unicode为UTF-16专门预留的空间，不可用作任何字符的码点！！！</span><br><span class="line">编码过程（例如码点为U+10437）：</span><br><span class="line">0x10437 - 0x10000 = 0x437  ---------得到一个00000~FFFFF共20位的值</span><br><span class="line">0x437 &gt;&gt; 10 = 0x1          ---------前10比特作为高位代理的偏移</span><br><span class="line">0x437 &amp; 0x3FF = 0x37	   ---------后10比特作为低位代理的偏移</span><br><span class="line">最后组成的代理对为：0xD801-0XDC37</span><br></pre></td></tr></table></figure>

<p>UTF-16是UTF-8和UTF-32的平衡与兼容，对于常用文字（包括中文），使用两字节来表示；对于不常用符号，使用4字节来表示。UTF-16较多的使用在Windows系统中</p>
<h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>UTF-32是定长编码，规定使用4字节来表示Unicode 中的所有字符。由于Unicode的码点范围为U+0~U+10FFFF，故仅需要21位比特即可完全表示，4字节完全够用。所以UTF-32采用了直接映射的方式，即令UTF-32编码在数值上等同于字符的码点。Linux系统中一般使用UTF-32编码。</p>
<h1 id="编译器与编码"><a href="#编译器与编码" class="headerlink" title="编译器与编码"></a>编译器与编码</h1><h2 id="“窄”与“宽”："><a href="#“窄”与“宽”：" class="headerlink" title="“窄”与“宽”："></a>“窄”与“宽”：</h2><p>窄字符编码是指<strong>使用单字节（<code>char</code>）存储文本的变长编码方案</strong>。包括UTF-8、GBK、ANSI、ASCII。窄字符编码并不是一个固定的编码方式，而是指一种字符表示方式，有如下特点：</p>
<ul>
<li>使用char类型存储字符</li>
<li>通常是不定长编码</li>
<li>是字节流编码，即基本单位是字节</li>
</ul>
<p>宽字符编码是指<strong>使用多字节(wchar_t)存储文本的定长编码方案。</strong>包括UTF-16，UTF-32。有如下特点：</p>
<ul>
<li>使用wchar_t类型存储字符</li>
<li>通常是定长编码</li>
<li>是字符流编码，即基本单位是字符（操作以字符为单位）</li>
</ul>
<h2 id="不同操作系统、编译器中窄字符与宽字符编码方式"><a href="#不同操作系统、编译器中窄字符与宽字符编码方式" class="headerlink" title="不同操作系统、编译器中窄字符与宽字符编码方式"></a>不同操作系统、编译器中窄字符与宽字符编码方式</h2><table>
<thead>
<tr>
<th></th>
<th>MSVC</th>
<th>GCC</th>
</tr>
</thead>
<tbody><tr>
<td>Windows(窄字符char)</td>
<td>默认输出文件编码为本地编码(中国是GBK)</td>
<td>默认输出文件编码为UTF-8</td>
</tr>
<tr>
<td>Windows(宽字符wchar_t)</td>
<td>固定输出文件编码为UTF-16</td>
<td>固定输出文件编码为UTF-16</td>
</tr>
<tr>
<td>Linux\macOS(窄字符char)</td>
<td>不使用MSVC</td>
<td>默认输出文件编码为UTF-8</td>
</tr>
<tr>
<td>Linux\macOS(宽字符wchar_t)</td>
<td>不使用MSVC</td>
<td>默认输出文件编码为UTF-32</td>
</tr>
</tbody></table>
<ol>
<li>在Windows（中国区）中，默认终端是GBK，MSVC编译器源文件默认识别为GBK，GCC源文件默认识别为UTF-8；       					而Linux里，默认终端、GCC默认源文件都是UTF-8文件；</li>
<li>GCC编译时若要指定源文件的编码为GBK，则需要使用“-finput-charset&#x3D;GBK”参数；若要指定输出文件中窄字符的编码为GBK，则需要使用“-fexec-charset&#x3D;GBK”参数。</li>
<li>源文件使用的编码方式影响的是<strong>编译器如何解析字符串文本</strong>，但最终生成的 <code>.exe</code> 文件中字符串的编码方式由 <code>-fexec-charset</code> 或其他机制决定，两者并无必然一致关系。</li>
<li>窄字符转化过程：假设的源文件为GBK，要输出的exe文件为utf-8，那么编译器会先将窄字符GBK解码为字符对应的Unicode码点，然后再将Unicode码点编码为utf-8，最后保存在exe文件中的是字符的utf-8编码形式。此时，若要在终端上打印，则终端会按默认编码（GBK）来解释窄字符，这样就会导致打印乱码。</li>
<li>宽字符转化过程：假设源文件为 GBK 编码，编译器会先将源文件内容解码为 Unicode 字符码点。对于宽字符文本（如 <code>L&quot;你好&quot;</code>），会将这些字符编码为目标平台的宽字符格式（Windows 为 UTF-16，Linux 为 UTF-32），并将这些宽字符序列保存在 <code>.exe</code> 文件中。</li>
<li>编译器在碰到无法正常识别的窄字符时，会直接将原字节照抄到exe文件中，不进行编码转换。因此如果源文件为gbk，但Gcc默认识别utf-8，则编译器识别错误，直接把窄字符在源文件中的字节复制到exe文件里面，由于终端是gbk，所以刚好能被终端识别，打印出正常的字符；</li>
<li>编译器在碰到无法正常识别的宽字符时，会直接编译失败。</li>
<li>终端本质上是按字节流工作的设备，因此在使用 <code>wprintf</code> 输出宽字符时，底层需要将宽字符编码为终端所支持的窄字符流。若当前进程没有设置正确的 <code>locale</code>（如默认是 <code>&quot;C&quot;</code>），那么字符转换会失败或退化为 ASCII，从而导致中文等字符无法正确打印。因此，在使用宽字符时，务必调用 <code>setlocale(LC_CTYPE, &quot;&quot;)</code> 来启用当前系统的本地编码设置。</li>
</ol>
]]></content>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>导入表</title>
    <url>/posts/23232/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>PE文件需要用到其他库里面的函数时，需要有一个导入表来记录这些导入函数的地址。导入表与导出表的关系可以理解为：你是一个exe文件，你需要去一家餐馆吃饭，而dll是这家店的老板，他给你提供了他们店的菜单，这个是他的导出表；你将你需要的菜写下来，这个是你的导入表；导入表只在隐式链接使用。</p>
<p>导入表的的地址存储在可选PE头最后一个成员——DataDirectory数组的第二个元素，即DataDirectory[1]。</p>
<p>导入表实际上是结构体<strong>数组</strong>，它由许多个<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体组成，每一个外部库需要一个结构体，在所有结构的最后,由一个内容全为0的<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体作为结束标志。每一个结构体成员如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">  union &#123;</span><br><span class="line">    DWORD  Characteristics;      </span><br><span class="line">    DWORD  OriginalFirstThunk;     // 指向导入名称表(INT，import name table)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">  DWORD  TimeDateStamp;        </span><br><span class="line">  DWORD  ForwarderChain;         </span><br><span class="line">  DWORD  Name;					// 该库名字的地址</span><br><span class="line">  DWORD  FirstThunk;           // 指向导入地址表(IAT，import address table),同时也是DataDirectory[13]</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>IAT(导入函数地址表)和INT(导入函数名称表)，都是一个<strong>结构体数组</strong>，它的成员都是<code>IMAGE_THUNK_DATA</code>结构的结构体。与导入表相似，IAT、INT也是以一个全为0的结构体结尾。<code>IMAGE_THUNK_DATA</code>结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_THUNK_DATA32</span><br><span class="line">&#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD ForwarderString;      // 转发字符串的RAV</span><br><span class="line">        DWORD Function;             // 被导入函数的地址</span><br><span class="line">        DWORD Ordinal;              // 被导入函数的序号</span><br><span class="line">        DWORD AddressOfData;        // 指向输入名称表 PIMAGE_IMPORT_BY_NAME</span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p>这是一个联合体，只有一个成员有效，一共占4个字节。当结构体的最高位为1时,表示函数是以序号的方式导入的,这时结构体的低位就是函数的序号；当双字最高位为0时,表示函数以函数名方式导入,这时结构体的值是一个RVA,指向一个用来定义导入函数名称的<code>IMAGE_IMPORT_BY_NAME</code>结构,此结构定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_BY_NAME</span><br><span class="line">&#123;</span><br><span class="line">    WORD    Hint;          // 函数序号</span><br><span class="line">    CHAR   Name[1];        // 导入函数的名称（这里定义为一个字节，但是实际上只是名字的首个字符）</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>dll在文件中时，IAT和INT的内容完全相同；当dll加载进内存之后，导入函数地址会填入IAT中<code>IMAGE_THUNK_DATA</code>的Function里面，此时这个结构体的4个字节就是一个指向导入函数的地址（RVA），使得程序可以直接通过这个地址来调用函数。而INT一直保持不变，于是加载后IAT与INT不相同。</p>
<p>注：可以通过修改导入表来让IAT和INT指向同一张表，由于PE文件运行时，INT表几乎用不到，所以这样在大多数情况不会影响程序的运行。</p>
<p><strong>导入表在文件中时：</strong></p>
<img src="/posts/23232/88bdc5cc50237f48060afe4af0c3107f.jpeg" class="" title="img">

<p>上例中一共有4个导入函数，前3个是以名字导入，第4个是以序号导入。此时INT和IAT结构是相同的。</p>
<p><strong>导入完成后的导入表：</strong></p>
<img src="/posts/23232/00110338f2667ee48574243bcec1ccb5.jpeg" class="" title="img">

<h3 id="导入流程："><a href="#导入流程：" class="headerlink" title="导入流程："></a>导入流程：</h3><p>导入dll库分为两种方法：<strong>静态导入和动态导入</strong>。</p>
<h4 id="静态导入："><a href="#静态导入：" class="headerlink" title="静态导入："></a><strong>静态导入：</strong></h4><ol>
<li><strong>编译和链接阶段</strong>：<ul>
<li><strong>创建导入表</strong>：链接器根据对象文件中的外部符号引用，创建 PE 文件的导入表。</li>
<li><strong>添加占位符</strong>：对于每个导入的函数，在 IAT 中会有一个占位符（即IMAGE_THUNK_DATA32），它将在运行时由 Windows 加载器替换为实际的函数地址。</li>
</ul>
</li>
<li><strong>每次启动时</strong>：<ul>
<li><strong>重新解析导入表</strong>：当程序启动时，Windows 加载器会读取 PE 文件中的导入表，并根据其中的信息加载所有静态导入的 DLL。</li>
<li><strong>更新 IAT</strong>：加载器会通过dll里面的导出表来解析他提供的导出函数地址，并用实际的地址更新 IAT 中的占位符。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>自动加载</strong>：所有静态导入的 DLL 在程序启动时自动加载。</li>
<li><strong>依赖性强</strong>：如果缺少任何一个必要的 DLL，程序将无法启动。</li>
<li><strong>IAT 更新频率</strong>：每次启动程序时都需要重新解析和更新 IAT。</li>
</ul>
</li>
</ol>
<h4 id="动态导入："><a href="#动态导入：" class="headerlink" title="动态导入："></a><strong>动态导入：</strong></h4><ol>
<li><strong>编译和链接阶段</strong>：<ul>
<li><strong>不生成导入表条目</strong>：与静态导入不同，动态连接不会在编译和链接阶段为动态加载的 DLL 创建导入表条目，<strong>动态导入与导入表无关</strong>。</li>
</ul>
</li>
<li><strong>每次启动时</strong>：<ul>
<li><strong>按需加载</strong>：动态连接的 DLL 不会在程序启动时自动加载，而是在需要时由程序显式调用 <code>LoadLibrary</code> 来加载。在使用LoadLibrary函数时，系统会将dll加载进空间，并返回一个句柄（即dll的地址）。使用GetProcAddress后，系统会根据函数名字或序号查找dll的导出表，得到函数RVA，此RVA加上dll的基址得到真实的函数地址，GetProcAddress将真实函数地址返回给程序保存。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>灵活性高</strong>：允许程序在运行时根据需要加载和卸载模块，提供了更大的灵活性。</li>
<li><strong>减少初始加载时间</strong>：在启动时不需要装载dll、修正导入表，所以可以加快程序的启动速度。</li>
<li><strong>IAT 更新频率</strong>：不需要任何IAT也不生成任何IAT。</li>
</ul>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>在静态导入dll时，编译阶段创建导入表，但在程序的启动阶段才会修正IAT表，一是因为ASLR 机制导致程序每一次启动都会分配不一样的基址，二是因为在程序开始时，dll文件才会映射到当前进程的虚拟地址中，这个时候才能知道导入函数的实际地址。启动阶段，IAT中所有导入函数（不管用没用到）的地址都会修正。</p>
<p>在编译时，所有调用导入函数（隐式导入）的代码都会被编译为CALL DWORD PTR [0x41C09C]这样的格式，其中0x41C09C实际上是该导入函数IAT的绝对地址（后续可能在启动阶段被重定位），所以这个指令实际上是提取0x41C09C地址处的4字节（这4个字节会在启动阶段被修正为函数的真实地址），然后跳转过去。如果在程序运行时调用一个函数将导入表中的IAT修改为自定义函数的地址，那么后续调用此导入函数时，将会跳转到自定义函数处（静态反汇编还是显示原函数），这就是IAT HOOK的原理。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>目标：打印导入表信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">IMAGE_IMPORT_DESCRIPTOR* import;</span><br><span class="line">int num=0;           //节数量</span><br><span class="line">int header_size=0;   // PE头大小</span><br><span class="line">int base=0;          // 基址</span><br><span class="line">int fsize=0,image_size=0; // 文件大小；文件映射的内存大小</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">	DWORD foa=0;</span><br><span class="line">    if(rva&lt;=header_size) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rva&lt;sheader[0].VirtualAddress) &#123;</span><br><span class="line">        printf(&quot;没有对应的foa!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &gt;= num) &#123;</span><br><span class="line">        printf(&quot;RVA超出范围!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">	return foa;</span><br><span class="line">&#125;</span><br><span class="line">void print_import(unsigned char *buffer)&#123;  // 打印导入表</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;;i++)&#123;</span><br><span class="line">        if(import[i].OriginalFirstThunk==0&amp;&amp;import[i].FirstThunk==0) break;</span><br><span class="line">        printf(&quot;%s导入表信息:\n&quot;,(char *)(RVA_to_FOA(import[i].Name)+buffer));</span><br><span class="line">        printf(&quot;OriginalFirstThunk(INT):%#010x\n&quot;,import[i].OriginalFirstThunk);</span><br><span class="line">        printf(&quot;TimeDateStamp:%#010x\n&quot;,import[i].TimeDateStamp);</span><br><span class="line">        printf(&quot;ForwarderChain:%#010x\n&quot;,import[i].ForwarderChain);</span><br><span class="line">        printf(&quot;Name:%#010x\n&quot;,import[i].Name);</span><br><span class="line">        printf(&quot;FirstThunk(IAT):%#010x\n\n&quot;,import[i].FirstThunk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void print_IAT(unsigned char *file_buf)&#123;  // 打印IAT表</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    IMAGE_THUNK_DATA32* IAT;</span><br><span class="line">    IMAGE_IMPORT_BY_NAME* name_t;</span><br><span class="line">    for(i=0;;i++)&#123;</span><br><span class="line">        if(import[i].OriginalFirstThunk==0&amp;&amp;import[i].FirstThunk==0) break;</span><br><span class="line">        printf(&quot;%s中导出函数:\n&quot;,(char *)(RVA_to_FOA(import[i].Name)+file_buf));</span><br><span class="line">        IAT = (IMAGE_THUNK_DATA32*)(RVA_to_FOA(import[i].FirstThunk)+file_buf);</span><br><span class="line">        printf(&quot;函数名导入:\n&quot;);</span><br><span class="line">        printf(&quot;函数名     Hint\n&quot;);</span><br><span class="line">        for(j=0;;j++)&#123;</span><br><span class="line">            if(IAT[j].u1.AddressOfData==0) break;</span><br><span class="line">            if(IAT[j].u1.AddressOfData&gt;&gt;31==0)</span><br><span class="line">            &#123;</span><br><span class="line">                name_t = (IMAGE_IMPORT_BY_NAME*)(RVA_to_FOA(IAT[j].u1.AddressOfData)+file_buf);</span><br><span class="line">                printf(&quot;%s      %#x\n&quot;,(char*)name_t-&gt;Name,name_t-&gt;Hint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n序号导入:\n&quot;);</span><br><span class="line">        for(j=0;;j++)&#123;</span><br><span class="line">            if(IAT[j].u1.AddressOfData==0) break;</span><br><span class="line">            if(IAT[j].u1.AddressOfData&gt;&gt;31==1)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;序号:%#x\n&quot;,IAT[j].u1.AddressOfData&amp;0x7fffffff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // if(argc != 2) &#123;</span><br><span class="line">    //     printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">    //     return 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    const char* pe_path = &quot;grade.exe&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize);</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *buffer=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    buffer+=dos-&gt;e_lfanew+4;  // 定位文件头</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    num = fheader-&gt;NumberOfSections;</span><br><span class="line">    buffer+=20;      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    header_size=oheader-&gt;SizeOfHeaders;</span><br><span class="line">    base=oheader-&gt;ImageBase;</span><br><span class="line">    image_size = oheader-&gt;SizeOfImage;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    int size = num * sizeof(IMAGE_SECTION_HEADER);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    import = (IMAGE_IMPORT_DESCRIPTOR*)(RVA_to_FOA(oheader-&gt;DataDirectory[1].VirtualAddress)+file_buf);</span><br><span class="line">	print_import(file_buf);</span><br><span class="line">    print_IAT(file_buf);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>导入表注入</title>
    <url>/posts/44489/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="DLLMain："><a href="#DLLMain：" class="headerlink" title="DLLMain："></a>DLLMain：</h1><p>DllMain是.dll文件的入口函数，当系统加载或卸载 DLL 时会自动调用它。它的参数为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL WINAPI DllMain(</span><br><span class="line">    _In_ HINSTANCE hinstDLL,   // DLL 模块句柄</span><br><span class="line">    _In_ DWORD     fdwReason,  // 调用原因标志</span><br><span class="line">    _In_ LPVOID    lpvReserved // 保留参数（通常为NULL）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中fdwReason调用原因：</p>
<table>
<thead>
<tr>
<th align="left"><strong>标志值</strong></th>
<th align="left"><strong>触发时机</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DLL_PROCESS_ATTACH</strong></td>
<td align="left">DLL 首次被进程加载时</td>
</tr>
<tr>
<td align="left"><strong>DLL_PROCESS_DETACH</strong></td>
<td align="left">DLL 从进程卸载时</td>
</tr>
<tr>
<td align="left">DLL_THREAD_ATTACH</td>
<td align="left">新线程在进程中创建时</td>
</tr>
<tr>
<td align="left">DLL_THREAD_DETACH</td>
<td align="left">线程正常退出时</td>
</tr>
</tbody></table>
<p>于是，可以用类似这样的代码来让dll加载和卸载时运行我们的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain(</span><br><span class="line">    HMODULE hModule, </span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">) &#123;</span><br><span class="line">    switch (ul_reason_for_call) &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH:</span><br><span class="line">            // 加载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已加载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_PROCESS_DETACH:</span><br><span class="line">            // 卸载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 即将卸载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_ATTACH:</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_DETACH:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="导入表注入步骤："><a href="#导入表注入步骤：" class="headerlink" title="导入表注入步骤："></a>导入表注入步骤：</h1><h2 id="dll文件："><a href="#dll文件：" class="headerlink" title="dll文件："></a>dll文件：</h2><p>在DLLMain里面加入要实现的函数和一个导出函数（这个一定要有，不然exe在加载阶段会直接报错），生成dll，把dll与待注入文件放同一个目录</p>
<p>.h：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">	_declspec(dllexport) int __stdcall add(int a, int b);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>.c：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;dllmain.h&quot;</span><br><span class="line"></span><br><span class="line">int __stdcall add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APIENTRY DllMain(</span><br><span class="line">    HMODULE hModule, </span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">) &#123;</span><br><span class="line">    switch (ul_reason_for_call) &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH:</span><br><span class="line">            // 加载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已加载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_PROCESS_DETACH:</span><br><span class="line">            // 卸载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 即将卸载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_ATTACH:</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_DETACH:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注入程序："><a href="#注入程序：" class="headerlink" title="注入程序："></a>注入程序：</h2><p>注入程序的主要逻辑是:</p>
<ul>
<li>先创建一个新节（注意可写）</li>
<li>将所有导入表移动到新节中</li>
<li>创建一个新的导入表结构</li>
<li>创建导入表结构中的INT和IAT（可以共享同一张表）</li>
<li>修正导入表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">DWORD FOA_to_RVA(DWORD foa)&#123;</span><br><span class="line">    DWORD rva=0;</span><br><span class="line">    if(foa&lt;oheader-&gt;SizeOfHeaders) &#123;</span><br><span class="line">        rva = foa;</span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;fheader-&gt;NumberOfSections;i++)&#123;</span><br><span class="line">        if(foa&gt;=sheader[i].PointerToRawData&amp;&amp;foa&lt;(sheader[i].PointerToRawData+sheader[i].SizeOfRawData))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=foa-sheader[i].PointerToRawData;</span><br><span class="line">    rva = sheader[i].VirtualAddress + offset;</span><br><span class="line">    return rva;</span><br><span class="line">&#125;</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">    DWORD foa=0;</span><br><span class="line">    if(rva&lt;oheader-&gt;SizeOfHeaders) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;fheader-&gt;NumberOfSections;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == fheader-&gt;NumberOfSections) &#123;printf(&quot;没有对应的FOA\n&quot;);return 0;&#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">    return foa;</span><br><span class="line">&#125;</span><br><span class="line">int new_section(int new_size)&#123;  // 创建新节，参数：新节大小，返回值：是否成功创建</span><br><span class="line">    // 判断是否能加节表:</span><br><span class="line">    if(oheader-&gt;SizeOfHeaders-(dos-&gt;e_lfanew+4+sizeof(IMAGE_FILE_HEADER)+fheader-&gt;SizeOfOptionalHeader+fheader-&gt;NumberOfSections*sizeof(IMAGE_SECTION_HEADER))&lt;=80)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;空间不足以创建节表\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = fheader-&gt;NumberOfSections;</span><br><span class="line">    strcpy(sheader[index].Name,&quot;new&quot;);</span><br><span class="line">    sheader[index].Misc.VirtualSize = new_size;</span><br><span class="line">    sheader[index].VirtualAddress = sheader[index-1].VirtualAddress + ((sheader[index-1].Misc.VirtualSize)/oheader-&gt;SectionAlignment+1)*oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].PointerToRawData = sheader[index-1].PointerToRawData + sheader[index-1].SizeOfRawData;</span><br><span class="line">    sheader[index].SizeOfRawData = new_size;</span><br><span class="line">    sheader[index].Characteristics = 0xE00000A0;  // 可读可写可执行</span><br><span class="line">    sheader[index].PointerToRelocations = sheader[index-1].PointerToRelocations;</span><br><span class="line">    sheader[index].PointerToLinenumbers = sheader[index-1].PointerToLinenumbers;</span><br><span class="line">    sheader[index].NumberOfRelocations = sheader[index-1].NumberOfRelocations;</span><br><span class="line">    sheader[index].NumberOfLinenumbers = sheader[index-1].NumberOfLinenumbers;</span><br><span class="line">    fheader-&gt;NumberOfSections++;</span><br><span class="line">    oheader-&gt;SizeOfImage+=oheader-&gt;SectionAlignment;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">DWORD move_import(DWORD offset,unsigned char *file_buf)&#123;  // 移动导入表。参数1：偏移FOA；参数2：文件指针</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR* import = (IMAGE_IMPORT_DESCRIPTOR*)(file_buf+RVA_to_FOA(oheader-&gt;DataDirectory[1].VirtualAddress));</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;;i++)&#123;  // 判断有多少个导入表</span><br><span class="line">        if(import[i].FirstThunk==0&amp;&amp;import[i].OriginalFirstThunk==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(file_buf+offset,file_buf+RVA_to_FOA(oheader-&gt;DataDirectory[1].VirtualAddress),i*sizeof(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line">    oheader-&gt;DataDirectory[1].VirtualAddress = FOA_to_RVA(offset);</span><br><span class="line">    offset +=i*sizeof(IMAGE_IMPORT_DESCRIPTOR);</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">DWORD add_import(DWORD offset,unsigned char *file_buf,char *s)&#123;  // 增加导入表。参数1：偏移FOA；参数2：文件指针；参数3：dll名字</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR* new_import = (IMAGE_IMPORT_DESCRIPTOR*)(file_buf+offset);</span><br><span class="line">    offset += 2*sizeof(IMAGE_IMPORT_DESCRIPTOR); // 还要留一个空表作结尾，故乘2</span><br><span class="line">    IMAGE_THUNK_DATA32 *INT,*IAT;  // 这里指的是FOA</span><br><span class="line">    new_import-&gt;OriginalFirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    INT = (IMAGE_THUNK_DATA32*)(file_buf+offset);</span><br><span class="line">    INT-&gt;u1.Ordinal = 0x80000001; // 设置为序号导入，序号为1</span><br><span class="line">    INT[1].u1.Ordinal = 0x0;  // 留一个空结构为结尾</span><br><span class="line">    offset += 8;</span><br><span class="line">    new_import-&gt;FirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    IAT = (IMAGE_THUNK_DATA32*)(file_buf+offset);</span><br><span class="line">    IAT-&gt;u1.Ordinal = 0x80000001;</span><br><span class="line">    IAT[1].u1.Ordinal = 0x0;</span><br><span class="line">    offset += 8;</span><br><span class="line">    strcpy((char *)(file_buf+offset),s); // 复制名字</span><br><span class="line">    new_import-&gt;Name = FOA_to_RVA(offset);</span><br><span class="line">    offset += strlen(s)+1;</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">DWORD add_import_name(DWORD offset,unsigned char *file_buf,char *s)&#123;  // 增加导入表。参数1：偏移FOA；参数2：文件指针；参数3：dll名字</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR* new_import = (IMAGE_IMPORT_DESCRIPTOR*)(file_buf+offset);</span><br><span class="line">    offset += 2*sizeof(IMAGE_IMPORT_DESCRIPTOR); // 还要留一个空表作结尾，故乘2</span><br><span class="line">    IMAGE_THUNK_DATA32 *INT;  // 这里指的是FOA</span><br><span class="line">    new_import-&gt;OriginalFirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    new_import-&gt;FirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    INT = (IMAGE_THUNK_DATA32*)(file_buf+offset);</span><br><span class="line">    offset+=8;  // 一个INT表加一个空表共8字节</span><br><span class="line">    INT-&gt;u1.AddressOfData = FOA_to_RVA(offset);</span><br><span class="line">    IMAGE_IMPORT_BY_NAME* by_name=(IMAGE_IMPORT_BY_NAME*)(file_buf+offset);</span><br><span class="line">    by_name-&gt;Hint = 1;</span><br><span class="line">    offset+=2;</span><br><span class="line">    char *fun=&quot;add&quot;;  // 函数名</span><br><span class="line">    strcpy((char *)(file_buf+offset),fun);</span><br><span class="line">    offset+=strlen(fun)+1;</span><br><span class="line">    strcpy((char *)(file_buf+offset),s); // 复制名字</span><br><span class="line">    new_import-&gt;Name = FOA_to_RVA(offset);</span><br><span class="line">    offset += strlen(s)+1;</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int new_size = 0x1000;  // 定义新节大小</span><br><span class="line">    const char* pe_path = &quot;testdll.exe&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    int fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize+new_size);   // 多分配0x1000用作新节</span><br><span class="line">    memset(file_buf, 0, fsize+new_size);</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *buffer=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    if(dos-&gt;e_magic!=0x5A4D) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=dos-&gt;e_lfanew;  // 定位文件头</span><br><span class="line">    if(*(DWORD*)buffer!=0x4550) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=4;</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer+=sizeof(IMAGE_FILE_HEADER);      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    if(!new_section(new_size))&#123;free(file_buf);return 0;&#125;</span><br><span class="line">    DWORD offset=sheader[fheader-&gt;NumberOfSections-1].PointerToRawData;</span><br><span class="line">    offset=move_import(offset,file_buf);</span><br><span class="line">    char *s=&quot;dllmain.dll&quot;;</span><br><span class="line">    offset = add_import(offset,file_buf,s);</span><br><span class="line">    // 写入新文件</span><br><span class="line">    FILE *new_file = fopen(&quot;new.exe&quot;,&quot;wb&quot;);</span><br><span class="line">    if (!new_file) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int written=fwrite(file_buf,sizeof(unsigned char),fsize+new_size,new_file);</span><br><span class="line">    if(written!=fsize+new_size)&#123;</span><br><span class="line">        perror(&quot;写入错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(new_file);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注入后目标程序在运行时就会弹出：</p>
<img src="/posts/44489/image-20250712190125481.png" class="" title="image-20250712190125481">

<p>在运行完成后就会弹出</p>
<img src="/posts/44489/image-20250712190454257.png" class="" title="image-20250712190454257">
]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>导出表</title>
    <url>/posts/20158/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>optional头最后一个成员DataDirectory[16]，这个结构体数组中的第一个元素存储的就是导出表的位置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;  // 导出表的RVA</span><br><span class="line">    DWORD   Size;             // 大小（没用）</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>导出表不是一张表，而是一个结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics; // 未使用</span><br><span class="line">    DWORD   TimeDateStamp; // 时间戳，表示当前PE文件（DLL）编译时的时间</span><br><span class="line">    WORD    MajorVersion; // 未使用</span><br><span class="line">    WORD    MinorVersion; // 未使用</span><br><span class="line">    DWORD   Name; // 当前导出表文件名字符串的地址</span><br><span class="line">    DWORD   Base; // 导出函数起始序号</span><br><span class="line">    DWORD   NumberOfFunctions; // 所有导出函数的个数(不一定准确)</span><br><span class="line">    DWORD   NumberOfNames; // 以函数名字导出的函数个数</span><br><span class="line">    DWORD   AddressOfFunctions;// 导出函数地址表RVA</span><br><span class="line">    DWORD   AddressOfNames; // 导出函数名称表RVA</span><br><span class="line">    DWORD   AddressOfNameOrdinals; // 导出函数序号表RVA</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>实际上，导出表指向了三张表（三个数组），分别是地址表、名称表、序号表。</p>
<ul>
<li><strong>Base</strong>（导出函数起始序号）：等于所有导出函数序号的最小值。</li>
<li><strong>NumberOfFunctions</strong>（所有导出函数的个数）：与地址表的成员个数相等，计算方式是(最大序号-最小序号+1)，但是并不一定等于实际导出函数的个数，比如当我有2个导出函数，使用def文件显式指定序号分别为1和3，那么NumberOfFunctions的值就为3，但是实际导出函数为2个。</li>
<li><strong>AddressOfFunctions</strong>（导出函数地址表）：每一个成员4个字节，存储一个导出函数的地址（可能为0）</li>
<li><strong>AddressOfNames</strong>（导出函数名称表）：每一个成员4个字节，存储一个导出函数的名字的地址</li>
<li><strong>AddressOfNameOrdinals</strong>（导出函数序号表）：一个成员2个字节，与名称表对应，记载对应函数的序号（实际为原序号-base）</li>
</ul>
<p>写4个导出函数，给其中两个分别分配2和7，构建dll，使用PE工具打开，观察导出表：</p>
<img src="/posts/20158/image-20250706204430469.png" class="" title="image-20250706204430469">

<p>导出函数实际有4个，但是NumberOfFunctions值为6（7-2+1），base为2（最小序号）。三表示意图：</p>
<img src="/posts/20158/draw.drawio.png" class="" title="draw.drawio">

<h2 id="寻找函数方法："><a href="#寻找函数方法：" class="headerlink" title="寻找函数方法："></a>寻找函数方法：</h2><h3 id="通过名称找："><a href="#通过名称找：" class="headerlink" title="通过名称找："></a>通过名称找：</h3><p>1、根据名称在名称表里面找。例如要找”plus”函数，将字符串与名称表里面表中地址指向的字符串进行以一比对，直到相同，记下索引（这里索引是3）。</p>
<p>2、根据上一步得到的索引，取序号表同索引处的值（这里是5）。</p>
<p>3、取地址表该索引处的地址，其为函数地址（RVA）。</p>
<h3 id="通过序号找："><a href="#通过序号找：" class="headerlink" title="通过序号找："></a>通过序号找：</h3><p>假设已知序号为7：</p>
<p>1、序号-base得到索引（这里是7-2&#x3D;5）</p>
<p>2、取地址表该索引处的地址，其为函数地址（RVA）。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>目标：</p>
<p>1、打印导出表所有信息</p>
<p>2、通过函数名查找函数FOA</p>
<p>3、通过序号查找函数FOA</p>
<p>思路：</p>
<p>1、由可选头得到结构体数组第一个元素</p>
<p>2、取第一个元素里面的VirtualAddress转FOA，在定位文件中导出表的位置</p>
<p>3、定位导出表中三个数组的位置</p>
<p>4、依据名称或序号找函数地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">IMAGE_EXPORT_DIRECTORY* export;</span><br><span class="line">int num=0;           //节数量</span><br><span class="line">int header_size=0;   // PE头大小</span><br><span class="line">int base=0;          // 基址</span><br><span class="line">int fsize=0,image_size=0; // 文件大小；文件映射的内存大小</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">	DWORD foa=0;</span><br><span class="line">    if(rva&lt;=header_size) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rva&lt;sheader[0].VirtualAddress) &#123;</span><br><span class="line">        printf(&quot;没有对应的foa!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &gt;= num) &#123;</span><br><span class="line">        printf(&quot;RVA超出范围!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">	return foa;</span><br><span class="line">&#125;</span><br><span class="line">void print_export()&#123;</span><br><span class="line">	printf(&quot;导出表信息:\n&quot;);</span><br><span class="line">	printf(&quot;Characteristics: %#010x\n&quot;, export-&gt;Characteristics);</span><br><span class="line">	printf(&quot;TimeDateStamp: %#010x\n&quot;, export-&gt;TimeDateStamp);</span><br><span class="line">	printf(&quot;MajorVersion: %#x\n&quot;, export-&gt;MajorVersion);</span><br><span class="line">	printf(&quot;MinorVersion: %#x\n&quot;, export-&gt;MinorVersion);</span><br><span class="line">	printf(&quot;Name: %#010x\n&quot;, export-&gt;Name);</span><br><span class="line">	printf(&quot;Base: %#x\n&quot;, export-&gt;Base);</span><br><span class="line">	printf(&quot;NumberOfFunctions: %#x\n&quot;, export-&gt;NumberOfFunctions);</span><br><span class="line">	printf(&quot;NumberOfNames: %#x\n&quot;, export-&gt;NumberOfNames);</span><br><span class="line">	printf(&quot;AddressOfFunctions: %#010x\n&quot;, export-&gt;AddressOfFunctions);</span><br><span class="line">	printf(&quot;AddressOfNames: %#010x\n&quot;, export-&gt;AddressOfNames);</span><br><span class="line">	printf(&quot;AddressOfNameOrdinals: %#010x\n\n&quot;, export-&gt;AddressOfNameOrdinals);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD SearchInName(char *name,unsigned char *file_buf)&#123;   // 通过名字查找函数地址(返回RVA)</span><br><span class="line">	int i=0;</span><br><span class="line">	DWORD* NameTable=(DWORD*)(RVA_to_FOA(export-&gt;AddressOfNames)+file_buf);</span><br><span class="line">	WORD* OrdinalTable=(WORD*)(RVA_to_FOA(export-&gt;AddressOfNameOrdinals)+file_buf);</span><br><span class="line">	DWORD* AddressTable=(DWORD*)(RVA_to_FOA(export-&gt;AddressOfFunctions)+file_buf);</span><br><span class="line">	for(i=0;i&lt;export-&gt;NumberOfNames;i++)&#123;</span><br><span class="line">		if(!strcmp(name,(char*)(RVA_to_FOA(NameTable[i])+file_buf)))&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==export-&gt;NumberOfNames)&#123;</span><br><span class="line">		printf(&quot;未找到该函数\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int index = (int)OrdinalTable[i];</span><br><span class="line">	return AddressTable[index];</span><br><span class="line">&#125;</span><br><span class="line">DWORD SearchInOrdinal(int index,unsigned char *file_buf)&#123;  // 通过序号查找</span><br><span class="line">	index -= export-&gt;Base;</span><br><span class="line">	DWORD* AddressTable=(DWORD*)(RVA_to_FOA(export-&gt;AddressOfFunctions)+file_buf);</span><br><span class="line">	return AddressTable[index];</span><br><span class="line">&#125;</span><br><span class="line">void Print_All_Function(unsigned char *file_buf)&#123;</span><br><span class="line">    DWORD* NameTable=(DWORD*)(RVA_to_FOA(export-&gt;AddressOfNames)+file_buf);</span><br><span class="line">	WORD* OrdinalTable=(WORD*)(RVA_to_FOA(export-&gt;AddressOfNameOrdinals)+file_buf);</span><br><span class="line">	DWORD* AddressTable=(DWORD*)(RVA_to_FOA(export-&gt;AddressOfFunctions)+file_buf);</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    printf(&quot;序号   函数名     FOA    RVA\n&quot;);</span><br><span class="line">    for(i=0;i&lt;export-&gt;NumberOfFunctions;i++)&#123;</span><br><span class="line">        if(AddressTable[i]==0) continue;</span><br><span class="line">        for(j=0;j&lt;export-&gt;NumberOfNames;j++)&#123;</span><br><span class="line">            if(i==OrdinalTable[j])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j==export-&gt;NumberOfNames) printf(&quot;%d    NULL    %#x    %#x\n&quot;,i+export-&gt;Base,RVA_to_FOA(AddressTable[i]),AddressTable[i]);</span><br><span class="line">        else printf(&quot;%d    %s    %#x     %#x\n&quot;,i+export-&gt;Base,(char*)(RVA_to_FOA(NameTable[j])+file_buf),RVA_to_FOA(AddressTable[i]),AddressTable[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // if(argc != 2) &#123;</span><br><span class="line">    //     printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">    //     return 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    const char* pe_path = &quot;dlltest.dll&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize);</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *offset=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)offset;</span><br><span class="line">    offset+=dos-&gt;e_lfanew+4;  // 定位文件头</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)offset;</span><br><span class="line">    num = fheader-&gt;NumberOfSections;</span><br><span class="line">    offset+=20;      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)offset;</span><br><span class="line">    header_size=oheader-&gt;SizeOfHeaders;</span><br><span class="line">    base=oheader-&gt;ImageBase;</span><br><span class="line">    image_size = oheader-&gt;SizeOfImage;</span><br><span class="line">    offset += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    int size = num * sizeof(IMAGE_SECTION_HEADER);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)offset;</span><br><span class="line">	DWORD export_rva = oheader-&gt;DataDirectory[0].VirtualAddress;</span><br><span class="line">	DWORD export_foa = RVA_to_FOA(export_rva);</span><br><span class="line">	if(export_foa == 0) &#123;</span><br><span class="line">		printf(&quot;导出表RVA转换失败\n&quot;);</span><br><span class="line">		free(file_buf);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	export = (IMAGE_EXPORT_DIRECTORY*)(file_buf + export_foa);</span><br><span class="line">	print_export();</span><br><span class="line">    Print_All_Function(file_buf);</span><br><span class="line">	int flag;</span><br><span class="line">	char s[20];</span><br><span class="line">	DWORD address=0;</span><br><span class="line">	int ord=0;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">        printf(&quot;请输入你需要进行的操作（使用名字查找选择1,使用序号查找选择2,退出选择0）:\n&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;flag);</span><br><span class="line">        switch(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            case 1:&#123;</span><br><span class="line">                printf(&quot;请输入函数名:&quot;);</span><br><span class="line">				scanf(&quot;%s&quot;,s);</span><br><span class="line">				address = SearchInName(s,file_buf);</span><br><span class="line">				printf(&quot;函数%s的RVA为%#010x,FOA为%#010x\n&quot;,s,address,RVA_to_FOA(address));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 2:&#123;</span><br><span class="line">				printf(&quot;请输入序号:&quot;);</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;ord);</span><br><span class="line">                address = SearchInOrdinal(ord,file_buf);</span><br><span class="line">				printf(&quot;序号为%d的函数的RVA为%#010x,FOA为%#010x\n&quot;,ord,address,RVA_to_FOA(address));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default:</span><br><span class="line">                free(file_buf);</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>库文件的编写</title>
    <url>/posts/61633/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h1><h2 id="生成方法："><a href="#生成方法：" class="headerlink" title="生成方法："></a>生成方法：</h2><p>在VS2022里面创建项目，选择生成静态库，此时程序会自动生成4个文件，分别是framework.h、pch.h、pch.cpp和一个项目名的cpp文件，前三个都是用来提高编译效率的，不用管。自己创建一个.h文件。</p>
<p>需要编辑两个文件，一个是头文件(h)，一个是源代码文件（c或cpp）。</p>
<ul>
<li>h文件里面存放导出函数的声明</li>
<li>c文件里面存放导出函数的具体实现</li>
</ul>
<p>如：</p>
<p>h文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once  //注：这个是为了防止头文件被多次包含而重复定义</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus   //这里是为了防止C++名称修饰（如果检测到是C++，则声明用C的方法包装）（一定要有，否则函数名称会改变）</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">	int add(int a, int b);</span><br><span class="line">	int sub(int a, int b);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>c文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;framework.h&quot;</span><br><span class="line">#include &quot;libtest.h&quot;</span><br><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行会生成一个.lib文件（实现），而之前创建的.h文件（声明）也需要用到</p>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><ol>
<li>需要包含头文件（让编译器知道函数的声明在哪）</li>
<li>显式指定库文件（让编译器知道函数的实现在哪）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&quot;libtest.h&quot;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;libtest.lib&quot;)</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int a = 1, b = 3;</span><br><span class="line">	printf(&quot;%d&quot;, add(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>静态链接库的特点是会在编译阶段直接将导出函数代码镶嵌进入目标程序中，因此一旦编译完成，目标程序不再需要该库文件，而且一旦修改了静态链接库，就需要重新编译目标程序，这与动态链接库不同。</p>
<p>同时，由于是将代码镶嵌入目标程序，因此无法通过反汇编分辨函数是从静态库导入的函数还是自己编写的。</p>
<p>如果多个程序都使用了同一个静态链接库里的函数，那么这些程序之间就会有很多重复的代码，十分浪费磁盘空间。</p>
<p>我们平常使用的包括printf、strcmp等函数都使用了静态链接库，不需要显示指定库文件是因为编程软件帮我们做了这些事。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>1、MSVC编译器的静态库文件是lib，但是GCC的静态库文件是.a文件！！！因此：</p>
<ul>
<li>在VS2022生成的lib文件在GCC编译器下不兼容，如果使用gcc链接lib文件，会出现“无法解析的外部符号”这样的错误。</li>
<li>64位的lib文件也与32位编译器不兼容（VS里面x64生成64位程序，x86生成32位程序）</li>
</ul>
<p>2、由于C++支持函数重载（支持同名函数不同参数），故其启用了名称修饰（即对函数名进行修饰），可通过工具-&gt;命令行-&gt;开发者命令提示，然后输入</p>
<p><code>dumpbin /SYMBOLS 库名字.lib</code>查看函数名称。</p>
<img src="/posts/61633/image-20250705170230840.png" class="" title="image-20250705170230840">

<p>可以看到启用了名称修饰后函数名称变化了。而C不支持函数重载，故C编译器链接此库时会出现“无法解析的外部符号add”这样的错误，c++编译器能正常链接。</p>
<p>为了兼容C，我们在头文件需要加上一个声明，即extern “C”，这代表我需要使用C的方法来编译，这样生成的库文件就未启用名称修饰。此时函数名称：</p>
<img src="/posts/61633/image-20250705171041271.png" class="" title="image-20250705171041271">

<p>这个库可被C和C++使用（但是不支持函数重载）</p>
<h1 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h1><h2 id="生成方法：-1"><a href="#生成方法：-1" class="headerlink" title="生成方法："></a>生成方法：</h2><h3 id="正常导出："><a href="#正常导出：" class="headerlink" title="正常导出："></a>正常导出：</h3><p>在VS2022里面创建动态链接库项目，程序一样会生成4个文件，与静态链接库不同的是头文件和源代码文件不同：</p>
<p>dlltest.h：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">	_declspec(dllexport) int __stdcall add(int a, int b);</span><br><span class="line">	_declspec(dllexport) int __stdcall sub(int a, int b);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这里的extern “C”也是声明使用C语言的方式编译，防止C++名称修饰；而_declspec(dllexport)则是声明这个是导出函数，可以被其他程序调用；这个”stdcall”是调用约定，代表被调函数清理堆栈，可以不填（默认是cdecl，调用者清理堆栈）；</p>
<p>dlltest.cpp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;dlltest.h&quot;</span><br><span class="line"></span><br><span class="line">int __stdcall add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __stdcall sub(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会生成一个dll和一个lib文件。</p>
<ul>
<li>dll文件：导出函数实际实现</li>
<li>lib文件：这个不是前面的静态链接库文件，而是“导入库”文件。在编译链接时提供 DLL 中导出函数的符号信息和位置。仅用于隐式链接（简化调用方式），编译完成后不再需要。</li>
</ul>
<h3 id="隐藏函数名导出（序号导出）："><a href="#隐藏函数名导出（序号导出）：" class="headerlink" title="隐藏函数名导出（序号导出）："></a>隐藏函数名导出（序号导出）：</h3><p>先创建一个.def文件（可以通过改名创建），然后填入如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">EXPORTS			// 这一句一定要有</span><br><span class="line">add @1			// @1代表分配序号1给add</span><br><span class="line">sub @2 NONAME   // NONAME代表不暴露函数名字，如果使用了NONAME就必须指定序号，否则会报语法错误</span><br></pre></td></tr></table></figure>

<p>然后右键项目名-&gt;项目属性 → 链接器 → 输入 → 模块定义文件，输入.def文件的名字。</p>
<p>可以通过应用depends来查看dll信息：</p>
<img src="/posts/61633/image-20250705221729314.png" class="" title="image-20250705221729314">

<p>可以看到第二个函数名字被隐藏了。这种只有序号的函数要显示链接来使用。</p>
<p><strong>序号分配问题：</strong></p>
<p>经过我的测试发现，未使用def文件显示分配的函数，他们的序号是按函数名称英文字母顺序来指定的，与函数出现顺序无关，例如：</p>
<img src="/posts/61633/image-20250706154504704.png" class="" title="image-20250706154504704">

<p>再或者：</p>
<img src="/posts/61633/image-20250706154647403.png" class="" title="image-20250706154647403">

<p>def文件里面指定的序号优先级最高，而且编译器默认分配的序号从def显式指定序号的最小值开始指定。（例如我这里指定了sub是2，plus是4）</p>
<img src="/posts/61633/image-20250706155621606.png" class="" title="image-20250706155621606">

<h2 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h2><h3 id="一、隐式链接："><a href="#一、隐式链接：" class="headerlink" title="一、隐式链接："></a>一、隐式链接：</h3><p>C语言用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;dlltest.lib&quot;)</span><br><span class="line"></span><br><span class="line">_declspec(dllimport) int _stdcall add(int a, int b);</span><br><span class="line">_declspec(dllimport) int _stdcall sub(int a, int b);</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a = 1, b = 3;</span><br><span class="line">	printf(&quot;%d&quot;, add(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib,&quot;dlltest.lib&quot;)</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; _declspec(dllimport) int _stdcall add(int a, int b);</span><br><span class="line">extern &quot;C&quot; _declspec(dllimport) int _stdcall sub(int a, int b);</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a = 1, b = 3;</span><br><span class="line">	printf(&quot;%d&quot;, add(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：C语言不需要也不支持extern “C”关键字，因为它默认就不存在名称修饰</p>
<p><strong>也可以创建一个头文件，将函数声明写进去，然后再包含这个头文件</strong></p>
<h3 id="二、显式链接"><a href="#二、显式链接" class="headerlink" title="二、显式链接"></a>二、显式链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int (*func)(int, int);  // 定义函数指针</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	func Plus;</span><br><span class="line">	HINSTANCE hModule = LoadLibrary(TEXT(&quot;dlltest.dll&quot;));  //载入dll，TEXT宏确保Unicode兼容性</span><br><span class="line">	Plus = (func)GetProcAddress(hModule, &quot;add&quot;);   // 获取函数地址（函数名导入）</span><br><span class="line">	// Plus = (func)GetProcAddress(hModule, MAKEINTRESOURCEA(1));  //通过序号导入</span><br><span class="line">	int a = 1, b = 3;</span><br><span class="line">	printf(&quot;%d&quot;, Plus(a, b));</span><br><span class="line">	FreeLibrary(hModule);  // 卸载dll</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MAKEINTRESOURCEA(1)，这个宏将整数转换为一个字符串指针，但该指针并不指向真正的字符串，而是将序号值直接放在指针值中。由于Windows系统在解析时会检查指针的高位是否为0（即指针值在0~65535之间），如果是，就认为是资源标识符（序号），否则就是字符串指针。</p>
<h3 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h3><ol>
<li>隐式链接启动时载入所有dll，显式链接在程序执行阶段，按程序需要载入dll</li>
<li>显式链接灵活，可在使用完后卸载dll释放空间，且无需导入库</li>
</ol>
]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>招新赛wp</title>
    <url>/posts/52115/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h1><h2 id="出题流程"><a href="#出题流程" class="headerlink" title="出题流程"></a>出题流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">/*初始化函数*/</span><br><span class="line">void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    unsigned char k[256] = &#123; 0 &#125;;</span><br><span class="line">    unsigned char tmp = 0;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = (j + s[i] + k[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[i]和s[j]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">/*加解密*/</span><br><span class="line">void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 1, j = 0, t = 0;  //将i初始值魔改为1</span><br><span class="line">    unsigned long k = 0;</span><br><span class="line">    unsigned char tmp;</span><br><span class="line">    for (k = 0; k&lt;Len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i = (i + 1) % 256;</span><br><span class="line">        j = (j + s[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[x]和s[y]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t = (s[i] + s[j]) % 256;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int __cdecl encode(char str[])&#123;</span><br><span class="line">	unsigned char *s;</span><br><span class="line">	s=(unsigned char*)str;</span><br><span class="line">    for(int i=0;i&lt;28;i++)&#123;</span><br><span class="line">        for(int j=21;j&lt;40 ;j+=2)&#123;</span><br><span class="line">            if(s[i]&amp;1==1)</span><br><span class="line">                s[i]^=j;</span><br><span class="line">            else</span><br><span class="line">                s[i]^=j+2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 28;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	unsigned char data[]=&#123;0x52,0xd1,0xd4,0x40,0xad,0xf9,0xa7,0x75,0x67,0x11,0x25,0x83,0xcd,0x10,0x62,0x61,0xa6,0xb6,0x74,0x94,0x4f,0x6f,0xb3,0xdd,0x94,0x33,0xd3,0x8b&#125;;</span><br><span class="line">	printf(&quot;请输入你的flag:&quot;);</span><br><span class="line">	unsigned char str[29];</span><br><span class="line">	scanf(&quot;%s&quot;,str);</span><br><span class="line">	int len=strlen((char*)str);</span><br><span class="line">	unsigned char s[256]=&#123;0&#125;;</span><br><span class="line">	unsigned char k[9]=&quot;Real-Key&quot;;</span><br><span class="line">	rc4_init(s,k,8);</span><br><span class="line">	rc4_crypt(s,str,len);</span><br><span class="line">//	encode1(str,28);</span><br><span class="line">	for(i=0;i&lt;len;i++)</span><br><span class="line">		if(str[i]!=data[i])&#123;</span><br><span class="line">			printf(&quot;wrong!\n&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	printf(&quot;right!!!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br><span class="line">__attribute__((constructor)) void hook()&#123; </span><br><span class="line">		__asm__ __volatile__ (  //花指令</span><br><span class="line">			&quot;jz 1f\n\t&quot;</span><br><span class="line">			&quot;jnz 1f\n\t&quot;</span><br><span class="line">			&quot;.byte 0x22\n\t&quot;</span><br><span class="line">			&quot;1:\n\t&quot;</span><br><span class="line">    		&quot;call 1f\n\t&quot;              // 调用当前标签（向后引用）</span><br><span class="line">    		&quot;.byte 0xe8\n\t&quot;           // 插入机器码0xE8（call指令的Opcode）</span><br><span class="line">    		&quot;1:\n\t&quot;                   // 定义局部标签</span><br><span class="line">    		&quot;add $8, (%%esp)\n\t&quot;     // </span><br><span class="line">    		&quot;.byte 0x36\n\t&quot;</span><br><span class="line">    		&quot;ret\n\t&quot;</span><br><span class="line">    		&quot;.byte 0xe8&quot;               // 再次插入0xE8</span><br><span class="line">    		:                          // 无输出操作数</span><br><span class="line">    		:                          // 无输入操作数</span><br><span class="line">    		: &quot;memory&quot;, &quot;esp&quot;, &quot;cc&quot;    // 声明破坏列表：内存、栈指针、标志寄存器</span><br><span class="line">		);</span><br><span class="line">        // 步骤4：取消函数地址保护</span><br><span class="line">        DWORD oldProtect;  // 旧保护属性</span><br><span class="line">        VirtualProtect((LPVOID)strlen,0x1000,PAGE_EXECUTE_READWRITE,&amp;oldProtect);</span><br><span class="line"></span><br><span class="line">        // 步骤5：获取自定义函数地址</span><br><span class="line">        byte* funcAddr = (byte*)encode;</span><br><span class="line">        byte* strlen_add = (byte*)strlen;</span><br><span class="line"></span><br><span class="line">        // 步骤6：跳转到自定义函数</span><br><span class="line">        __asm__ __volatile__ (</span><br><span class="line">    		&quot;movl %0, %%eax \n\t&quot;</span><br><span class="line">		    &quot;movl %1, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;subl %%eax, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;subl $5, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;movb $0xe9, (%%eax) \n\t&quot;</span><br><span class="line">		    &quot;movl %%ebx, 1(%%eax)&quot;</span><br><span class="line">		    : /* 无输出操作数 */</span><br><span class="line">		    : &quot;r&quot; (strlen_add), &quot;r&quot; (funcAddr)  // 输入操作数</span><br><span class="line">		    : &quot;eax&quot;, &quot;ebx&quot;, &quot;memory&quot;            // 破坏列表</span><br><span class="line">		);</span><br><span class="line">         DWORD floadprotect;</span><br><span class="line">         VirtualProtect((LPVOID)strlen,0x1000,oldProtect,&amp;floadprotect);</span><br><span class="line">&#125;注：此代码内联汇编是对32位寄存器操作，因此只能使用32位编译器编译</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>第一部分：魔改的RC4，将加密部分的i初始魔改为1</p>
<p>第二部分：hook strcmp函数，使用GCC扩展属性__attribute__((constructor))将hook函数标记为全局函数，先于main函数执行</p>
<p><strong>注：三种使函数先于main函数执行的方法：</strong></p>
<p>1、TLS函数</p>
<p>2、使用GCC扩展属性__attribute__((constructor))，使用方法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((constructor)) void function()</span><br></pre></td></tr></table></figure>

<p>3、使用全局变量调用函数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int a=function();</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这段代码得到的exe文件，我再用另一种方式hook（手动hook），即利用xdbg修改hook函数开头几个字节，使其跳转到一个空白处，再在空白处写入被覆盖的代码，最后跳回hook函数：</p>
<img src="/posts/52115/image-20250425205801010.png" class="" title="image-20250425205801010">

<img src="/posts/52115/image-20250425210041906.png" class="" title="image-20250425210041906">

<p>这样做的目的，就是让IDA分析的hook函数是断开的，从而无法反编译为伪代码，增加分析难度。</p>
<p>最后，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strip +文件名</span><br></pre></td></tr></table></figure>

<p>把文件符号表去除，这样函数名就不会是“hook”，就得不到提示。</p>
<p>最后hook函数的效果🥱:</p>
<img src="/posts/52115/image-20250425210918537.png" class="" title="image-20250425210918537">

<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>打开观察main函数</p>
<img src="/posts/52115/image-20250425211345949.png" class="" title="image-20250425211345949">

<p>是一个魔改的rc4加密，魔改的是加密部分的索引初始值</p>


<p>解密会发现得到的并非flag，而是一串乱码。逻辑看起来确实也很简单，并没有出现其他加密。这个时候就要猜是不是有函数被hook了，一般而言，hook函数都要引用被Hook的函数，因此可以通过交叉引用判断某个函数是否被hook。对strlen函数交叉引用：</p>
<img src="/posts/52115/image-20250425212547314.png" class="" title="image-20250425212547314">

<p>第一个列出的函数是启动函数，系统自带的，不需要我们分析；后面几行有点奇怪，跟进去看看：</p>
<img src="/posts/52115/image-20250425213138620.png" class="" title="image-20250425213138620">

<p>首先定位汇编代码，有vitualprotect函数和strlen函数，说明很可能使用了Inline hook。想要反编译代码，但是函数开头既有花指令又有一个莫名奇妙的jmp</p>
<img src="/posts/52115/image-20250425213356338.png" class="" title="image-20250425213356338">

<p>跟进这个sub_401B43看看</p>
<img src="/posts/52115/image-20250425213536378.png" class="" title="image-20250425213536378">

<p>这个函数开头是正常的栈帧调用，然后预留局部变量空间，最后跳转到4019E2地址处，这个地址就是上面4019DD函数jmp后的第一个指令的地址，所以这里也是一个Inline hook，只不过这个是手动的，作用就是把4019DD函数一分为二，导致IDA无法识别函数后半段。</p>
<p>程序流程图为：</p>
<img src="/posts/52115/image-20250425214525222.png" class="" title="image-20250425214525222">

<p>想要IDA重新正确识别，可以在xdbg里面修改，也可直接在IDA里面修改，这里选择在IDA里面修改：</p>
<p>1、先把汇编指令提取出来：</p>
<img src="/posts/52115/image-20250425214845634.png" class="" title="image-20250425214845634">

<p>2、右键-&gt;pathing-&gt;change bytes，把刚才复制的硬编码粘贴上去，把从jmp一直到程序回来的位置的数据覆盖掉</p>
<img src="/posts/52115/image-20250425215005936.png" class="" title="image-20250425215005936">

<img src="/posts/52115/image-20250425215339751.png" class="" title="image-20250425215339751">

<p>接下来去花指令，一共有两个花指令：</p>
<p>第一个：</p>
<img src="/posts/52115/image-20250425220627820.png" class="" title="image-20250425220627820">

<p>第二个：</p>




<img src="/posts/52115/image-20250425220947082.png" class="" title="image-20250425220947082">

<p>得到伪代码</p>
<img src="/posts/52115/image-20250425221612166.png" class="" title="image-20250425221612166">

<p>这里是把strlen函数hook为了sub_401718函数，跟进去看看：</p>
<img src="/posts/52115/image-20250425221706733.png" class="" title="image-20250425221706733">

<p>这个加密函数看起来挺简单，但实际上并不容易，它每一次根据数据的奇偶性来决定，异或的目标。看起来我们根据加密后的数据无法判断他到底是走了哪条路径，那就无法逆向（当然，爆破也行）。但是实际上，j每一次循环都是奇数，j+2也是奇数，奇数^奇数&#x3D;偶数，偶数^奇数&#x3D;奇数。假如数据加密前是奇数，那么加密后会变为偶数；假如数据加密前是偶数，那么加密后变为奇数。反过来假如加密后是奇数，那么加密前是偶数，与j+2异或得到加密前的数据；如果加密后是偶数，那么加密前是奇数，与j异或得到加密前的数据。</p>
<p>解密代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    unsigned char k[256] = &#123; 0 &#125;;</span><br><span class="line">    unsigned char tmp = 0;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = (j + s[i] + k[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[i]和s[j]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 1, j = 0, t = 0;  //将i初始值魔改为1</span><br><span class="line">    unsigned long k = 0;</span><br><span class="line">    unsigned char tmp;</span><br><span class="line">    for (k = 0; k&lt;Len; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i = (i + 1) % 256;</span><br><span class="line">        j = (j + s[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[x]和s[y]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t = (s[i] + s[j]) % 256;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void decode1(unsigned char s[],int len)&#123;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        for(int j=39;j&gt;20;j-=2)&#123;</span><br><span class="line">            if(s[i]&amp;1==1)</span><br><span class="line">                s[i]^=j+2;</span><br><span class="line">            else</span><br><span class="line">                s[i]^=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned char flag[]=&#123;0x52,0xd1,0xd4,0x40,0xad,0xf9,0xa7,0x75,0x67,0x11,0x25,0x83,0xcd,0x10,0x62,0x61,0xa6,0xb6,0x74,0x94,0x4f,0x6f,0xb3,0xdd,0x94,0x33,0xd3,0x8b&#125;;</span><br><span class="line">    int len=28;</span><br><span class="line">    unsigned char key[]=&quot;Real-Key&quot;;</span><br><span class="line">    unsigned char s[256]=&#123;0&#125;;</span><br><span class="line">    rc4_init(s,key,8);  </span><br><span class="line">    rc4_crypt(s,flag,28); </span><br><span class="line">    int i;</span><br><span class="line">    decode1(flag,len);</span><br><span class="line">    for(i=0;i&lt;28;i++)&#123;</span><br><span class="line">		printf(&quot;%c&quot;,flag[i]);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;//FCTF&#123;dasgygfushfhihsfhsufbj&#125;</span><br></pre></td></tr></table></figure>

<h1 id="poetry"><a href="#poetry" class="headerlink" title="poetry"></a>poetry</h1><h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;debugapi.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">// 检查是否为UTF-8汉字的首字节</span><br><span class="line">int is_chinese(unsigned char c) &#123;</span><br><span class="line">    return (c &gt;= 0xE4 &amp;&amp; c &lt;= 0xE9);  // 对应三字节编码的汉字首字节</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查是否为UTF-8格式的汉字句号（0xE3 0x80 0x82）</span><br><span class="line">int is_period(const unsigned char* buf, int pos) &#123;</span><br><span class="line">    return (buf[pos] == 0xE3 &amp;&amp; buf[pos+1] == 0x80 &amp;&amp; buf[pos+2] == 0x82);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int file_operation(char key[]) &#123;</span><br><span class="line">    unsigned char data[]=&#123;0xa3,0xcb,0xff,0xae,0xb8,0xb2,0xd5,0xb6&#125;;</span><br><span class="line"></span><br><span class="line">    // 读取文件内容</span><br><span class="line">    FILE* fp = fopen(&quot;poetry.txt&quot;, &quot;rb&quot;);</span><br><span class="line">    if (!fp) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(fp, 0, SEEK_END);//将指针设置到文件尾</span><br><span class="line">    long size = ftell(fp);//获取文件字节数</span><br><span class="line">    fseek(fp, 0, SEEK_SET);//指针重新设置回文件头</span><br><span class="line"></span><br><span class="line">    unsigned char* buf = (unsigned char*)malloc(size + 1);</span><br><span class="line">    fread(buf, 1, size, fp);</span><br><span class="line">    buf[size] = &#x27;\0&#x27;;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    // 处理内容</span><br><span class="line">    char result[size * 3 + 1];  // 预分配最大可能空间</span><br><span class="line">    int result_len = 0;</span><br><span class="line">    int count=0;</span><br><span class="line"></span><br><span class="line">    //接下来这段其实就是读取文件中每一个&quot;。&quot;前的一个汉字。utf-8里汉字占3个字节</span><br><span class="line">    for (int i = 0; i &lt; size; ) &#123;</span><br><span class="line">        // 检测句号（3字节）</span><br><span class="line">        if(count==300) break;//防止动调时死循环</span><br><span class="line">        if (i &lt;= size - 3 &amp;&amp; is_period(buf, i)) &#123;//检测句号</span><br><span class="line">            // 向前查找汉字（3字节）</span><br><span class="line">            if (i &gt;= 3 &amp;&amp; is_chinese(buf[i-3])) &#123;</span><br><span class="line">                memcpy(result + result_len, &amp;buf[i-3], 3);</span><br><span class="line">                result_len += 3;</span><br><span class="line">            &#125;</span><br><span class="line">            i += 3;  // 跳过句号</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i+=1^IsDebuggerPresent();//反调试：在动调时i不变，不在动调i++</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result[result_len] = &#x27;\0&#x27;;</span><br><span class="line">    for(int i=0;i&lt;8;i++)</span><br><span class="line">        if(((unsigned char)key[i]^(unsigned char)result[i])!=data[i])</span><br><span class="line">            exit(0);</span><br><span class="line">    free(buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void tea_encrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k1,k2,k3;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x9E3779B9,sum=0;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=delta;</span><br><span class="line">		v0+=((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">		v1+=((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); </span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">void rc4_init(unsigned char*s, char* key)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    unsigned char k[256] = &#123; 0 &#125;;</span><br><span class="line">    unsigned char tmp = 0;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = (unsigned char)key[i%8];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = (j + s[i] + k[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];//交换s[i]和s[j]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">/*加解密*/</span><br><span class="line">void rc4_crypt(char* key,unsigned char*key2,  unsigned long Len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0, t = 0;</span><br><span class="line">    unsigned long k = 0;</span><br><span class="line">    unsigned char tmp;</span><br><span class="line">    unsigned char s[256];</span><br><span class="line">    rc4_init(s,key);</span><br><span class="line">    for(k = 0; k&lt;16; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i = (i + 1) % 256;</span><br><span class="line">        j = (j + s[i]) % 256;</span><br><span class="line">        tmp = s[i]^IsDebuggerPresent();</span><br><span class="line">        s[i] = s[j];//交换s[x]和s[y]</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t = (s[i] + s[j]) % 256;</span><br><span class="line">        key2[k] = s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Hello, Comrade!!!\n&quot;);</span><br><span class="line">    printf(&quot;Please enter your key and start the struggle!!!\n&quot;);</span><br><span class="line">    char key[9];</span><br><span class="line">    scanf(&quot;%s&quot;,key);</span><br><span class="line">    file_operation(key);  //验证key</span><br><span class="line">    printf(&quot;please input your flag:\n&quot;);</span><br><span class="line">    char flag[49];</span><br><span class="line">    scanf(&quot;%s&quot;,flag);</span><br><span class="line">    unsigned char key2[16];</span><br><span class="line">    rc4_crypt(key,key2,20);  //利用rc4加密生成一个新的key</span><br><span class="line">    //接下来是SMC</span><br><span class="line">	int n; DWORD floadprotect;</span><br><span class="line">	byte* funcAddr = (byte*)tea_encrypt;//函数地址</span><br><span class="line">	VirtualProtect(&amp;tea_encrypt, 0xDF, PAGE_EXECUTE_READWRITE, &amp;floadprotect);//第二个参数为大小,</span><br><span class="line">	for (int i = 0; i &lt; 0xDF; i++)//解密操作 也需要修正大小 这里是修正后的</span><br><span class="line">		funcAddr[i] ^= 0x12;</span><br><span class="line">    for(int i=0;i&lt;48;i+=8)&#123;</span><br><span class="line">        tea_encrypt((uint32_t*)&amp;flag[i],(uint32_t*)key2); //tea加密</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char data[]=&#123;0x91,0xe5,0x27,0x31,0x2d,0x8c,0xf1,0x61,0x2,0xd8,0xf6,0xea,0xb4,</span><br><span class="line">                          0xba,0xf,0x2,0x97,0x22,0xa8,0x1a,0x1c,0xca,0x83,0x28,0xb1,0x3c,</span><br><span class="line">                          0x67,0x33,0xef,0x25,0x57,0x82,0x7f,0xc,0xac,0xf1,0x89,0xf6,0x45,</span><br><span class="line">                          0xae,0x49,0x53,0x3a,0xee,0x92,0xdd,0xb,0x48&#125;;</span><br><span class="line">    for(int i=0;i&lt;48;i++)&#123;</span><br><span class="line">        if((unsigned char)flag[i]!=data[i])</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;wrong!!!&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;right!!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>查找字符串定位到主函数</p>
<img src="/posts/52115/image-20250606232108750.png" class="" title="image-20250606232108750">

<p>查看file_operation函数</p>


<p>这个反调试不会直接退出，而是在检测到调试状态时使v10+&#x3D;0，也就是进入死循环，这样后面就没办法通过key的检验。前面一段操作是：以二进制形式读取文件，获取每一个句号前的一个汉字，将得到的汉字拼接为一个数组（一个汉字占3个字节）。将数组与输入的key进行异或，异或结果与数据进行比较。由于运行到第49行时12字节数组已经确定，所以可以直接动调获取。动调前可以采用keypatch绕过反调试：</p>
<img src="/posts/52115/image-20250525012703047.png" class="" title="image-20250525012703047">

<p>这里汇编代码的xor eax,1 其实就对应!IsDebuggerPresent()，因为eax寄存器存着函数返回值，在动调就返回1，1与1异或等于0，也就是v10+&#x3D;0，进入无限循环。想要绕过反调试，可以keypatch把1改为0，这样在调试时就不会进入无限循环。右键-&gt;keypatch</p>
<img src="/posts/52115/image-20250525013209303.png" class="" title="image-20250525013209303">

<p>点patch，然后edit-&gt;patch program-&gt;apply patches to…。然后开始动调获取数组v4的值（获取前8字节就行）：</p>
<img src="/posts/52115/image-20250606233149284.png" class="" title="image-20250606233149284">

<p>这个数组与明文异或可以得到密钥：FCTF2025</p>
<p>回到主函数	</p>
<img src="/posts/52115/image-20250606233507807.png" class="" title="image-20250606233507807">

<p>这里rc4传入输入的密钥，生成一个新的密钥v3，然后把v3传入loc_7FF7940217CF函数。rc4函数这里有一个反调试：</p>
<img src="/posts/52115/image-20250527090453821.png" class="" title="image-20250527090453821">

<p>看汇编段：</p>
<img src="/posts/52115/image-20250527090518668.png" class="" title="image-20250527090518668">

<p>这里反调试逻辑就是，当不在调试状态时，IsDebuggerPresent()返回0，0与任何数异或等于原数；如果在调试状态，那么IsDebuggerPresent()返回1，与1异或会导致值改变。汇编里面eax存IsDebuggerPresent()函数返回值，140001B16处如果直接加mov eax,1由于指令大小为5字节，大于原指令xor eax,ebx（2字节），会覆盖掉后面的指令，所以要选择两字节的指令，我这里选择改为mov eax,ebx：</p>
<img src="/posts/52115/image-20250527091813146.png" class="" title="image-20250527091813146">

<p>一样，要记得保存。loc_7FF7940217CF函数使用了SMC隐藏。动调修复函数，同时获取经过rc4加密后的新密钥（这里key输入刚才得到的FCTF2025）：</p>
<p>新密钥：</p>
<img src="/posts/52115/image-20250525014624013.png" class="" title="image-20250525014624013">

<p>修复后的函数：</p>
<img src="/posts/52115/image-20250525014757066.png" class="" title="image-20250525014757066">

<p>是一个tea加密，这里0x61C88647实际上是0x9E3779B9的反码，所以-0x61C88647实际上就是+0x9E3779B9。解密脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void decrypt(uint32_t* v,uint32_t* key)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t k0,k2,k3,k1;</span><br><span class="line">	uint32_t v0,v1;</span><br><span class="line">	v0=v[0],v1=v[1];</span><br><span class="line">	k0=key[0],k1=key[1],k2=key[2],k3=key[3];</span><br><span class="line">	uint32_t delta=0x9E3779B9,sum=0x9E3779B9*32;</span><br><span class="line">	for(int i=0;i&lt;32;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1-=((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);</span><br><span class="line">		v0-=((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);</span><br><span class="line">		sum-=delta;</span><br><span class="line">	&#125;</span><br><span class="line">	v[0]=v0,v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char s[]=&#123;0x91,0xe5,0x27,0x31,0x2d,0x8c,0xf1,0x61,0x2,0xd8,0xf6,0xea,0xb4,</span><br><span class="line">                      0xba,0xf,0x2,0x97,0x22,0xa8,0x1a,0x1c,0xca,0x83,0x28,0xb1,0x3c,</span><br><span class="line">                      0x67,0x33,0xef,0x25,0x57,0x82,0x7f,0xc,0xac,0xf1,0x89,0xf6,0x45,</span><br><span class="line">                      0xae,0x49,0x53,0x3a,0xee,0x92,0xdd,0xb,0x48&#125;;</span><br><span class="line">	unsigned char key[16]=&#123;0x28, 0x28, 0x7B, 0x33, 0x76, 0x67, 0x9D, 0xCD, 0x69, 0x3F, </span><br><span class="line">  							0xA7, 0xD1, 0x40, 0x62, 0x3C, 0xE7&#125;;</span><br><span class="line">	for(int i=0;i&lt;48;i+=8)</span><br><span class="line">	&#123;</span><br><span class="line">		decrypt((uint32_t*)&amp;s[i],(uint32_t*)key);	</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;48;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%c&quot;,s[i]);	</span><br><span class="line">	&#125;	  </span><br><span class="line"> &#125;</span><br><span class="line"> //FCTF&#123;The_proletariat_all_over_the_world_unite!!&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">#define row 8  // 行</span><br><span class="line">#define col 6  // 列</span><br><span class="line">char path[100];  // 路径</span><br><span class="line">int len = 0;   //路径长度</span><br><span class="line">int map[48]=&#123;0&#125;;</span><br><span class="line">int num=0;</span><br><span class="line">void search(char s[],int temp[])&#123;</span><br><span class="line">	char table[]=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">	for(int i=0;i&lt;strlen(s);i++)&#123;</span><br><span class="line">		temp[i]=strchr(table,s[i])-table;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void creat_map(int a[])&#123;  //将8个十进制数转化为8个6比特二进制数，组成8*6的迷宫地图</span><br><span class="line">	int temp;</span><br><span class="line">	for(int i=0;i&lt;8;i++)&#123; //行</span><br><span class="line">		temp=a[i];</span><br><span class="line">		for(int j=5;j&gt;=0;j--)&#123;  //列</span><br><span class="line">			map[i*6+j]=temp&amp;1;</span><br><span class="line">			temp&gt;&gt;=1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int judge(char path[])&#123;  //检验是否符合通路</span><br><span class="line">	const char *s[] = &#123;</span><br><span class="line">        &quot;ddddsdssaassassddd&quot;,</span><br><span class="line">        &quot;ddddsdssaawaaasssssddddd&quot;,</span><br><span class="line">        &quot;ssdddsssassddd&quot;,</span><br><span class="line">        &quot;sssssssddddd&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        if (!strcmp(path, s[i])) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void find_road(int r, int c) &#123;</span><br><span class="line">    if (r &gt;= row || r &lt; 0 || c &gt;= col || c &lt; 0 || map[r * col + c] == 1)  return;  // 超出地图或撞上墙则返回</span><br><span class="line">    if (r * col + c == 47) &#123;   // 找到终点</span><br><span class="line">        if(!judge(path))</span><br><span class="line">		&#123;	</span><br><span class="line">			printf(&quot;wrong path!&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    map[r * col + c] = 1;  // 标记为已访问，防止重复访问</span><br><span class="line">    // 尝试四个方向</span><br><span class="line">    path[len++] = &#x27;d&#x27;;</span><br><span class="line">    find_road(r, c + 1);  // 右</span><br><span class="line">    path[--len] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">    path[len++] = &#x27;a&#x27;;</span><br><span class="line">    find_road(r, c - 1);  // 左</span><br><span class="line">    path[--len] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">    path[len++] = &#x27;s&#x27;;</span><br><span class="line">    find_road(r + 1, c);  // 下</span><br><span class="line">    path[--len] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">    path[len++] = &#x27;w&#x27;;</span><br><span class="line">    find_road(r - 1, c);  // 上</span><br><span class="line">    path[--len] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">    map[r * col + c] = 0;  // 回溯</span><br><span class="line">&#125;</span><br><span class="line">int zero_num()&#123;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=0;i&lt;48;i++)</span><br><span class="line">		if(map[i]==0) sum++;</span><br><span class="line">	return (sum==30)?1:0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int temp[8];</span><br><span class="line">	char s[14];</span><br><span class="line">	char input[14];</span><br><span class="line">	printf(&quot;请输入你的flag!!!:\n&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;,input);</span><br><span class="line">	int slen=strlen(input);</span><br><span class="line">	if(memcmp(&quot;FCTF&#123;&quot;,input,5)||input[slen-1]!=&#x27;&#125;&#x27;)&#123;</span><br><span class="line">		printf(&quot;wrong!!&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	memcpy(s,input+5,slen-6);</span><br><span class="line">	search(s,temp);</span><br><span class="line">	creat_map(temp);</span><br><span class="line">	if(!zero_num())</span><br><span class="line">	&#123; printf(&quot;map wrong!!!&quot;);return 0;&#125;</span><br><span class="line">	find_road(0,0);</span><br><span class="line">	if(num==4)</span><br><span class="line">		printf(&quot;right!!!&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">// FCTF&#123;BcCYbTXA&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/posts/1079/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="第一周：模拟队列管理"><a href="#第一周：模拟队列管理" class="headerlink" title="第一周：模拟队列管理"></a>第一周：模拟队列管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 队列的管理过程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 11</span><br><span class="line">typedef struct queue&#123;</span><br><span class="line">    int rear,front;</span><br><span class="line">    int arr[max];</span><br><span class="line">&#125;queue;</span><br><span class="line">void init(queue *q)&#123;  //队列初始化</span><br><span class="line">    q-&gt;front=q-&gt;rear=0;</span><br><span class="line">&#125;</span><br><span class="line">void print_queue(queue *q)&#123;  //打印队列</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;该队列为：\n&quot;);</span><br><span class="line">    for(i=q-&gt;front;i&lt;q-&gt;rear;i++) printf(&quot;%d &quot;,q-&gt;arr[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int is_full(queue *q)&#123;  //判满</span><br><span class="line">    return (q-&gt;rear+1)%max==q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line">int is_empty(queue *q)&#123;  //判空</span><br><span class="line">    return q-&gt;front==q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">queue *creat()&#123;  // 创建队列</span><br><span class="line">    int i,num,data;</span><br><span class="line">    queue *q;</span><br><span class="line">    q=(queue *)malloc(sizeof(queue));</span><br><span class="line">    init(q);</span><br><span class="line">    printf(&quot;请输入需要创建队列的个数:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        printf(&quot;请输入你需要插入的值:&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;data);</span><br><span class="line">        if(is_full(q)==1) &#123;printf(&quot;队列已满!/n&quot;);break;&#125;</span><br><span class="line">        q-&gt;arr[q-&gt;rear]=data;</span><br><span class="line">        q-&gt;rear=(q-&gt;rear+1)%max;</span><br><span class="line">    &#125;</span><br><span class="line">    return q;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q)&#123;  // 入队</span><br><span class="line">    int data;</span><br><span class="line">    printf(&quot;请输入你需要插入的值:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;data);</span><br><span class="line">    if(is_full(q)==1) &#123;printf(&quot;队列已满!/n&quot;);return;&#125;</span><br><span class="line">    q-&gt;arr[q-&gt;rear]=data;</span><br><span class="line">    q-&gt;rear=(q-&gt;rear+1)%max;</span><br><span class="line">&#125;</span><br><span class="line">int dequeue(queue *q)&#123;  // 出队</span><br><span class="line">    int data;</span><br><span class="line">    if(is_empty(q)) &#123;printf(&quot;队列为空!\n&quot;);return -1;&#125;</span><br><span class="line">    data=q-&gt;arr[q-&gt;front];</span><br><span class="line">    q-&gt;front=(q-&gt;front+1)%max;</span><br><span class="line">    printf(&quot;出队的元素为：%d\n&quot;,data);</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">void clear(queue *q)&#123;  // 清空队列</span><br><span class="line">    q-&gt;front=q-&gt;rear=0;</span><br><span class="line">&#125;</span><br><span class="line">void print_table()&#123;  // 打印操作表</span><br><span class="line">    printf(&quot;********************************\n&quot;);</span><br><span class="line">    printf(&quot;*1、新建                       *\n&quot;);</span><br><span class="line">    printf(&quot;*2、初始化                     *\n&quot;);</span><br><span class="line">    printf(&quot;*3、出队                       *\n&quot;);</span><br><span class="line">    printf(&quot;*4、入队                       *\n&quot;);</span><br><span class="line">    printf(&quot;*5、打印队列                   *\n&quot;);</span><br><span class="line">    printf(&quot;*6、清空队列                   *\n&quot;);</span><br><span class="line">    printf(&quot;*7、队列是否为满               *\n&quot;);</span><br><span class="line">    printf(&quot;*8、队列是否空                 *\n&quot;);</span><br><span class="line">    printf(&quot;*9、退出                       *\n&quot;);</span><br><span class="line">    printf(&quot;********************************\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x;</span><br><span class="line">    queue *q;</span><br><span class="line">    print_table();</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;请选择要进行的操作:&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        switch(x)&#123;</span><br><span class="line">            case 1:q=creat();</span><br><span class="line">                   print_queue(q);</span><br><span class="line">                   break;</span><br><span class="line">            case 2:init(q);</span><br><span class="line">                    printf(&quot;队列是空的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 3:dequeue(q);</span><br><span class="line">                    print_queue(q);</span><br><span class="line">                    break;</span><br><span class="line">            case 4:enqueue(q);</span><br><span class="line">                    print_queue(q);</span><br><span class="line">                    break;</span><br><span class="line">            case 5:print_queue(q);</span><br><span class="line">                    break;</span><br><span class="line">            case 6:clear(q);</span><br><span class="line">                    if(is_empty(q)) printf(&quot;队列是空的\n&quot;);</span><br><span class="line">                    else printf(&quot;队列不是空的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 7:if(is_full(q)) printf(&quot;队列是满的\n&quot;);</span><br><span class="line">                    else printf(&quot;队列不是满的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 8:if(is_empty(q)) printf(&quot;队列是空的\n&quot;);</span><br><span class="line">                    else printf(&quot;队列不是空的\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            case 9:exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三周：FCFS进程调度算法"><a href="#第三周：FCFS进程调度算法" class="headerlink" title="第三周：FCFS进程调度算法"></a>第三周：FCFS进程调度算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct Time &#123;</span><br><span class="line">    int hour;</span><br><span class="line">    int min;</span><br><span class="line">&#125; Time;</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">    Time arrive;</span><br><span class="line">    int zx;</span><br><span class="line">    Time start;</span><br><span class="line">    Time finish;</span><br><span class="line">    int zz;</span><br><span class="line">    float zzxs;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">typedef struct Q &#123;</span><br><span class="line">    Node* front;</span><br><span class="line">    Node* end;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">int compare(Time t1,Time t2)&#123;   //t1先到返回1，t2先到返回0</span><br><span class="line">	int x1=t1.hour * 60 + t1.min;</span><br><span class="line">	int x2=t2.hour * 60 + t2.min;</span><br><span class="line">	return x1&lt;=x2;</span><br><span class="line">&#125;</span><br><span class="line">void creat(Queue *q)&#123;</span><br><span class="line">	int num,i;</span><br><span class="line">    printf(&quot;请输入进程个数：\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">    printf(&quot;id   名字   到达时间   执行时间（分钟）\n&quot;);</span><br><span class="line">	Node *tmp=(Node *)malloc(sizeof(Node));</span><br><span class="line">	Node *p;</span><br><span class="line">	scanf(&quot;%d %s %d:%d %d&quot;, &amp;tmp-&gt;id, tmp-&gt;name,&amp;tmp-&gt;arrive.hour,&amp;tmp-&gt;arrive.min, &amp;tmp-&gt;zx);</span><br><span class="line">	tmp-&gt;next=NULL;</span><br><span class="line">	q-&gt;front=tmp;q-&gt;end=tmp;</span><br><span class="line">	for(i=0;i&lt;num-1;i++)&#123;</span><br><span class="line">		tmp=(Node *)malloc(sizeof(Node));</span><br><span class="line">		scanf(&quot;%d %s %d:%d %d&quot;, &amp;tmp-&gt;id, tmp-&gt;name, &amp;tmp-&gt;arrive.hour,&amp;tmp-&gt;arrive.min,&amp;tmp-&gt;zx);</span><br><span class="line">		tmp-&gt;next=NULL;</span><br><span class="line">		p=q-&gt;front;</span><br><span class="line">		if(compare(tmp-&gt;arrive,p-&gt;arrive)) &#123;tmp-&gt;next=q-&gt;front;q-&gt;front=tmp;&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			while(p-&gt;next!=NULL&amp;&amp;compare(p-&gt;next-&gt;arrive,tmp-&gt;arrive)) p=p-&gt;next;</span><br><span class="line">			tmp-&gt;next=p-&gt;next;p-&gt;next=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void print(Queue *q)&#123;</span><br><span class="line">	Node *tmp=q-&gt;front;</span><br><span class="line">	printf(&quot;模拟进程FCFS调度过程输出结果:\n&quot;);</span><br><span class="line">	printf(&quot;ID号 名字 到达时间 执行时间(分钟) 开始时间 完成时间 周转时间(分钟) 带权周转时间(系数)\n&quot;);</span><br><span class="line">	float _zz=0,_zzxs=0;</span><br><span class="line">	int num=0;</span><br><span class="line">	while(tmp!=NULL)&#123;</span><br><span class="line">		num++;</span><br><span class="line">		printf(&quot;%04d %-3s   %02d:%02d    %-12d  %02d:%02d  %02d:%02d   %-12d  %.2f\n&quot;, </span><br><span class="line">			tmp-&gt;id, tmp-&gt;name, tmp-&gt;arrive.hour,tmp-&gt;arrive.min,tmp-&gt;zx,tmp-&gt;start.hour,tmp-&gt;start.min,tmp-&gt;finish.hour,tmp-&gt;finish.min,tmp-&gt;zz,tmp-&gt;zzxs);</span><br><span class="line">		_zz+=tmp-&gt;zz;</span><br><span class="line">		_zzxs+=tmp-&gt;zzxs;</span><br><span class="line">		tmp=tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;系统平均周转时间为：%.2f\n&quot;,_zz/num);</span><br><span class="line">	printf(&quot;系统带权平均周转时间: %.2f\n&quot;,_zzxs/num);</span><br><span class="line">&#125;</span><br><span class="line">void calculate(Node *p)&#123; //计算时间</span><br><span class="line">	p-&gt;finish.hour=p-&gt;start.hour+(p-&gt;start.min+p-&gt;zx)/60;</span><br><span class="line">	p-&gt;finish.min=(p-&gt;start.min+p-&gt;zx)%60;</span><br><span class="line">	p-&gt;zz=(p-&gt;finish.hour*60+p-&gt;finish.min)-(p-&gt;arrive.hour*60+p-&gt;arrive.min);</span><br><span class="line">	p-&gt;zzxs=(p-&gt;zz*1.00)/p-&gt;zx;</span><br><span class="line">&#125;</span><br><span class="line">void fcfs(Queue *q)&#123;</span><br><span class="line">	Time t0;</span><br><span class="line">	Node *tmp;</span><br><span class="line">	tmp=q-&gt;front;</span><br><span class="line">	t0=tmp-&gt;arrive;</span><br><span class="line">	tmp-&gt;start=t0;</span><br><span class="line">	calculate(tmp);</span><br><span class="line">	t0=tmp-&gt;finish;</span><br><span class="line">	tmp=tmp-&gt;next;</span><br><span class="line">	while(tmp!=NULL)&#123;</span><br><span class="line">		if(compare(t0,tmp-&gt;arrive))  t0=tmp-&gt;arrive;</span><br><span class="line">		tmp-&gt;start=t0;</span><br><span class="line">		calculate(tmp);</span><br><span class="line">		t0=tmp-&gt;finish;</span><br><span class="line">		tmp=tmp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		printf(&quot;请输入操作：(1:开始进程; -1:结束进程):&quot;);</span><br><span class="line">		int flag;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;flag);</span><br><span class="line">		if(flag==-1) break;</span><br><span class="line">		Queue q;</span><br><span class="line">		q.end=q.front=NULL;</span><br><span class="line">		creat(&amp;q);</span><br><span class="line">		fcfs(&amp;q);</span><br><span class="line">		print(&amp;q);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 5001 p1 9:40 20</span><br><span class="line">// 5004 p4 10:10 10</span><br><span class="line">// 5005 p5 10:05 30</span><br><span class="line">// 5002 p2 9:55 15</span><br><span class="line">// 5003 p3 9:45 25</span><br></pre></td></tr></table></figure>

<h1 id="第四周：短进程优先调度"><a href="#第四周：短进程优先调度" class="headerlink" title="第四周：短进程优先调度"></a>第四周：短进程优先调度</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;			//注：此代码有点问题</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int hour;</span><br><span class="line">    int min;</span><br><span class="line">&#125; Time;</span><br><span class="line"></span><br><span class="line">typedef struct Process &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[10];</span><br><span class="line">    Time arrive;</span><br><span class="line">    int zx;</span><br><span class="line">    Time start;</span><br><span class="line">    Time finish;</span><br><span class="line">    int zz;</span><br><span class="line">    float zzxs;</span><br><span class="line">    struct Process* next;</span><br><span class="line">&#125; Process;</span><br><span class="line"></span><br><span class="line">//时间比较函数</span><br><span class="line">int time_cmp(Time a, Time b) &#123;</span><br><span class="line">    return (a.hour * 60 + a.min) - (b.hour * 60 + b.min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//增加指定分钟数</span><br><span class="line">Time add_mins(Time t, int mins) &#123;</span><br><span class="line">    int total = t.hour * 60 + t.min + mins;</span><br><span class="line">    return (Time)&#123;total / 60, total % 60&#125;;</span><br><span class="line">&#125;</span><br><span class="line">//时间差计算（分钟）</span><br><span class="line">int time_diff(Time end, Time start) &#123;</span><br><span class="line">    return (end.hour * 60 + end.min) - (start.hour * 60 + start.min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SJF调度核心算法</span><br><span class="line">void sjf_scheduler(Process** head, int n) &#123;</span><br><span class="line">    Process* scheduled_head = NULL;</span><br><span class="line">    Process* scheduled_tail = NULL;  // 新增尾指针</span><br><span class="line">    Time current_time = &#123;9, 40&#125;;</span><br><span class="line">    int processed = 0;</span><br><span class="line"></span><br><span class="line">    while (processed &lt; n) &#123;</span><br><span class="line">        Process **prev = head;</span><br><span class="line">        Process *sel = NULL;</span><br><span class="line">        int min_time = INT_MAX;</span><br><span class="line">        Process **prev_sel = NULL;</span><br><span class="line"></span><br><span class="line">        while (*prev) &#123;</span><br><span class="line">            if ((*prev)-&gt;start.hour == 0 &amp;&amp; </span><br><span class="line">                time_cmp((*prev)-&gt;arrive, current_time) &lt;= 0) &#123;</span><br><span class="line">                if ((*prev)-&gt;zx &lt; min_time) &#123;</span><br><span class="line">                    min_time = (*prev)-&gt;zx;</span><br><span class="line">                    sel = *prev;</span><br><span class="line">                    prev_sel = prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = &amp;(*prev)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sel) &#123;</span><br><span class="line">            // 设置进程时间</span><br><span class="line">            sel-&gt;start = (time_cmp(current_time, sel-&gt;arrive) &gt; 0) ? </span><br><span class="line">                        current_time : sel-&gt;arrive;</span><br><span class="line">            sel-&gt;finish = add_mins(sel-&gt;start, sel-&gt;zx);</span><br><span class="line">            sel-&gt;zz = time_diff(sel-&gt;finish, sel-&gt;arrive);</span><br><span class="line">            sel-&gt;zzxs = (float)sel-&gt;zz / sel-&gt;zx;</span><br><span class="line">            </span><br><span class="line">            current_time = sel-&gt;finish;</span><br><span class="line">            processed++;</span><br><span class="line">            </span><br><span class="line">            // 从原链表移除</span><br><span class="line">            if (prev_sel) &#123;</span><br><span class="line">                *prev_sel = sel-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 尾部插入</span><br><span class="line">            sel-&gt;next = NULL;</span><br><span class="line">            if (scheduled_head == NULL) &#123;</span><br><span class="line">                scheduled_head = scheduled_tail = sel;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scheduled_tail-&gt;next = sel;</span><br><span class="line">                scheduled_tail = sel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current_time.min++;</span><br><span class="line">            if (current_time.min &gt;= 60) &#123;</span><br><span class="line">                current_time.hour++;</span><br><span class="line">                current_time.min = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *head = scheduled_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int op, n;</span><br><span class="line">    Process *head = NULL;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        printf(&quot;请输入操作(1：开始进程调度；-1：结束进程)：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line">        </span><br><span class="line">        if(op == -1) break;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;请输入进程数：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;id号 名字 到达时间 执行时间\n&quot;);</span><br><span class="line">        for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">            Process *p = (Process*)malloc(sizeof(Process));</span><br><span class="line">            scanf(&quot;%d %s %d:%d %d&quot;, </span><br><span class="line">                 &amp;p-&gt;id, p-&gt;name, </span><br><span class="line">                 &amp;p-&gt;arrive.hour, &amp;p-&gt;arrive.min,</span><br><span class="line">                 &amp;p-&gt;zx);</span><br><span class="line">            p-&gt;start.hour = 0;  // 初始化开始时间</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            head = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sjf_scheduler(&amp;head, n);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;\n模拟短进程优先调度过程结果：\n&quot;);</span><br><span class="line">        printf(&quot;id号 名字 到达时间 执行时间(分钟) 开始时间 完成时间 周转时间(分钟) 带权周转系数\n&quot;);</span><br><span class="line">        </span><br><span class="line">        float total_zz = 0, total_zzxs = 0;</span><br><span class="line">        Process *p = head;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            printf(&quot;%-4d %-4s %02d:%02d %12d   %02d:%02d    %02d:%02d %15d %12.2f\n&quot;,</span><br><span class="line">                  p-&gt;id, p-&gt;name, </span><br><span class="line">                  p-&gt;arrive.hour, p-&gt;arrive.min,</span><br><span class="line">                  p-&gt;zx,</span><br><span class="line">                  p-&gt;start.hour, p-&gt;start.min,</span><br><span class="line">                  p-&gt;finish.hour, p-&gt;finish.min,</span><br><span class="line">                  p-&gt;zz, p-&gt;zzxs);</span><br><span class="line">            </span><br><span class="line">            total_zz += p-&gt;zz;</span><br><span class="line">            total_zzxs += p-&gt;zzxs;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;\n系统平均周转时间为：%.2f\n&quot;, total_zz / n);</span><br><span class="line">        printf(&quot;系统平均带权周转系数为：%.2f\n\n&quot;, total_zzxs / n);</span><br><span class="line">        </span><br><span class="line">        // 内存释放</span><br><span class="line">        while(head) &#123;</span><br><span class="line">            Process *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        head = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1001 p1 9:40 20</span><br><span class="line">// 1004 p4 10:10 10</span><br><span class="line">// 1058 p5 10:05 30 </span><br><span class="line">// 1002 p2 9:55 15</span><br><span class="line">// 1003 p3 9:45 25</span><br></pre></td></tr></table></figure>

<h1 id="第五周：-优先级调度算法"><a href="#第五周：-优先级调度算法" class="headerlink" title="第五周： 优先级调度算法"></a>第五周： 优先级调度算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int hour;</span><br><span class="line">    int min;</span><br><span class="line">&#125; Time;</span><br><span class="line"></span><br><span class="line">typedef struct Process &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">    Time arrive;</span><br><span class="line">    int zx;</span><br><span class="line">    int priority;  // 新增优先级字段</span><br><span class="line">    Time start;</span><br><span class="line">    Time finish;</span><br><span class="line">    int zz;</span><br><span class="line">    float zzxs;</span><br><span class="line">    struct Process* next;</span><br><span class="line">&#125; Process;</span><br><span class="line"></span><br><span class="line">int time_cmp(Time a, Time b) &#123;</span><br><span class="line">    return (a.hour * 60 + a.min) - (b.hour * 60 + b.min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time add_mins(Time t, int mins) &#123;</span><br><span class="line">    int total = t.hour * 60 + t.min + mins;</span><br><span class="line">    return (Time)&#123;total / 60, total % 60&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int time_diff(Time end, Time start) &#123;</span><br><span class="line">    return (end.hour * 60 + end.min) - (start.hour * 60 + start.min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改为优先级调度算法</span><br><span class="line">void sjf_scheduler(Process** head, int n) &#123;</span><br><span class="line">    Process* scheduled_head = NULL;</span><br><span class="line">    Process* scheduled_tail = NULL;</span><br><span class="line">    Time current_time = &#123;9, 40&#125;;</span><br><span class="line">    int processed = 0;</span><br><span class="line"></span><br><span class="line">    while (processed &lt; n) &#123;</span><br><span class="line">        Process **prev = head;</span><br><span class="line">        Process *sel = NULL;</span><br><span class="line">        int max_priority = -1;</span><br><span class="line">        int min_zx = INT_MAX;</span><br><span class="line">        Process **prev_sel = NULL;</span><br><span class="line"></span><br><span class="line">        while (*prev) &#123;</span><br><span class="line">            if ((*prev)-&gt;start.hour == 0 &amp;&amp; </span><br><span class="line">                time_cmp((*prev)-&gt;arrive, current_time) &lt;= 0) &#123;</span><br><span class="line">                </span><br><span class="line">                // 优先级更高，或同优先级但执行时间更短</span><br><span class="line">                if ((*prev)-&gt;priority &gt; max_priority || </span><br><span class="line">                    ((*prev)-&gt;priority == max_priority &amp;&amp; (*prev)-&gt;zx &lt; min_zx)) &#123;</span><br><span class="line">                    max_priority = (*prev)-&gt;priority;</span><br><span class="line">                    min_zx = (*prev)-&gt;zx;</span><br><span class="line">                    sel = *prev;</span><br><span class="line">                    prev_sel = prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = &amp;(*prev)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sel) &#123;</span><br><span class="line">            sel-&gt;start = (time_cmp(current_time, sel-&gt;arrive) &gt; 0) ? </span><br><span class="line">                        current_time : sel-&gt;arrive;</span><br><span class="line">            sel-&gt;finish = add_mins(sel-&gt;start, sel-&gt;zx);</span><br><span class="line">            sel-&gt;zz = time_diff(sel-&gt;finish, sel-&gt;arrive);</span><br><span class="line">            sel-&gt;zzxs = (float)sel-&gt;zz / sel-&gt;zx;</span><br><span class="line">            </span><br><span class="line">            current_time = sel-&gt;finish;</span><br><span class="line">            processed++;</span><br><span class="line">            </span><br><span class="line">            // 从原链表移除</span><br><span class="line">            if (prev_sel) &#123;</span><br><span class="line">                *prev_sel = sel-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 尾部插入</span><br><span class="line">            sel-&gt;next = NULL;</span><br><span class="line">            if (scheduled_head == NULL) &#123;</span><br><span class="line">                scheduled_head = scheduled_tail = sel;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scheduled_tail-&gt;next = sel;</span><br><span class="line">                scheduled_tail = sel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current_time.min++;</span><br><span class="line">            if (current_time.min &gt;= 60) &#123;</span><br><span class="line">                current_time.hour++;</span><br><span class="line">                current_time.min = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *head = scheduled_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int op, n;</span><br><span class="line">    Process *head = NULL;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        printf(&quot;请输入操作(1：开始进程调度；-1：结束进程)：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line">        </span><br><span class="line">        if(op == -1) break;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;请输入进程数：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;id号 名字 优先级 到达时间 执行时间\n&quot;);</span><br><span class="line">        for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">            Process *p = (Process*)malloc(sizeof(Process));</span><br><span class="line">            scanf(&quot;%d %s %d %d:%d %d&quot;, </span><br><span class="line">                 &amp;p-&gt;id, p-&gt;name, &amp;p-&gt;priority,</span><br><span class="line">                 &amp;p-&gt;arrive.hour, &amp;p-&gt;arrive.min,</span><br><span class="line">                 &amp;p-&gt;zx);</span><br><span class="line">            p-&gt;start.hour = 0;  // 初始化开始时间</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            head = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sjf_scheduler(&amp;head, n);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;\n模拟优先级调度过程结果：\n&quot;);</span><br><span class="line">        printf(&quot;id号 名字 到达时间 执行时间(分钟) 开始时间 完成时间 周转时间(分钟) 带权周转系数\n&quot;);</span><br><span class="line">        </span><br><span class="line">        float total_zz = 0, total_zzxs = 0;</span><br><span class="line">        Process *p = head;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            printf(&quot;%-4d %-4s %02d:%02d %12d   %02d:%02d    %02d:%02d %15d %12.2f\n&quot;,</span><br><span class="line">                  p-&gt;id, p-&gt;name, </span><br><span class="line">                  p-&gt;arrive.hour, p-&gt;arrive.min,</span><br><span class="line">                  p-&gt;zx,</span><br><span class="line">                  p-&gt;start.hour, p-&gt;start.min,</span><br><span class="line">                  p-&gt;finish.hour, p-&gt;finish.min,</span><br><span class="line">                  p-&gt;zz,p-&gt;zzxs);</span><br><span class="line">            </span><br><span class="line">            total_zz += p-&gt;zz;</span><br><span class="line">            total_zzxs += p-&gt;zzxs;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;\n系统平均周转时间为：%.2f\n&quot;, total_zz / n);</span><br><span class="line">        printf(&quot;系统平均带权周转系数为：%.2f\n\n&quot;, total_zzxs / n);</span><br><span class="line">        </span><br><span class="line">        // 内存释放</span><br><span class="line">        while(head) &#123;</span><br><span class="line">            Process *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        head = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 1001 p1 1 09:40 20</span><br><span class="line">// 1002 p2 3 09:55 15</span><br><span class="line">// 1003 p3 2 09:45 25</span><br><span class="line">// 1004 p4 4 10:10 10</span><br><span class="line">// 1005 p5 3 10:05 30</span><br></pre></td></tr></table></figure>

<h1 id="第六周：时间片轮转调度算法"><a href="#第六周：时间片轮转调度算法" class="headerlink" title="第六周：时间片轮转调度算法"></a>第六周：时间片轮转调度算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct data &#123;</span><br><span class="line">    int hour;</span><br><span class="line">    int minute;</span><br><span class="line">&#125; Time;</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">    Time arrive;</span><br><span class="line">    int zx;</span><br><span class="line">    Time start;</span><br><span class="line">    Time finish;</span><br><span class="line">    int zz;</span><br><span class="line">    float zzxs;</span><br><span class="line">    Time current;</span><br><span class="line">    int ywcs;</span><br><span class="line">    int sysj;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">typedef struct Queue &#123;</span><br><span class="line">    Node* front;</span><br><span class="line">    Node* tail;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">Queue* init() &#123;</span><br><span class="line">    Queue* p = (Queue*)malloc(sizeof(Queue));</span><br><span class="line">    p-&gt;front = p-&gt;tail = NULL;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool timecompare(Time tt, Time p) &#123;</span><br><span class="line">    int t1 = tt.hour * 60 + tt.minute;</span><br><span class="line">    int t2 = p.hour * 60 + p.minute;</span><br><span class="line">    return t1 &gt;= t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Namecompare(const char* s1, const char* s2) &#123;</span><br><span class="line">    return strcmp(s1, s2) &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Choose(Node* p, Node* q, int flag) &#123;</span><br><span class="line">    if (flag == 1) &#123;</span><br><span class="line">        int p_time = p-&gt;arrive.hour * 60 + p-&gt;arrive.minute;</span><br><span class="line">        int q_time = q-&gt;arrive.hour * 60 + q-&gt;arrive.minute;</span><br><span class="line">        return p_time &gt; q_time;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return Namecompare(p-&gt;name, q-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Time_or_Name_Sorted(Queue *que, int flag) &#123;</span><br><span class="line">    if (que-&gt;front == NULL || que-&gt;front-&gt;next == NULL) return;</span><br><span class="line"></span><br><span class="line">    bool swapped;</span><br><span class="line">    Node **pptr, *curr, *next;</span><br><span class="line">    do &#123;</span><br><span class="line">        swapped = false;</span><br><span class="line">        pptr = &amp;que-&gt;front;</span><br><span class="line">        curr = que-&gt;front;</span><br><span class="line">        next = curr-&gt;next;</span><br><span class="line"></span><br><span class="line">        while (next) &#123;</span><br><span class="line">            if (Choose(curr, next, flag)) &#123;</span><br><span class="line">                curr-&gt;next = next-&gt;next;</span><br><span class="line">                next-&gt;next = curr;</span><br><span class="line">                *pptr = next;</span><br><span class="line">                </span><br><span class="line">                if (curr-&gt;next == NULL) que-&gt;tail = curr;</span><br><span class="line">                swapped = true;</span><br><span class="line">                pptr = &amp;next-&gt;next;</span><br><span class="line">                next = curr-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pptr = &amp;curr-&gt;next;</span><br><span class="line">                curr = next;</span><br><span class="line">                next = next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (swapped);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time* ComputeTime(Time* tt, Node* q, int tp) &#123;</span><br><span class="line">    if (q-&gt;ywcs == 0) &#123; // 首次执行</span><br><span class="line">        q-&gt;start = *tt;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;current = *tt; // 每次更新当前开始时间</span><br><span class="line"></span><br><span class="line">    int exec_time = (q-&gt;sysj &gt; tp) ? tp : q-&gt;sysj;</span><br><span class="line">    tt-&gt;minute += exec_time;</span><br><span class="line">    tt-&gt;hour += tt-&gt;minute / 60;</span><br><span class="line">    tt-&gt;minute %= 60;</span><br><span class="line"></span><br><span class="line">    q-&gt;ywcs += exec_time;</span><br><span class="line">    q-&gt;sysj -= exec_time;</span><br><span class="line"></span><br><span class="line">    if (q-&gt;sysj == 0) &#123;</span><br><span class="line">        q-&gt;finish = *tt;</span><br><span class="line">        int arrive_min = q-&gt;arrive.hour * 60 + q-&gt;arrive.minute;</span><br><span class="line">        int finish_min = q-&gt;finish.hour * 60 + q-&gt;finish.minute;</span><br><span class="line">        q-&gt;zz = finish_min - arrive_min;</span><br><span class="line">        q-&gt;zzxs = (float)q-&gt;zz / q-&gt;zx;</span><br><span class="line">    &#125;</span><br><span class="line">    return tt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Print_Current(Queue* que, int round, Node* curr, Time sys_time) &#123;</span><br><span class="line">    printf(&quot;\n第%d轮执行和就绪队列的结果:\n&quot;, round);</span><br><span class="line">    printf(&quot;ID号 名字　　到达时间　总执行时间　当前开始时间　已完成时间　剩余时间\n&quot;);</span><br><span class="line">    </span><br><span class="line">    if (curr) &#123;</span><br><span class="line">        printf(&quot;%-5d %-6s　%02d:%02d　　%-9d　　&quot;,</span><br><span class="line">            curr-&gt;id, curr-&gt;name, </span><br><span class="line">            curr-&gt;arrive.hour, curr-&gt;arrive.minute,</span><br><span class="line">            curr-&gt;zx);</span><br><span class="line"></span><br><span class="line">        if (curr-&gt;ywcs == 0 &amp;&amp; curr-&gt;sysj == curr-&gt;zx) &#123;</span><br><span class="line">            printf(&quot;00:00　　　&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%02d:%02d　　　&quot;,</span><br><span class="line">                curr-&gt;current.hour, curr-&gt;current.minute);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%-8d　　%-8d\n&quot;, curr-&gt;ywcs, curr-&gt;sysj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p = que-&gt;front;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        printf(&quot;%-5d %-6s　%02d:%02d　　%-9d　　&quot;, </span><br><span class="line">            p-&gt;id, p-&gt;name, </span><br><span class="line">            p-&gt;arrive.hour, p-&gt;arrive.minute,</span><br><span class="line">            p-&gt;zx);</span><br><span class="line"></span><br><span class="line">        if (p-&gt;ywcs == 0 &amp;&amp; p-&gt;sysj == p-&gt;zx) &#123;</span><br><span class="line">            printf(&quot;00:00　　　&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%02d:%02d　　　&quot;,</span><br><span class="line">                p-&gt;current.hour, p-&gt;current.minute);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%-8d　　%-8d\n&quot;, p-&gt;ywcs, p-&gt;sysj);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_to_ready(Queue* ready, Queue* que, Time sys_time) &#123;</span><br><span class="line">    Node* p = que-&gt;front;</span><br><span class="line">    while (p &amp;&amp; timecompare(sys_time, p-&gt;arrive)) &#123;</span><br><span class="line">        Node* next = p-&gt;next;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        if (!ready-&gt;tail) &#123;</span><br><span class="line">            ready-&gt;front = ready-&gt;tail = p;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ready-&gt;tail-&gt;next = p;</span><br><span class="line">            ready-&gt;tail = p;</span><br><span class="line">        &#125;</span><br><span class="line">        que-&gt;front = next;</span><br><span class="line">        if (!next) que-&gt;tail = NULL;</span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue* Time_Slice_Rotation(Queue* que, int tp) &#123;</span><br><span class="line">    Queue* done = init();</span><br><span class="line">    Time sys_time = &#123;99, 99&#125;;</span><br><span class="line"></span><br><span class="line">    Node* p = que-&gt;front;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        int arrive_min = p-&gt;arrive.hour * 60 + p-&gt;arrive.minute;</span><br><span class="line">        int sys_min = sys_time.hour * 60 + sys_time.minute;</span><br><span class="line">        if (arrive_min &lt; sys_min) &#123;</span><br><span class="line">            sys_time = p-&gt;arrive;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue* ready = init();</span><br><span class="line">    Node* curr = NULL;</span><br><span class="line">    int round = 0;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        add_to_ready(ready, que, sys_time);</span><br><span class="line"></span><br><span class="line">        if (!curr) &#123;</span><br><span class="line">            if (ready-&gt;front) &#123;</span><br><span class="line">                curr = ready-&gt;front;</span><br><span class="line">                ready-&gt;front = ready-&gt;front-&gt;next;</span><br><span class="line">                if (!ready-&gt;front) ready-&gt;tail = NULL;</span><br><span class="line">            &#125; else if (que-&gt;front) &#123;</span><br><span class="line">                sys_time = que-&gt;front-&gt;arrive;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        round++;</span><br><span class="line">        Time prev_time = sys_time;</span><br><span class="line">        ComputeTime(&amp;sys_time, curr, tp);</span><br><span class="line"></span><br><span class="line">        add_to_ready(ready, que, sys_time);</span><br><span class="line"></span><br><span class="line">        Print_Current(ready, round, curr, sys_time);</span><br><span class="line"></span><br><span class="line">        if (curr-&gt;sysj == 0) &#123;</span><br><span class="line">            curr-&gt;next = done-&gt;front;</span><br><span class="line">            done-&gt;front = curr;</span><br><span class="line">            if (!done-&gt;tail) done-&gt;tail = curr;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (ready-&gt;tail) &#123;</span><br><span class="line">                ready-&gt;tail-&gt;next = curr;</span><br><span class="line">                ready-&gt;tail = curr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ready-&gt;front = ready-&gt;tail = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Print(Queue* que, int n) &#123;</span><br><span class="line">    printf(&quot;\n模拟进程时间片轮转调度结果:\n&quot;);</span><br><span class="line">    printf(&quot;ID号　名字　　到达时间　执行时间　开始时间　完成时间　周转时间　带权周转\n&quot;);</span><br><span class="line">    float sum_zz = 0, sum_zzxs = 0;</span><br><span class="line">    Node* p = que-&gt;front;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        printf(&quot;%-5d %-6s　%02d:%02d　　%-8d　%02d:%02d　　%02d:%02d　　%-8d　%.2f\n&quot;,</span><br><span class="line">               p-&gt;id, p-&gt;name, </span><br><span class="line">               p-&gt;arrive.hour, p-&gt;arrive.minute,</span><br><span class="line">               p-&gt;zx,</span><br><span class="line">               p-&gt;start.hour, p-&gt;start.minute,</span><br><span class="line">               p-&gt;finish.hour, p-&gt;finish.minute,</span><br><span class="line">               p-&gt;zz, p-&gt;zzxs);</span><br><span class="line">        sum_zz += p-&gt;zz;</span><br><span class="line">        sum_zzxs += p-&gt;zzxs;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n系统平均周转时间: %.2f分钟\n&quot;, sum_zz / n);</span><br><span class="line">    printf(&quot;系统平均带权周转系数: %.2f\n&quot;, sum_zzxs / n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Scanln(Queue* wait, int n) &#123;</span><br><span class="line">    printf(&quot;请输入%d个进程的参数（ID 名称 到达时间 执行时间）:\n&quot;, n);</span><br><span class="line">    int i; </span><br><span class="line">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        Node* p = (Node*)malloc(sizeof(Node));</span><br><span class="line">        memset(p, 0, sizeof(Node));</span><br><span class="line">        scanf(&quot;%d %s %d:%d %d&quot;, </span><br><span class="line">             &amp;p-&gt;id, p-&gt;name, </span><br><span class="line">             &amp;p-&gt;arrive.hour, &amp;p-&gt;arrive.minute,</span><br><span class="line">             &amp;p-&gt;zx);</span><br><span class="line">        p-&gt;sysj = p-&gt;zx;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">        if (!wait-&gt;front) &#123;</span><br><span class="line">            wait-&gt;front = wait-&gt;tail = p;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wait-&gt;tail-&gt;next = p;</span><br><span class="line">            wait-&gt;tail = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void freeQueue(Queue* q) &#123;</span><br><span class="line">    Node* p = q-&gt;front;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        Node* temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Queue* wait = init();</span><br><span class="line">    int flag, n, t;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;\n请输入操作 (1:开始调度; 0:退出): &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;flag);</span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            freeQueue(wait);</span><br><span class="line">            printf(&quot;操作结束!\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;请输入进程数量: &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        printf(&quot;请输入时间片长度(分钟): &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">        Scanln(wait, n);</span><br><span class="line"></span><br><span class="line">        Time_or_Name_Sorted(wait, 1);</span><br><span class="line">        Queue* done = Time_Slice_Rotation(wait, t);</span><br><span class="line">        Time_or_Name_Sorted(done, 0);</span><br><span class="line">        Print(done, n);</span><br><span class="line"></span><br><span class="line">        freeQueue(wait);</span><br><span class="line">        freeQueue(done);</span><br><span class="line">        wait = init();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第七周：-银行家算法"><a href="#第七周：-银行家算法" class="headerlink" title="第七周： 银行家算法"></a>第七周： 银行家算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#define MAX 10</span><br><span class="line"></span><br><span class="line">// 数据结构</span><br><span class="line">int zy, n;</span><br><span class="line">int Available[MAX];</span><br><span class="line">int Max[MAX][MAX], Need[MAX][MAX], Allocation[MAX][MAX];</span><br><span class="line">char Name[MAX][15];</span><br><span class="line">int safe_seq[MAX];</span><br><span class="line"></span><br><span class="line">// 函数声明</span><br><span class="line">int FindIndex(char *s);</span><br><span class="line">void PrintStatus();</span><br><span class="line">int SafetyCheck();</span><br><span class="line">void Banker();</span><br><span class="line"></span><br><span class="line">// 根据进程名找索引</span><br><span class="line">int FindIndex(char *s) &#123;</span><br><span class="line">    for(int i=0; i&lt;n; i++)</span><br><span class="line">        if(strcmp(Name[i], s) == 0)</span><br><span class="line">            return i;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印当前状态（按图像格式）</span><br><span class="line">void PrintStatus() &#123;</span><br><span class="line">    printf(&quot;\n进程名\t最大需求量\t尚需求量\t已分配量\t执行状态\n&quot;);</span><br><span class="line">    for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">        printf(&quot;%s\t&quot;, Name[i]);</span><br><span class="line">        // 最大需求</span><br><span class="line">        for(int j=0; j&lt;zy; j++) </span><br><span class="line">            printf(j&lt;zy-1 ? &quot;%d,&quot; : &quot;%d&quot;, Max[i][j]);</span><br><span class="line">        // 尚需求</span><br><span class="line">        printf(&quot;\t &quot;);</span><br><span class="line">        for(int j=0; j&lt;zy; j++)</span><br><span class="line">            printf(j&lt;zy-1 ? &quot;%d,&quot; : &quot;%d&quot;, Need[i][j]);</span><br><span class="line">        // 已分配</span><br><span class="line">        printf(&quot;\t &quot;);</span><br><span class="line">        for(int j=0; j&lt;zy; j++)</span><br><span class="line">            printf(j&lt;zy-1 ? &quot;%d,&quot; : &quot;%d&quot;, Allocation[i][j]);</span><br><span class="line">        printf(&quot;\tWorking\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;系统剩余资源:\n&quot;);</span><br><span class="line">    for(int j=0; j&lt;zy; j++)</span><br><span class="line">        printf(j&lt;zy-1 ? &quot;%d,&quot; : &quot;%d\n\n&quot;, Available[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 安全性检查算法</span><br><span class="line">int SafetyCheck() &#123;</span><br><span class="line">    int Work[MAX], Finish[MAX];</span><br><span class="line">    memcpy(Work, Available, sizeof(Work));</span><br><span class="line">    memset(Finish, 0, sizeof(Finish));</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line">    while(count &lt; n) &#123;</span><br><span class="line">        int found = 0;</span><br><span class="line">        for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">            if(!Finish[i]) &#123;</span><br><span class="line">                int can_allocate = 1;</span><br><span class="line">                for(int j=0; j&lt;zy; j++)</span><br><span class="line">                    if(Need[i][j] &gt; Work[j]) &#123;</span><br><span class="line">                        can_allocate = 0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                if(can_allocate) &#123;</span><br><span class="line">                    for(int j=0; j&lt;zy; j++)</span><br><span class="line">                        Work[j] += Allocation[i][j];</span><br><span class="line">                    Finish[i] = 1;</span><br><span class="line">                    safe_seq[count++] = i;</span><br><span class="line">                    found = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!found) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return (count == n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 银行家算法主流程</span><br><span class="line">void Banker() &#123;</span><br><span class="line">    char pname[15];</span><br><span class="line">    int req[zy], index;</span><br><span class="line">    char choice;</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;请输入进程名: &quot;);</span><br><span class="line">        scanf(&quot;%s&quot;, pname);</span><br><span class="line">        index = FindIndex(pname);</span><br><span class="line">        if(index == -1) &#123;</span><br><span class="line">            printf(&quot;进程不存在!\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;请输入该进程当前申请的各个资源数量: &quot;);</span><br><span class="line">        for(int j=0; j&lt;zy; j++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;req[j]);</span><br><span class="line"></span><br><span class="line">        // 步骤1：检查请求合法性</span><br><span class="line">        int valid = 1;</span><br><span class="line">        for(int j=0; j&lt;zy; j++) &#123;</span><br><span class="line">            if(req[j] &gt; Need[index][j] || req[j] &gt; Available[j]) &#123;</span><br><span class="line">                valid = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!valid) &#123;</span><br><span class="line">            printf(&quot;申请异常！\n&quot;);</span><br><span class="line">            printf(&quot;系统可用资源如下:\n&quot;);</span><br><span class="line">            for(int j=0; j&lt;zy; j++)</span><br><span class="line">                printf(j&lt;zy-1 ? &quot;%d,&quot; : &quot;%d\n&quot;, Available[j]);</span><br><span class="line">            printf(&quot;当前进程剩余所需资源如下:\n&quot;);</span><br><span class="line">            for(int j=0; j&lt;zy; j++)</span><br><span class="line">                printf(&quot;%d,&quot;,Need[index][j]);</span><br><span class="line">            printf(&quot;\n请重新输入!&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 试探分配</span><br><span class="line">        for(int j=0; j&lt;zy; j++) &#123;</span><br><span class="line">            Available[j] -= req[j];</span><br><span class="line">            Allocation[index][j] += req[j];</span><br><span class="line">            Need[index][j] -= req[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 安全性检查</span><br><span class="line">        if(SafetyCheck()) &#123;</span><br><span class="line">            printf(&quot;申请成功！安全序列为:&quot;);</span><br><span class="line">            for(int i=0; i&lt;n; i++)</span><br><span class="line">            	if(!(Need[safe_seq[i]][0]==0&amp;&amp;Need[safe_seq[i]][1]==0&amp;&amp;Need[safe_seq[i]][2]==0)) </span><br><span class="line">                	printf(&quot;%s-&gt;&quot;, Name[safe_seq[i]]);</span><br><span class="line">            printf(&quot;\b\b  \n&quot;);</span><br><span class="line">            if(Need[index][0]==0&amp;&amp;Need[index][1]==0&amp;&amp;Need[index][2]==0)&#123;</span><br><span class="line">                for(int i=0;i&lt;zy;i++)&#123;</span><br><span class="line">                    Available[i]+=Allocation[index][i];</span><br><span class="line">                    Allocation[index][i]=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            PrintStatus();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;无安全系列，请重新输入！\n&quot;);</span><br><span class="line">            // 回滚操作</span><br><span class="line">            for(int j=0; j&lt;zy; j++) &#123;</span><br><span class="line">                Available[j] += req[j];</span><br><span class="line">                Allocation[index][j] -= req[j];</span><br><span class="line">                Need[index][j] += req[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;是否需要申请资源?(Y/N): &quot;);</span><br><span class="line">        scanf(&quot; %c&quot;, &amp;choice);</span><br><span class="line">    &#125; while(toupper(choice) == &#x27;Y&#x27;);</span><br><span class="line">    PrintStatus();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;请输入进程数: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    printf(&quot;请输入资源种类的数量: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;zy);</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入%d类资源初始化的资源数: &quot;, zy);</span><br><span class="line">    for(int i=0; i&lt;zy; i++)</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;Available[i]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入进程信息（进程名 最大需求量）:\n&quot;);</span><br><span class="line">    for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">        scanf(&quot;%s&quot;, Name[i]);</span><br><span class="line">        for(int j=0; j&lt;zy; j++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;Max[i][j]);</span><br><span class="line">            Need[i][j] = Max[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n进程开始执行！\n请为进程分配相关资源！\n&quot;);</span><br><span class="line">    Banker();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-03-25_084958.png" class="" title="2025-03-25_084958">

<h1 id="第八周：固定分区算法"><a href="#第八周：固定分区算法" class="headerlink" title="第八周：固定分区算法"></a>第八周：固定分区算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct d&#123;  //内存分区</span><br><span class="line">    int id;</span><br><span class="line">    int size;</span><br><span class="line">    int address;  //起始地址</span><br><span class="line">    char station[10]; //状态</span><br><span class="line">&#125;memory;  </span><br><span class="line">void print(memory m[],int n)&#123;</span><br><span class="line">    printf(&quot;**********打印分区信息*************\n&quot;);</span><br><span class="line">    printf(&quot;分区号  大小  起始  状态\n&quot;);</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        printf(&quot;%-7d%-7d%-7d%s\n&quot;,m[i].id,m[i].size,m[i].address,m[i].station);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,i;</span><br><span class="line">    memory m[10];</span><br><span class="line">    printf(&quot;请输入系统的分区块数: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;请依次输入:\n分区号  大小  起始\n&quot;);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;m[i].id,&amp;m[i].size,&amp;m[i].address);</span><br><span class="line">        strcpy(m[i].station,&quot;0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    print(m,n);</span><br><span class="line">    int num,j,x;</span><br><span class="line">    int job[10];</span><br><span class="line">    printf(&quot;请输入作业的个数: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">    printf(&quot;请输入这%d个作业的信息: \n&quot;,num);</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        printf(&quot;请输入作业%d的大小: &quot;,i+1);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        for(j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!strcmp(m[j].station,&quot;0&quot;)&amp;&amp;m[j].size&gt;=x)&#123;</span><br><span class="line">                job[i]=x;</span><br><span class="line">                sprintf(m[j].station,&quot;JOB%d&quot;,i+1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;打印各作业的信息: \n作业名 作业大小\n&quot;);</span><br><span class="line">    for(i=0;i&lt;num;i++)</span><br><span class="line">        printf(&quot;JOB%d  %dKB\n&quot;,i+1,job[i]);</span><br><span class="line">    print(m,n);</span><br><span class="line">    char flag;</span><br><span class="line">    printf(&quot;是否需要回收(y/n)?:&quot;);</span><br><span class="line">    scanf(&quot; %c&quot;,&amp;flag);</span><br><span class="line">    char work[10];</span><br><span class="line">    while((int)flag==(int)&#x27;y&#x27;)&#123;</span><br><span class="line">        print(m,n);</span><br><span class="line">        printf(&quot;请输入要回收的作业名:&quot;);</span><br><span class="line">        scanf(&quot; %s&quot;,&amp;work);</span><br><span class="line">        for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(m[i].station!=0&amp;&amp;!strcmp(m[i].station,work))&#123;</span><br><span class="line">                strcpy(m[i].station,&quot;0&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;回收成功\n&quot;);</span><br><span class="line">        print(m,n);</span><br><span class="line">        printf(&quot;是否需要回收(y/n)?:&quot;);</span><br><span class="line">        scanf(&quot; %c&quot;,&amp;flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-04-01_000958.png" class="" title="2025-04-01_000958">

<h1 id="第九周：可变分区算法"><a href="#第九周：可变分区算法" class="headerlink" title="第九周：可变分区算法"></a>第九周：可变分区算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int inf = 0x7ffffff;</span><br><span class="line"></span><br><span class="line">struct Y &#123;</span><br><span class="line">    int size;</span><br><span class="line">    int address;</span><br><span class="line">    string str;</span><br><span class="line">    Y(int x = 0, int y = 0, string t = &quot;&quot;) : size(x), address(y), str(t) &#123;&#125;</span><br><span class="line">    bool operator&lt;(const Y&amp; x) const &#123;</span><br><span class="line">        return address &lt; x.address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Y&gt; H, N; // H: 已分配, N: 未分配</span><br><span class="line"></span><br><span class="line">void out() &#123;</span><br><span class="line">    int num=1;</span><br><span class="line">    cout&lt;&lt;&quot;======== 主存分配情况 ========&quot;&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; &quot;\n已分配分区表：&quot; &lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt;&quot;分区号&quot;&lt;&lt;&quot;\t大小&quot;&lt;&lt;&quot;\t地址&quot;&lt;&lt;&quot;\t状态&quot;&lt;&lt;endl;</span><br><span class="line">    for (auto &amp;y : H) &#123;</span><br><span class="line">        cout &lt;&lt;num&lt;&lt; &quot;\t&quot; &lt;&lt; y.size &lt;&lt; &quot;\t&quot; &lt;&lt; y.address&lt;&lt; &quot;\t&quot; &lt;&lt; y.str &lt;&lt; endl;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;\n未分配分区表：&quot; &lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt;&quot;分区号&quot;&lt;&lt;&quot;\t大小&quot;&lt;&lt;&quot;\t地址&quot;&lt;&lt;&quot;\t状态&quot;&lt;&lt;endl;</span><br><span class="line">    for (auto &amp;y : N) &#123;</span><br><span class="line">        cout &lt;&lt;num&lt;&lt; &quot;\t&quot; &lt;&lt; y.size &lt;&lt; &quot;\t&quot; &lt;&lt; y.address&lt;&lt; &quot;\t&quot; &lt;&lt; y.str &lt;&lt; endl;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void menu1() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;======== 可变分区管理 ========&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*      1. 内存管理     *&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*      2. 内存去配     *&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*      0. 退出         *&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;请输入选项：&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void menu2() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;========= 分配算法 ==========&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*      1. 最先分配算法     *&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*      2. 最优分配算法     *&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*      3. 最坏分配算法     *&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;请输入选项：&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void C1(int size, string x) &#123;</span><br><span class="line">    sort(N.begin(), N.end());</span><br><span class="line">    for (auto it = N.begin(); it &lt;= N.end(); ++it) &#123;</span><br><span class="line">        if (it-&gt;size &gt;= size &amp;&amp; it-&gt;str == &quot;空闲&quot;) &#123;</span><br><span class="line">            H.push_back(Y(size, it-&gt;address, x));</span><br><span class="line">            if(it-&gt;size &gt; size)&#123;</span><br><span class="line">                int s=it-&gt;size,a=it-&gt;address;</span><br><span class="line">                N.erase(it);</span><br><span class="line">                N.push_back(Y(s - size, a + size, &quot;空闲&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            else N.erase(it);</span><br><span class="line">            sort(N.begin(), N.end());</span><br><span class="line">            sort(H.begin(), H.end());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;分配失败：无足够空闲分区！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void C2(int size, string x) &#123;</span><br><span class="line">    sort(N.begin(), N.end(), [](Y a, Y b) &#123; return a.size &lt; b.size; &#125;);</span><br><span class="line">    for (auto it = N.begin(); it != N.end(); ++it) &#123;</span><br><span class="line">        if (it-&gt;size &gt;= size &amp;&amp; it-&gt;str == &quot;空闲&quot;) &#123;</span><br><span class="line">            H.push_back(Y(size, it-&gt;address, x));</span><br><span class="line">            if (it-&gt;size &gt; size) &#123;</span><br><span class="line">                N.insert(it + 1, Y(it-&gt;size - size, it-&gt;address + size, &quot;空闲&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            N.erase(it);</span><br><span class="line">            sort(N.begin(), N.end());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;分配失败：无足够空闲分区！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void C3(int size, string x) &#123;</span><br><span class="line">    sort(N.begin(), N.end(), [](Y a, Y b) &#123; return a.size &gt; b.size; &#125;);</span><br><span class="line">    for (auto it = N.begin(); it != N.end(); ++it) &#123;</span><br><span class="line">        if (it-&gt;size &gt;= size &amp;&amp; it-&gt;str == &quot;空闲&quot;) &#123;</span><br><span class="line">            H.push_back(Y(size, it-&gt;address, x));</span><br><span class="line">            if (it-&gt;size &gt; size) &#123;</span><br><span class="line">                N.insert(it + 1, Y(it-&gt;size - size, it-&gt;address + size, &quot;空闲&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            N.erase(it);</span><br><span class="line">            sort(N.begin(), N.end());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;分配失败：无足够空闲分区！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void D(string x) &#123;</span><br><span class="line">    for (auto it = H.begin(); it != H.end(); ++it) &#123;</span><br><span class="line">        if (it-&gt;str == x) &#123;</span><br><span class="line">            Y freed = *it;</span><br><span class="line">            H.erase(it);</span><br><span class="line">            N.push_back(Y(freed.size, freed.address, &quot;空闲&quot;));</span><br><span class="line">            sort(N.begin(), N.end());</span><br><span class="line">            </span><br><span class="line">            // 合并相邻分区</span><br><span class="line">            auto nit = N.begin();</span><br><span class="line">            while (nit != N.end()) &#123;</span><br><span class="line">                auto next = nit + 1;</span><br><span class="line">                if (next != N.end() &amp;&amp; nit-&gt;address + nit-&gt;size == next-&gt;address) &#123;</span><br><span class="line">                    next-&gt;size += nit-&gt;size;</span><br><span class="line">                    next-&gt;address = nit-&gt;address;</span><br><span class="line">                    nit = N.erase(nit); // 这里一定要对next进行操作，因为erase返回的是删除项的下一项，如果对nit进行操作，可能会跳过连续合并的情况</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ++nit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;回收成功！&quot; &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;回收失败：未找到该作业！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cout &lt;&lt; &quot;请输入内存大小：&quot;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; &quot;请输入起始地址：&quot;;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    N.push_back(Y(n, m, &quot;空闲&quot;));</span><br><span class="line">    out();</span><br><span class="line">    </span><br><span class="line">   int f;</span><br><span class="line">   do &#123;</span><br><span class="line">       menu1();</span><br><span class="line">       cin &gt;&gt; f;</span><br><span class="line">       switch (f) &#123;</span><br><span class="line">           case 1: &#123;</span><br><span class="line">               menu2();</span><br><span class="line">               int flag;</span><br><span class="line">               cin &gt;&gt; flag;</span><br><span class="line">               string tmp;</span><br><span class="line">               int size;</span><br><span class="line">               cout &lt;&lt; &quot;请输入作业名：&quot;;</span><br><span class="line">               cin &gt;&gt; tmp;</span><br><span class="line">               cout &lt;&lt; &quot;请输入分配大小：&quot;;</span><br><span class="line">               cin &gt;&gt; size;</span><br><span class="line">               if (flag == 1) C1(size, tmp);</span><br><span class="line">               else if (flag == 2) C2(size, tmp);</span><br><span class="line">               else if (flag == 3) C3(size, tmp);</span><br><span class="line">               out();</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           case 2: &#123;</span><br><span class="line">               string tmp;</span><br><span class="line">               out();</span><br><span class="line">               cout &lt;&lt; &quot;请输入回收的作业名：&quot;;</span><br><span class="line">               cin &gt;&gt; tmp;</span><br><span class="line">               D(tmp);</span><br><span class="line">               out();</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; while (f != 0);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-04-07_213522.png" class="" title="2025-04-07_213522">

<h1 id="第十周：分页分区算法"><a href="#第十周：分页分区算法" class="headerlink" title="第十周：分页分区算法"></a>第十周：分页分区算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define Max 100</span><br><span class="line">typedef struct k&#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int size[Max][2];</span><br><span class="line">    struct k* next;</span><br><span class="line">    int sizenum;   //块的个数 </span><br><span class="line">&#125;node;</span><br><span class="line">int memorysize;</span><br><span class="line">int wordlength;</span><br><span class="line">int blocksize;</span><br><span class="line">int blocknum=0;  //可用物理块数</span><br><span class="line">int sys[2000];</span><br><span class="line">node *n;</span><br><span class="line">void print_sys()&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    printf(&quot;主存位示图如下:\n&quot;);</span><br><span class="line">    printf(&quot;    &quot;);</span><br><span class="line">    for(i=0;i&lt;wordlength;i++)&#123;</span><br><span class="line">    	printf(&quot;%-2d&quot;,i);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n0 | &quot;);</span><br><span class="line">    for(i=0;i&lt;memorysize;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,sys[i]);</span><br><span class="line">        if((i+1)%wordlength==0) printf(&quot;\n%-2d| &quot;,i/wordlength+1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n剩余物理块数:%d\n&quot;,blocknum);</span><br><span class="line">&#125;</span><br><span class="line">void print_table(char s[])&#123;  //打印页表 </span><br><span class="line">	node *p;</span><br><span class="line">	p=n-&gt;next;</span><br><span class="line">	int i;</span><br><span class="line">	printf(&quot;------打印%s作业的页表-------\n&quot;,s);</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		if(!strcmp(s,p-&gt;name)) break;</span><br><span class="line">		printf(&quot;1\n&quot;);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p==NULL)&#123;</span><br><span class="line">		printf(&quot;未找到该作业\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=0;i&lt;p-&gt;sizenum;i++)&#123;</span><br><span class="line">		printf(&quot;    %-4d%-4d\n&quot;,p-&gt;size[i][0],p-&gt;size[i][1]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int operation()&#123;</span><br><span class="line">	int o;</span><br><span class="line">	printf(&quot;\n********分页式管理*********&quot;);</span><br><span class="line">	printf(&quot;\n    *   1、内存分配   *    &quot;);</span><br><span class="line">	printf(&quot;\n    *   2、内存去配   *    &quot;);</span><br><span class="line">	printf(&quot;\n    *   0、退出       *    &quot;);</span><br><span class="line">	printf(&quot;\n        请输入选项:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;o);</span><br><span class="line">	return o;</span><br><span class="line">&#125;</span><br><span class="line">void mem_malloc()&#123;  //内存分配 </span><br><span class="line">	int num;</span><br><span class="line">	node *p;</span><br><span class="line">	p=(node *)malloc(sizeof(node));</span><br><span class="line">	p-&gt;next=NULL;</span><br><span class="line">	printf(&quot;请输入作业名:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;,p-&gt;name);</span><br><span class="line">	printf(&quot;请输入需要分配的大小:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">	num/=blocksize;</span><br><span class="line">	p-&gt;sizenum=num;</span><br><span class="line">	if(num&gt;blocknum)&#123;</span><br><span class="line">		printf(&quot;空间不足!\n&quot;);</span><br><span class="line">		return; </span><br><span class="line">	&#125;</span><br><span class="line">	int i=0,j=0,k;</span><br><span class="line">	for(j=0;j&lt;num;j++) p-&gt;size[j][0]=j;</span><br><span class="line">	for(k=0;k&lt;num;k++)&#123;</span><br><span class="line">		for(i;i&lt;memorysize;i++)&#123;</span><br><span class="line">			if(sys[i]==1) continue;</span><br><span class="line">			sys[i]=1;</span><br><span class="line">			blocknum--;</span><br><span class="line">			p-&gt;size[k][1]=i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	node *q;</span><br><span class="line">	q=n;</span><br><span class="line">	while(q-&gt;next!=NULL)&#123;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;next=p;</span><br><span class="line">	printf(&quot;分配成功!\n&quot;);</span><br><span class="line">	print_sys();</span><br><span class="line">	print_table(p-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line">void mem_free()&#123;  //内存去配</span><br><span class="line"> 	char s[10];</span><br><span class="line">	printf(&quot;请输入你需要释放的作业:&quot;);</span><br><span class="line">	scanf(&quot; %s&quot;,s);</span><br><span class="line">	node *p;</span><br><span class="line">	node *q;</span><br><span class="line">	p=n-&gt;next;</span><br><span class="line">	q=n;</span><br><span class="line">	int i;</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		if(!strcmp(s,p-&gt;name)) break;</span><br><span class="line">		printf(&quot;%s\n&quot;,p-&gt;name);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p==NULL)&#123;</span><br><span class="line">		printf(&quot;无此作业,回收失败!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;next=p-&gt;next;</span><br><span class="line">	for(i=0;i&lt;p-&gt;sizenum;i++)&#123;</span><br><span class="line">		sys[p-&gt;size[i][1]]=0;</span><br><span class="line">		blocknum++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;该作业回收成功!\n&quot;);</span><br><span class="line">	print_sys();</span><br><span class="line">	free(p);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">    printf(&quot;请输入系统内存空间大小:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;memorysize);</span><br><span class="line">    printf(&quot;请输入字长16/32/64:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;wordlength);</span><br><span class="line">    printf(&quot;请输入物理块大小:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;blocksize);</span><br><span class="line">    int i,j,num=0;</span><br><span class="line">    for(i=0;i&lt;memorysize;i++)&#123;</span><br><span class="line">        sys[i]=rand()%2;</span><br><span class="line">        if(sys[i]==0) blocknum++;</span><br><span class="line">        srand(i);</span><br><span class="line">    &#125;</span><br><span class="line">    print_sys();</span><br><span class="line">    n=(node *)malloc(sizeof(node));</span><br><span class="line">    n-&gt;next=NULL;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">    	switch(operation())&#123;</span><br><span class="line">    		case 1:</span><br><span class="line">    			print_sys();</span><br><span class="line">    			mem_malloc();</span><br><span class="line">    			break;</span><br><span class="line">    		case 2:</span><br><span class="line">    			print_sys();</span><br><span class="line">    			mem_free();</span><br><span class="line">    			break;</span><br><span class="line">    		case 0:</span><br><span class="line">    			exit(0);</span><br><span class="line">    		default:</span><br><span class="line">    			continue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-04-14_225430.png" class="" title="2025-04-14_225430">

<h1 id="第十一周（选做）：段页式存储管理"><a href="#第十一周（选做）：段页式存储管理" class="headerlink" title="第十一周（选做）：段页式存储管理"></a>第十一周（选做）：段页式存储管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_MEMORY 2000</span><br><span class="line"></span><br><span class="line">typedef struct PageEntry &#123;</span><br><span class="line">    int page_num;</span><br><span class="line">    int block_num;</span><br><span class="line">    struct PageEntry* next;</span><br><span class="line">&#125; PageEntry;</span><br><span class="line"></span><br><span class="line">typedef struct SegmentEntry &#123;</span><br><span class="line">    int seg_num;</span><br><span class="line">    int page_count;</span><br><span class="line">    PageEntry* page_table;  //页表</span><br><span class="line">    struct SegmentEntry* next;</span><br><span class="line">&#125; SegmentEntry;</span><br><span class="line"></span><br><span class="line">typedef struct Job &#123;</span><br><span class="line">    char name[10];</span><br><span class="line">	int job_length; //作业大小</span><br><span class="line">    int seg_count;  //段数</span><br><span class="line">    SegmentEntry* seg_table;//段表</span><br><span class="line">    struct Job* next;</span><br><span class="line">&#125; Job;</span><br><span class="line"></span><br><span class="line">int memory_size;</span><br><span class="line">int word_length;</span><br><span class="line">int block_size;</span><br><span class="line">int free_blocks = 0;</span><br><span class="line">int bitmap[MAX_MEMORY];</span><br><span class="line">Job* job_list = NULL;</span><br><span class="line"></span><br><span class="line">void print_bitmap() &#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    printf(&quot;主存位示图如下:\n&quot;);</span><br><span class="line">    printf(&quot;  &quot;);</span><br><span class="line">    for(i=0;i&lt;word_length;i++)&#123;</span><br><span class="line">    	printf(&quot; %2d&quot;,i);</span><br><span class="line">	&#125;</span><br><span class="line">    for(i=0;i&lt;memory_size;i++)&#123;</span><br><span class="line">		if(i%word_length==0) printf(&quot;\n%-2d| &quot;,i/word_length);</span><br><span class="line">        printf(&quot;%-2d &quot;,bitmap[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n剩余物理块数:%d\n&quot;,free_blocks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_job_table(char name[]) &#123;</span><br><span class="line">    </span><br><span class="line">    Job* curr = job_list;</span><br><span class="line">    while (curr != NULL &amp;&amp; strcmp(curr-&gt;name, name) != 0)</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    </span><br><span class="line">    if (curr == NULL) &#123;</span><br><span class="line">        printf(&quot;作业不存在！\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n作业 %s 的分配情况如下：\n&quot;, name);</span><br><span class="line">    SegmentEntry* seg = curr-&gt;seg_table;</span><br><span class="line">    while (seg != NULL) &#123;</span><br><span class="line">        printf(&quot;  第%d段:\n&quot;, seg-&gt;seg_num);</span><br><span class="line">		printf(&quot;      页号   块号\n&quot;);</span><br><span class="line">        PageEntry* page = seg-&gt;page_table;</span><br><span class="line">        while (page != NULL) &#123;</span><br><span class="line">            printf(&quot;      %-7d%d\n&quot;, </span><br><span class="line">                   page-&gt;page_num, page-&gt;block_num);</span><br><span class="line">            page = page-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        seg = seg-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void allocate_memory() &#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int seg_count, total_pages = 0;</span><br><span class="line">	int len=0;</span><br><span class="line">	print_bitmap();</span><br><span class="line">    </span><br><span class="line">    printf(&quot;\n输入作业名: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, name);</span><br><span class="line">    </span><br><span class="line">    // 检查重名</span><br><span class="line">    Job* curr = job_list;</span><br><span class="line">    while (curr != NULL) &#123;</span><br><span class="line">        if (strcmp(curr-&gt;name, name) == 0) &#123;</span><br><span class="line">            printf(&quot;作业名已存在！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">	printf(&quot;请输入%s所需主存大小: &quot;,name);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">	if(len/word_length&gt;free_blocks)&#123;</span><br><span class="line">		printf(&quot;空间不足!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入要将作业分为几段: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;seg_count);</span><br><span class="line">	int free_size=len; </span><br><span class="line">    int* pages_per_seg = (int*)malloc(seg_count * sizeof(int));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; seg_count; i++) &#123;</span><br><span class="line">        printf(&quot;剩余%d的内存未分配,请输入第%d段的大小: &quot;,free_size, i);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;pages_per_seg[i]);</span><br><span class="line">		printf(&quot;内存分配成功!\n&quot;);</span><br><span class="line">		free_size-=pages_per_seg[i];</span><br><span class="line">        total_pages += pages_per_seg[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建新作业</span><br><span class="line">    Job* new_job = (Job*)malloc(sizeof(Job));</span><br><span class="line">	new_job-&gt;job_length=len;</span><br><span class="line">    strcpy(new_job-&gt;name, name);</span><br><span class="line">    new_job-&gt;seg_count = seg_count;</span><br><span class="line">    new_job-&gt;seg_table = NULL;</span><br><span class="line">    new_job-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    // 分配段表</span><br><span class="line">    for (int i = 0; i &lt; seg_count; i++) &#123;</span><br><span class="line">        SegmentEntry* seg = (SegmentEntry*)malloc(sizeof(SegmentEntry));</span><br><span class="line">        seg-&gt;seg_num = i;</span><br><span class="line">        seg-&gt;page_count = pages_per_seg[i];</span><br><span class="line">        seg-&gt;page_table = NULL;</span><br><span class="line">        seg-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">        // 分配页表</span><br><span class="line">        for (int j = 0; j &lt; pages_per_seg[i]; j++) &#123;</span><br><span class="line">            // 查找空闲块</span><br><span class="line">            int k;</span><br><span class="line">            for (k = 0; k &lt; memory_size; k++) &#123;</span><br><span class="line">                if (bitmap[k] == 0) break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (k &gt;= memory_size) &#123;</span><br><span class="line">                printf(&quot;分配意外失败！\n&quot;);</span><br><span class="line">                free(pages_per_seg);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 更新位示图</span><br><span class="line">            bitmap[k] = 1;</span><br><span class="line">            free_blocks--;</span><br><span class="line"></span><br><span class="line">            // 创建页表项</span><br><span class="line">            PageEntry* page = (PageEntry*)malloc(sizeof(PageEntry));</span><br><span class="line">            page-&gt;page_num = j;</span><br><span class="line">            page-&gt;block_num = k;</span><br><span class="line">            page-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">            // 添加到页表</span><br><span class="line">            if (seg-&gt;page_table == NULL) &#123;</span><br><span class="line">                seg-&gt;page_table = page;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                PageEntry* p = seg-&gt;page_table;</span><br><span class="line">                while (p-&gt;next != NULL) p = p-&gt;next;</span><br><span class="line">                p-&gt;next = page;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加到段表</span><br><span class="line">        if (new_job-&gt;seg_table == NULL) &#123;</span><br><span class="line">            new_job-&gt;seg_table = seg;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            SegmentEntry* s = new_job-&gt;seg_table;</span><br><span class="line">            while (s-&gt;next != NULL) s = s-&gt;next;</span><br><span class="line">            s-&gt;next = seg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加到作业链表</span><br><span class="line">    if (job_list == NULL) &#123;</span><br><span class="line">        job_list = new_job;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Job* p = job_list;</span><br><span class="line">        while (p-&gt;next != NULL) p = p-&gt;next;</span><br><span class="line">        p-&gt;next = new_job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(pages_per_seg);</span><br><span class="line">    print_bitmap();</span><br><span class="line">	print_job_table(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void free_memory() &#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    printf(&quot;\n请输入作业名: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, name);</span><br><span class="line"></span><br><span class="line">    Job *prev = NULL, *curr = job_list;</span><br><span class="line">    while (curr != NULL &amp;&amp; strcmp(curr-&gt;name, name) != 0) &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (curr == NULL) &#123;</span><br><span class="line">        printf(&quot;作业不存在！\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从链表移除</span><br><span class="line">    if (prev == NULL) &#123;</span><br><span class="line">        job_list = curr-&gt;next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev-&gt;next = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 释放段表</span><br><span class="line">    SegmentEntry* seg = curr-&gt;seg_table;</span><br><span class="line">    while (seg != NULL) &#123;</span><br><span class="line">        // 释放页表</span><br><span class="line">        PageEntry* page = seg-&gt;page_table;</span><br><span class="line">        while (page != NULL) &#123;</span><br><span class="line">            bitmap[page-&gt;block_num] = 0; // 更新位示图</span><br><span class="line">            free_blocks++;</span><br><span class="line">            PageEntry* temp = page;</span><br><span class="line">            page = page-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        SegmentEntry* temp_seg = seg;</span><br><span class="line">        seg = seg-&gt;next;</span><br><span class="line">        free(temp_seg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(curr);</span><br><span class="line">    printf(&quot;去配成功！\n&quot;, name);</span><br><span class="line">    print_bitmap();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    </span><br><span class="line">    printf(&quot;请输入内存总大小: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;memory_size);</span><br><span class="line">    printf(&quot;请输入系统字长大小（16/32/64）: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;word_length);</span><br><span class="line">    printf(&quot;请输入块长: &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;block_size);</span><br><span class="line"></span><br><span class="line">    // 初始化位示图</span><br><span class="line">    free_blocks = 0;</span><br><span class="line">    for (int i = 0; i &lt; memory_size; i++) &#123;</span><br><span class="line">        bitmap[i] = rand() % 2;</span><br><span class="line">        if (bitmap[i] == 0) free_blocks++;</span><br><span class="line">    &#125;</span><br><span class="line">	print_bitmap();</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;\n********可变分区管理*********&quot;);</span><br><span class="line">		printf(&quot;\n    *   1、内存分配   *    &quot;);</span><br><span class="line">		printf(&quot;\n    *   2、内存去配   *    &quot;);</span><br><span class="line">		printf(&quot;\n    *   0、退出       *   &quot;);</span><br><span class="line">		printf(&quot;\n        请输入选项:&quot;);</span><br><span class="line">        </span><br><span class="line">        int choice;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;choice);</span><br><span class="line">        </span><br><span class="line">        switch (choice) &#123;</span><br><span class="line">            case 1: allocate_memory(); break;</span><br><span class="line">            case 2: free_memory(); break;</span><br><span class="line">            case 0: exit(0);</span><br><span class="line">            default: printf(&quot;无效选项！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-04-21_234800.png" class="" title="2025-04-21_234800">

<h1 id="第十一周：分段式存储管理"><a href="#第十一周：分段式存储管理" class="headerlink" title="第十一周：分段式存储管理"></a>第十一周：分段式存储管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 分区节点结构体</span><br><span class="line">typedef struct link_node &#123;</span><br><span class="line">    int id;              // 分区ID</span><br><span class="line">    int size;            // 分区大小</span><br><span class="line">    int address;         // 起始地址</span><br><span class="line">    char flag[20];       // 状态</span><br><span class="line">    struct link_node* next;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">// 段表</span><br><span class="line">typedef struct segment_node &#123;</span><br><span class="line">    char job_name[20];   // 作业名称</span><br><span class="line">    int segments[10][3]; // [段号][大小, 基地址]</span><br><span class="line">    int segment_count;   // 段数量</span><br><span class="line">    struct segment_node* next;</span><br><span class="line">&#125; segmentNode;</span><br><span class="line"></span><br><span class="line">// 内存节点</span><br><span class="line">typedef struct memory_node &#123;</span><br><span class="line">    int size;    // 内存大小</span><br><span class="line">    int address; // 起始地址 </span><br><span class="line">&#125; memoryNode;</span><br><span class="line"></span><br><span class="line">// 全局变量</span><br><span class="line">memoryNode memory;</span><br><span class="line">node* free_list = NULL;      // 空闲分区链表</span><br><span class="line">node* allocated_list = NULL; // 已分配分区链表</span><br><span class="line">segmentNode* segment_list = NULL; // 段表链表</span><br><span class="line">int partition_id = 1;        // 全局分区ID计数器</span><br><span class="line"></span><br><span class="line">void initialize_memory();</span><br><span class="line">void display_menu();</span><br><span class="line">void display_partitions();</span><br><span class="line">node* find_first_fit(int size);</span><br><span class="line">void allocate_memory();</span><br><span class="line">void deallocate_memory();</span><br><span class="line">void add_segment(char* job_name, int segment_num, int size, int base_addr);</span><br><span class="line">void print_segment_table(char* job_name);</span><br><span class="line">void merge_free_partitions();</span><br><span class="line">int get_next_id();</span><br><span class="line">// 使用一个空闲分区初始化内存</span><br><span class="line">void initialize_memory() &#123;</span><br><span class="line">    node* new_node = (node*)malloc(sizeof(node));</span><br><span class="line">    new_node-&gt;id = partition_id++;</span><br><span class="line">    new_node-&gt;size = memory.size;</span><br><span class="line">    new_node-&gt;address = memory.address;</span><br><span class="line">    strcpy(new_node-&gt;flag, &quot;空闲&quot;);</span><br><span class="line">    new_node-&gt;next = NULL;</span><br><span class="line">    free_list = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示菜单</span><br><span class="line">void display_menu() &#123;</span><br><span class="line">    printf(&quot;*********可变分区管理**********\n&quot;);</span><br><span class="line">    printf(&quot;   *     1.内存分配      *\n&quot;);</span><br><span class="line">    printf(&quot;   *     2.内存去配      *\n&quot;);</span><br><span class="line">    printf(&quot;   *     0.退出          *\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示当前分区状态</span><br><span class="line">void display_partitions() &#123;</span><br><span class="line">    printf(&quot;******************主存分配情况*********************\n&quot;);</span><br><span class="line">    printf(&quot;已分配：\n&quot;);</span><br><span class="line">    printf(&quot;分配号  大小（KB）      起始（KB）      状态\n&quot;);</span><br><span class="line">    node* current = allocated_list;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        printf(&quot;%-8d%-16d%-16d%s\n&quot;, current-&gt;id, current-&gt;size, current-&gt;address, current-&gt;flag);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n未分配：\n&quot;);</span><br><span class="line">    printf(&quot;分配号  大小（KB）      起始（KB）      状态\n&quot;);</span><br><span class="line">    current = free_list;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        printf(&quot;%-8d%-16d%-16d%s\n&quot;, current-&gt;id, current-&gt;size, current-&gt;address, current-&gt;flag);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找首次适应的空闲分区</span><br><span class="line">node* find_first_fit(int size) &#123;</span><br><span class="line">    node* current = free_list;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (current-&gt;size &gt;= size) &#123;</span><br><span class="line">            return current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为作业分配内存</span><br><span class="line">void allocate_memory() &#123;</span><br><span class="line">    char job_name[20];</span><br><span class="line">    int total_size, segments, remaining_size;</span><br><span class="line">    printf(&quot;请输入作业名:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, job_name);</span><br><span class="line">    printf(&quot;请输入%s需要分配的主存大小:&quot;, job_name);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;total_size);</span><br><span class="line">    printf(&quot;请输入要分成几段：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;segments);</span><br><span class="line">    </span><br><span class="line">    remaining_size = total_size;</span><br><span class="line">    int segment_sizes[10];</span><br><span class="line">    </span><br><span class="line">    // 逐个分配每个段</span><br><span class="line">    for (int i = 0; i &lt; segments; i++) &#123;</span><br><span class="line">        printf(&quot;剩余%dKB的内存，请输入第%d段的大小：&quot;, remaining_size, i + 1);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;segment_sizes[i]);</span><br><span class="line">        if (segment_sizes[i] &gt; remaining_size) &#123;</span><br><span class="line">            printf(&quot;段大小超过剩余内存，分配失败！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining_size -= segment_sizes[i];</span><br><span class="line">        </span><br><span class="line">        // 查找空闲分区</span><br><span class="line">        node* free_partition = find_first_fit(segment_sizes[i]);</span><br><span class="line">        if (!free_partition) &#123;</span><br><span class="line">            printf(&quot;没有足够的空闲分区，分配失败！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建已分配分区（复用空闲分区ID）</span><br><span class="line">        node* allocated = (node*)malloc(sizeof(node));</span><br><span class="line">        allocated-&gt;id = free_partition-&gt;id;</span><br><span class="line">        allocated-&gt;size = segment_sizes[i];</span><br><span class="line">        allocated-&gt;address = free_partition-&gt;address;</span><br><span class="line">        sprintf(allocated-&gt;flag, &quot;%s%d&quot;, job_name, i);</span><br><span class="line">        allocated-&gt;next = NULL;</span><br><span class="line">        </span><br><span class="line">        // 添加到已分配链表</span><br><span class="line">        if (!allocated_list) &#123;</span><br><span class="line">            allocated_list = allocated;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node* temp = allocated_list;</span><br><span class="line">            while (temp-&gt;next) temp = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = allocated;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 更新空闲分区</span><br><span class="line">        free_partition-&gt;size -= segment_sizes[i];</span><br><span class="line">        free_partition-&gt;address += segment_sizes[i];</span><br><span class="line">        if (free_partition-&gt;size == 0) &#123;</span><br><span class="line">            // 移除空空闲分区</span><br><span class="line">            node* prev = NULL;</span><br><span class="line">            node* current = free_list;</span><br><span class="line">            while (current != free_partition) &#123;</span><br><span class="line">                prev = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (prev) &#123;</span><br><span class="line">                prev-&gt;next = free_partition-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                free_list = free_partition-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            free(free_partition);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 为剩余空闲分区分配新ID</span><br><span class="line">            free_partition-&gt;id = get_next_id();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 添加到段表</span><br><span class="line">        add_segment(job_name, i, segment_sizes[i], allocated-&gt;address);</span><br><span class="line">        display_partitions();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (remaining_size != 0) &#123;</span><br><span class="line">        printf(&quot;分配的段大小总和不等于总大小，分配失败！\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;分配成功！\n&quot;);</span><br><span class="line">    printf(&quot;************打印%s段表************\n&quot;, job_name);</span><br><span class="line">    print_segment_table(job_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取下一个可用ID</span><br><span class="line">int get_next_id() &#123;</span><br><span class="line">    int max_id = 0;</span><br><span class="line">    node* current = allocated_list;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (current-&gt;id &gt; max_id) max_id = current-&gt;id;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_id + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放作业占用的内存</span><br><span class="line">void deallocate_memory() &#123;</span><br><span class="line">    display_partitions();</span><br><span class="line">    char job_name[20];</span><br><span class="line">    printf(&quot;请输入您想回收的作业名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, job_name);</span><br><span class="line">    </span><br><span class="line">    // 在段表中查找对应的段</span><br><span class="line">    segmentNode* seg = segment_list;</span><br><span class="line">    int found = 0;</span><br><span class="line">    while (seg) &#123;</span><br><span class="line">        if (strcmp(seg-&gt;job_name, job_name) == 0) &#123;</span><br><span class="line">            found = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        seg = seg-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!found) &#123;</span><br><span class="line">        printf(&quot;未找到作业%s的段表！\n&quot;, job_name);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理每个段</span><br><span class="line">    for (int i = 0; i &lt; seg-&gt;segment_count; i++) &#123;</span><br><span class="line">        char segment_flag[20];</span><br><span class="line">        sprintf(segment_flag, &quot;%s%d&quot;, job_name, i);</span><br><span class="line">        </span><br><span class="line">        // 从已分配链表中查找并移除</span><br><span class="line">        node* prev = NULL;</span><br><span class="line">        node* current = allocated_list;</span><br><span class="line">        while (current &amp;&amp; strcmp(current-&gt;flag, segment_flag) != 0) &#123;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (current) &#123;</span><br><span class="line">            if (prev) &#123;</span><br><span class="line">                prev-&gt;next = current-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                allocated_list = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 创建新空闲分区</span><br><span class="line">            node* new_free = (node*)malloc(sizeof(node));</span><br><span class="line">            new_free-&gt;id = get_next_id();</span><br><span class="line">            new_free-&gt;size = current-&gt;size;</span><br><span class="line">            new_free-&gt;address = current-&gt;address;</span><br><span class="line">            strcpy(new_free-&gt;flag, &quot;空闲&quot;);</span><br><span class="line">            new_free-&gt;next = NULL;</span><br><span class="line">            </span><br><span class="line">            // 添加到空闲链表</span><br><span class="line">            if (!free_list) &#123;</span><br><span class="line">                free_list = new_free;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node* temp = free_list;</span><br><span class="line">                while (temp-&gt;next) temp = temp-&gt;next;</span><br><span class="line">                temp-&gt;next = new_free;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            free(current);</span><br><span class="line">            printf(&quot;回收%s的段%s成功！\n&quot;, job_name, segment_flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从段表链表中移除</span><br><span class="line">    segmentNode* prev_seg = NULL;</span><br><span class="line">    seg = segment_list;</span><br><span class="line">    while (seg &amp;&amp; strcmp(seg-&gt;job_name, job_name) != 0) &#123;</span><br><span class="line">        prev_seg = seg;</span><br><span class="line">        seg = seg-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (seg) &#123;</span><br><span class="line">        if (prev_seg) &#123;</span><br><span class="line">            prev_seg-&gt;next = seg-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            segment_list = seg-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        free(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 合并相邻的空闲分区</span><br><span class="line">    merge_free_partitions();</span><br><span class="line">    </span><br><span class="line">    // 为所有空闲分区更新ID</span><br><span class="line">    node* current = free_list;</span><br><span class="line">    int new_id = get_next_id();</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        current-&gt;id = new_id++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    display_partitions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加段到段表</span><br><span class="line">void add_segment(char* job_name, int segment_num, int size, int base_addr) &#123;</span><br><span class="line">    segmentNode* seg = segment_list;</span><br><span class="line">    while (seg &amp;&amp; strcmp(seg-&gt;job_name, job_name) != 0) &#123;</span><br><span class="line">        seg = seg-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!seg) &#123;</span><br><span class="line">        // 创建新段表节点并添加到链表头部</span><br><span class="line">        seg = (segmentNode*)malloc(sizeof(segmentNode));</span><br><span class="line">        strcpy(seg-&gt;job_name, job_name);</span><br><span class="line">        seg-&gt;segment_count = 0;</span><br><span class="line">        seg-&gt;next = segment_list;</span><br><span class="line">        segment_list = seg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    seg-&gt;segments[seg-&gt;segment_count][0] = segment_num;</span><br><span class="line">    seg-&gt;segments[seg-&gt;segment_count][1] = size;</span><br><span class="line">    seg-&gt;segments[seg-&gt;segment_count][2] = base_addr;</span><br><span class="line">    seg-&gt;segment_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印作业的段表</span><br><span class="line">void print_segment_table(char* job_name) &#123;</span><br><span class="line">    printf(&quot;段号    段长    基址\n&quot;);</span><br><span class="line">    segmentNode* seg = segment_list;</span><br><span class="line">    while (seg &amp;&amp; strcmp(seg-&gt;job_name, job_name) != 0) &#123;</span><br><span class="line">        seg = seg-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (seg) &#123;</span><br><span class="line">        for (int i = 0; i &lt; seg-&gt;segment_count; i++) &#123;</span><br><span class="line">            printf(&quot;%-8d%-8d%d\n&quot;, </span><br><span class="line">                seg-&gt;segments[i][0], </span><br><span class="line">                seg-&gt;segments[i][1], </span><br><span class="line">                seg-&gt;segments[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合并相邻的空闲分区</span><br><span class="line">void merge_free_partitions() &#123;</span><br><span class="line">    // 按起始地址对空闲链表进行排序</span><br><span class="line">    node* sorted = NULL;</span><br><span class="line">    node* current = free_list;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        node* next = current-&gt;next;</span><br><span class="line">        if (!sorted || sorted-&gt;address &gt; current-&gt;address) &#123;</span><br><span class="line">            current-&gt;next = sorted;</span><br><span class="line">            sorted = current;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node* temp = sorted;</span><br><span class="line">            while (temp-&gt;next &amp;&amp; temp-&gt;next-&gt;address &lt; current-&gt;address) &#123;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            current-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    free_list = sorted;</span><br><span class="line">    </span><br><span class="line">    // 合并相邻的空闲分区</span><br><span class="line">    current = free_list;</span><br><span class="line">    while (current &amp;&amp; current-&gt;next) &#123;</span><br><span class="line">        if (current-&gt;address + current-&gt;size == current-&gt;next-&gt;address) &#123;</span><br><span class="line">            current-&gt;size += current-&gt;next-&gt;size;</span><br><span class="line">            node* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = temp-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化内存</span><br><span class="line">    printf(&quot;请输入内存大小：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;memory.size);</span><br><span class="line">    printf(&quot;请输入起始地址：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;memory.address);</span><br><span class="line">    initialize_memory();</span><br><span class="line">    </span><br><span class="line">    int choice;</span><br><span class="line">    do &#123;</span><br><span class="line">        display_menu();</span><br><span class="line">        printf(&quot;         请输入选项: &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;choice);</span><br><span class="line">        switch (choice) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1.内存分配\n&quot;);</span><br><span class="line">            display_partitions();</span><br><span class="line">            allocate_memory();</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;2.内存去配\n&quot;);</span><br><span class="line">            deallocate_memory();</span><br><span class="line">            break;</span><br><span class="line">        case 0:</span><br><span class="line">            printf(&quot;0.退出\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;无效选项，请重新输入！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (choice != 0);</span><br><span class="line">    </span><br><span class="line">    // 释放内存</span><br><span class="line">    node* temp;</span><br><span class="line">    while (free_list) &#123;</span><br><span class="line">        temp = free_list;</span><br><span class="line">        free_list = free_list-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    while (allocated_list) &#123;</span><br><span class="line">        temp = allocated_list;</span><br><span class="line">        allocated_list = allocated_list-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    segmentNode* temp_seg;</span><br><span class="line">    while (segment_list) &#123;</span><br><span class="line">        temp_seg = segment_list;</span><br><span class="line">        segment_list = segment_list-&gt;next;</span><br><span class="line">        free(temp_seg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-04-22_084440.png" class="" title="2025-04-22_084440">

<h1 id="第十二周：页面置换"><a href="#第十二周：页面置换" class="headerlink" title="第十二周：页面置换"></a>第十二周：页面置换</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 1010</span><br><span class="line"></span><br><span class="line">int n, m, ss[N];</span><br><span class="line">int ans[N][N]; // ans[i][0]表示第i次访问是否缺页，1为缺页；后续存主存状态</span><br><span class="line">int v[N];      // 当前内存中的页</span><br><span class="line">int evicted_pages[N]; // 记录每次缺页时被替换出的页面(没有替换则为-1)</span><br><span class="line"></span><br><span class="line">void out() &#123;</span><br><span class="line">	printf(&quot;**********请求分页式存储管理**********\n&quot;);</span><br><span class="line">	printf(&quot;        *   1. FIFO分配         *\n&quot;);</span><br><span class="line">	printf(&quot;        *   2. LRU (LFU) 分配   *\n&quot;);</span><br><span class="line">	printf(&quot;        *   0. 退出             *\n&quot;);</span><br><span class="line">	printf(&quot;            请输入选项: &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(char *jobname) &#123;</span><br><span class="line">	printf(&quot;请输入作业名: &quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, jobname);</span><br><span class="line">	printf(&quot;请输入作业页面长度: &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">	printf(&quot;请输入作业页面顺序: \n&quot;);</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;ss[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// FIFO算法</span><br><span class="line">void solve1() &#123;</span><br><span class="line">	int front = 0, rear = 0;</span><br><span class="line">	int queue[N] = &#123;0&#125;;</span><br><span class="line">	int mem_cnt = 0;</span><br><span class="line">	memset(evicted_pages, -1, sizeof(evicted_pages)); // 初始化evicted</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		int page = ss[i];</span><br><span class="line">		int found = 0;</span><br><span class="line">		</span><br><span class="line">		// 查找是否已在内存中</span><br><span class="line">		for (int j = 0; j &lt; mem_cnt; j++) &#123;</span><br><span class="line">			if (v[j] == page) &#123;</span><br><span class="line">				found = 1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (!found) &#123;</span><br><span class="line">			ans[i][0] = 1; // 缺页</span><br><span class="line">			if (mem_cnt &lt; n) &#123;</span><br><span class="line">				v[mem_cnt++] = page;</span><br><span class="line">				queue[rear++ % n] = page;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				int old = queue[front++ % n];</span><br><span class="line">				for (int j = 0; j &lt; n-1; j++) &#123;</span><br><span class="line">					v[j]=v[j+1];</span><br><span class="line">				&#125;</span><br><span class="line">				v[n-1]=page;</span><br><span class="line">				evicted_pages[i]=old;</span><br><span class="line">				queue[rear++ % n] = page;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ans[i][0] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 保存当前内存状态</span><br><span class="line">		for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">			ans[i][j + 1] = (j &lt; mem_cnt) ? v[mem_cnt-j-1] : -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// LRU算法</span><br><span class="line">void solve2() &#123;</span><br><span class="line">	int mem_cnt = 0;</span><br><span class="line">	int lru_stack[N] = &#123;0&#125;; // 按使用顺序排列的内存页</span><br><span class="line">	memset(evicted_pages, -1, sizeof(evicted_pages)); // 初始化evicted</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		int page = ss[i];</span><br><span class="line">		int found = 0, pos = -1;</span><br><span class="line">		</span><br><span class="line">		// 查找是否在内存中</span><br><span class="line">		for (int j = 0; j &lt; mem_cnt; j++) &#123;</span><br><span class="line">			if (lru_stack[j] == page) &#123;</span><br><span class="line">				found = 1;</span><br><span class="line">				pos = j;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (found) &#123;</span><br><span class="line">			ans[i][0] = 0;</span><br><span class="line">			// 提升到最近使用</span><br><span class="line">			for (int j = pos; j &lt; mem_cnt - 1; j++) &#123;</span><br><span class="line">				lru_stack[j] = lru_stack[j + 1];</span><br><span class="line">			&#125;</span><br><span class="line">			lru_stack[mem_cnt - 1] = page;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			ans[i][0] = 1;</span><br><span class="line">			if (mem_cnt &lt; n) &#123;</span><br><span class="line">				v[mem_cnt] = page;</span><br><span class="line">				lru_stack[mem_cnt++] = page;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				int old=lru_stack[0];</span><br><span class="line">				// 替换最久未使用的页面（队首）</span><br><span class="line">				evicted_pages[i]=lru_stack[0];</span><br><span class="line">				for (int j = 0; j &lt; n - 1; j++) &#123;</span><br><span class="line">					lru_stack[j] = lru_stack[j + 1];</span><br><span class="line">				&#125;</span><br><span class="line">				lru_stack[n - 1] = page;</span><br><span class="line">				for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">					v[j]=lru_stack[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 保存当前状态</span><br><span class="line">		for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">			ans[i][j + 1] = (j &lt; mem_cnt) ? v[mem_cnt-j-1] : -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(char *jobname) &#123;</span><br><span class="line">	printf(&quot;作业名: %s\n&quot;, jobname);</span><br><span class="line">	printf(&quot;作业调度过程:\n&quot;);</span><br><span class="line">	</span><br><span class="line">	// 打印表头</span><br><span class="line">	printf(&quot;     &quot;);</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		printf(&quot;%2d &quot;, i);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n     &quot;);</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		printf(&quot;%2d &quot;, ss[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	int div=0;</span><br><span class="line">	// 打印每个物理块状态</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		printf(&quot;%d    &quot;,div++);</span><br><span class="line">		for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">			if (ans[j][i + 1] != -1)</span><br><span class="line">				printf(&quot;%2d &quot;, ans[j][i + 1]);</span><br><span class="line">			else</span><br><span class="line">				printf(&quot;   &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 打印缺页标识</span><br><span class="line">	printf(&quot;     &quot;);</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		if (ans[i][0] == 1)</span><br><span class="line">			printf(&quot; + &quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;   &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	//打印缺页</span><br><span class="line">	printf(&quot;     &quot;);</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		if (evicted_pages[i] == -1)</span><br><span class="line">			printf(&quot;   &quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%2d &quot;,evicted_pages[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	</span><br><span class="line">	// 缺页率统计</span><br><span class="line">	int faults = 0;</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		if (ans[i][0] == 1)</span><br><span class="line">			faults++;</span><br><span class="line">	&#125;</span><br><span class="line">	double rate = 100.0 * faults / m;</span><br><span class="line">	printf(&quot;\n缺页中断率为: %.2f\n&quot;, rate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	printf(&quot;请输入物理块的块数: &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	</span><br><span class="line">	out();</span><br><span class="line">	int f;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;f);</span><br><span class="line">	</span><br><span class="line">	while (f != 0) &#123;</span><br><span class="line">		char jobname[100];</span><br><span class="line">		input(jobname);</span><br><span class="line">		memset(ans, -1, sizeof(ans));</span><br><span class="line">		memset(v, -1, sizeof(v));</span><br><span class="line">		</span><br><span class="line">		if (f == 1) &#123;</span><br><span class="line">			solve1();</span><br><span class="line">            printf(&quot;**********打印作业FIFO调度进入主存页的过程**********\n&quot;);</span><br><span class="line">			print(jobname);</span><br><span class="line">		&#125; else if (f == 2) &#123;</span><br><span class="line">			solve2();</span><br><span class="line">            printf(&quot;**********打印作业LRU调度进入主存页的过程**********\n&quot;);</span><br><span class="line">			print(jobname);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;无效选项\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		out();</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;f);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-05-06_092241.png" class="" title="2025-05-06_092241">

<h1 id="第十三周：设备分配回收"><a href="#第十三周：设备分配回收" class="headerlink" title="第十三周：设备分配回收"></a>第十三周：设备分配回收</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_SDT 10</span><br><span class="line">#define MAX_DCT 100</span><br><span class="line">#define MAX_COCT 100</span><br><span class="line">#define MAX_CHCT 10</span><br><span class="line">#define MAX_LUT 100</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char type[20];</span><br><span class="line">    int total;</span><br><span class="line">    int available;</span><br><span class="line">    int dct_start;</span><br><span class="line">&#125; SDTEntry;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int abs_num;</span><br><span class="line">    char type[20];</span><br><span class="line">    int is_good;</span><br><span class="line">    char free[20];</span><br><span class="line">    int rel_num;</span><br><span class="line">&#125; DCTEntry;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int num;</span><br><span class="line">    char name[20];</span><br><span class="line">    int is_good;</span><br><span class="line">    char free[20];</span><br><span class="line">    int channel;</span><br><span class="line">&#125; COCTEntry;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int channel_num;</span><br><span class="line">    int controllers[MAX_COCT];</span><br><span class="line">    int controller_count;</span><br><span class="line">&#125; CHCTEntry;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char job_name[20];</span><br><span class="line">    int sdt_index;</span><br><span class="line">    int rel_num;</span><br><span class="line">    int abs_num;</span><br><span class="line">&#125; LUTEntry;</span><br><span class="line"></span><br><span class="line">SDTEntry sdt[MAX_SDT];</span><br><span class="line">int sdt_count = 0;</span><br><span class="line"></span><br><span class="line">DCTEntry dct[MAX_DCT];</span><br><span class="line">int dct_count = 0;</span><br><span class="line"></span><br><span class="line">COCTEntry coct[MAX_COCT];</span><br><span class="line">int coct_count = 0;</span><br><span class="line"></span><br><span class="line">CHCTEntry chct[MAX_CHCT];</span><br><span class="line">int chct_count = 0;</span><br><span class="line"></span><br><span class="line">LUTEntry lut[MAX_LUT];</span><br><span class="line">int lut_count = 0;</span><br><span class="line"></span><br><span class="line">int remaining_controllers = 0;</span><br><span class="line"></span><br><span class="line">void init_COCT(int ch_num, int co_num) &#123;</span><br><span class="line">    coct_count = co_num;</span><br><span class="line">    for (int i = 0; i &lt; co_num; i++) &#123;</span><br><span class="line">        COCTEntry *c = &amp;coct[i];</span><br><span class="line">        c-&gt;num = i;</span><br><span class="line">        sprintf(c-&gt;name, &quot;control_%d&quot;, i);</span><br><span class="line">        c-&gt;is_good = (i == 0) ? 0 : 1;</span><br><span class="line">        strcpy(c-&gt;free, &quot;yes&quot;);</span><br><span class="line">        </span><br><span class="line">        if (i &lt; ch_num) &#123;</span><br><span class="line">            c-&gt;channel = i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (ch_num &gt; 1) &#123;</span><br><span class="line">                c-&gt;channel = 1 + (i - ch_num) % (ch_num - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                c-&gt;channel = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    remaining_controllers = 0;</span><br><span class="line">    for (int i = 0; i &lt; co_num; i++) &#123;</span><br><span class="line">        if (coct[i].is_good &amp;&amp; strcmp(coct[i].free, &quot;yes&quot;) == 0) &#123;</span><br><span class="line">            remaining_controllers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_CHCT(int ch_num) &#123;</span><br><span class="line">    chct_count = ch_num;</span><br><span class="line">    for (int i = 0; i &lt; ch_num; i++) &#123;</span><br><span class="line">        chct[i].channel_num = i;</span><br><span class="line">        chct[i].controller_count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; coct_count; i++) &#123;</span><br><span class="line">        int ch = coct[i].channel;</span><br><span class="line">        if (ch &lt; chct_count) &#123;</span><br><span class="line">            CHCTEntry *entry = &amp;chct[ch];</span><br><span class="line">            entry-&gt;controllers[entry-&gt;controller_count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_SDT() &#123;</span><br><span class="line">    printf(&quot;**********打印系统设备表SDT**********\n&quot;);</span><br><span class="line">    printf(&quot;设备类型 设备总数量 设备可用数量 设备DCT号\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; sdt_count; i++) &#123;</span><br><span class="line">        SDTEntry *s = &amp;sdt[i];</span><br><span class="line">        printf(&quot;%-9s %-11d %-12d %d\n&quot;, s-&gt;type, s-&gt;total, s-&gt;available, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_DCT() &#123;</span><br><span class="line">    printf(&quot;**********打印系统设备控制表DCT**********\n&quot;);</span><br><span class="line">    printf(&quot;设备绝对号 设备类型 设备好坏 设备空闲 设备相对号\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; dct_count; i++) &#123;</span><br><span class="line">        DCTEntry *d = &amp;dct[i];</span><br><span class="line">        printf(&quot;%-11d %-9s %-9s   %-8s   %d\n&quot;, </span><br><span class="line">              d-&gt;abs_num, d-&gt;type, </span><br><span class="line">              d-&gt;is_good ? &quot;好&quot; : &quot;坏&quot;, </span><br><span class="line">              d-&gt;free, d-&gt;rel_num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_COCT() &#123;</span><br><span class="line">    printf(&quot;**********系统控制器控制表COCT**********\n&quot;);</span><br><span class="line">    printf(&quot;编号 名字       好坏 空闲 所属通道\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; coct_count; i++) &#123;</span><br><span class="line">        COCTEntry *c = &amp;coct[i];</span><br><span class="line">        printf(&quot;%-4d %-10s %-4s   %-4s   %d\n&quot;,</span><br><span class="line">              c-&gt;num, c-&gt;name,</span><br><span class="line">              c-&gt;is_good ? &quot;好&quot; : &quot;坏&quot;,</span><br><span class="line">              c-&gt;free, c-&gt;channel);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;系统剩余可用控制器数量：%d\n&quot;, remaining_controllers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_CHCT() &#123;</span><br><span class="line">    printf(&quot;**********系统通道控制表CHCT**********\n&quot;);</span><br><span class="line">    printf(&quot;编号 通道内控制器序号\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; chct_count; i++) &#123;</span><br><span class="line">        CHCTEntry *ch = &amp;chct[i];</span><br><span class="line">        printf(&quot;%-4d &quot;, ch-&gt;channel_num);</span><br><span class="line">        for (int j = 0; j &lt; ch-&gt;controller_count; j++) &#123;</span><br><span class="line">            printf(&quot;%d&quot;, ch-&gt;controllers[j]);</span><br><span class="line">            if (j != ch-&gt;controller_count - 1) &#123;</span><br><span class="line">                printf(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改后的打印函数</span><br><span class="line">void print_LUT() &#123;</span><br><span class="line">    printf(&quot;**********系统逻辑单位表LUT**********\n&quot;);</span><br><span class="line">    </span><br><span class="line">    // 创建已处理作业的标记数组</span><br><span class="line">    char processed_jobs[MAX_LUT][20] = &#123;0&#125;;</span><br><span class="line">    int processed_count = 0;</span><br><span class="line">    </span><br><span class="line">    // 第一层循环：遍历所有LUT条目</span><br><span class="line">    for (int i = 0; i &lt; lut_count; i++) &#123;</span><br><span class="line">        char *current_job = lut[i].job_name;</span><br><span class="line">        </span><br><span class="line">        // 检查是否已处理过该作业</span><br><span class="line">        int is_processed = 0;</span><br><span class="line">        for (int j = 0; j &lt; processed_count; j++) &#123;</span><br><span class="line">            if (strcmp(processed_jobs[j], current_job) == 0) &#123;</span><br><span class="line">                is_processed = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (is_processed) continue;</span><br><span class="line">        </span><br><span class="line">        // 记录已处理作业</span><br><span class="line">        strcpy(processed_jobs[processed_count++], current_job);</span><br><span class="line">        </span><br><span class="line">        // 打印作业头</span><br><span class="line">        printf(&quot;%s占用设备的设备相对号和设备绝对号及SDT号：\n&quot;, current_job);</span><br><span class="line">        printf(&quot;设备相对号 设备绝对号 SDT号\n&quot;);</span><br><span class="line">        </span><br><span class="line">        // 第二层循环：打印该作业所有设备</span><br><span class="line">        for (int k = 0; k &lt; lut_count; k++) &#123;</span><br><span class="line">            if (strcmp(lut[k].job_name, current_job) == 0) &#123;</span><br><span class="line">                printf(&quot;%-10d %-11d %d\n&quot;, </span><br><span class="line">                      lut[k].rel_num, </span><br><span class="line">                      lut[k].abs_num, </span><br><span class="line">                      lut[k].sdt_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;); // 作业间空行分隔</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_device() &#123;</span><br><span class="line">    char type[20];</span><br><span class="line">    int count;</span><br><span class="line">    printf(&quot;请输入添加的设备类型：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, type);</span><br><span class="line">    printf(&quot;请输入添加的数量：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;count);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; sdt_count; i++) &#123;</span><br><span class="line">        if (strcmp(sdt[i].type, type) == 0) &#123;</span><br><span class="line">            printf(&quot;设备类型已存在！\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SDTEntry s;</span><br><span class="line">    strcpy(s.type, type);</span><br><span class="line">    s.total = count;</span><br><span class="line">    s.available = count - 1;</span><br><span class="line">    s.dct_start = dct_count;</span><br><span class="line">    sdt[sdt_count++] = s;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        DCTEntry d;</span><br><span class="line">        d.abs_num = dct_count;</span><br><span class="line">        strcpy(d.type, type);</span><br><span class="line">        d.is_good = (i == 0) ? 0 : 1;</span><br><span class="line">        strcpy(d.free, &quot;yes&quot;);</span><br><span class="line">        d.rel_num = i;</span><br><span class="line">        dct[dct_count++] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;添加成功！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void allocate_device() &#123;</span><br><span class="line">    char job_name[20], type[20];</span><br><span class="line">    int needed;</span><br><span class="line">    printf(&quot;请输入作业名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, job_name);</span><br><span class="line">    printf(&quot;请输入作业所需的设备类型：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, type);</span><br><span class="line">    </span><br><span class="line">    int sdt_index = -1;</span><br><span class="line">    SDTEntry *s;</span><br><span class="line">    for (int i = 0; i &lt; sdt_count; i++) &#123;</span><br><span class="line">        if (strcmp(sdt[i].type, type) == 0) &#123;</span><br><span class="line">            sdt_index = i;</span><br><span class="line">            s = &amp;sdt[i];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sdt_index == -1) &#123;</span><br><span class="line">        printf(&quot;设备类型不存在！\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;设备可用数量为：%d\n&quot;, s-&gt;available);</span><br><span class="line">    if (s-&gt;available &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;没有可用设备！\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;请输入作业所需的设备数量：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;needed);</span><br><span class="line">    if (needed &gt; s-&gt;available) &#123;</span><br><span class="line">        printf(&quot;所需数量超过可用数量！\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;**********打印%s设备控制表DCT**********\n&quot;, type);</span><br><span class="line">    printf(&quot;设备绝对号 设备类型 设备好坏 设备空闲 设备相对号\n&quot;);</span><br><span class="line">    for (int i = s-&gt;dct_start; i &lt; s-&gt;dct_start + s-&gt;total; i++) &#123;</span><br><span class="line">        DCTEntry *d = &amp;dct[i];</span><br><span class="line">        printf(&quot;%-11d %-9s %-9s   %-8s   %d\n&quot;, </span><br><span class="line">            d-&gt;abs_num, d-&gt;type,</span><br><span class="line">            d-&gt;is_good ? &quot;好&quot; : &quot;坏&quot;,</span><br><span class="line">            d-&gt;free, d-&gt;rel_num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int n = 0; n &lt; needed; n++) &#123;</span><br><span class="line">        int rel_num;</span><br><span class="line">        printf(&quot;请输入你选择的设备的设备相对号：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;rel_num);</span><br><span class="line">        </span><br><span class="line">        int found = 0;</span><br><span class="line">        for (int i = s-&gt;dct_start; i &lt; s-&gt;dct_start + s-&gt;total; i++) &#123;</span><br><span class="line">            DCTEntry *d = &amp;dct[i];</span><br><span class="line">            if (d-&gt;rel_num == rel_num &amp;&amp; d-&gt;is_good &amp;&amp; strcmp(d-&gt;free, &quot;yes&quot;) == 0) &#123;</span><br><span class="line">                found = 1;</span><br><span class="line">                </span><br><span class="line">                int co_found = 0;</span><br><span class="line">                for (int j = 0; j &lt; coct_count; j++) &#123;</span><br><span class="line">                    COCTEntry *c = &amp;coct[j];</span><br><span class="line">                    if (c-&gt;is_good &amp;&amp; strcmp(c-&gt;free, &quot;yes&quot;) == 0) &#123;</span><br><span class="line">                        co_found = 1;</span><br><span class="line">                        </span><br><span class="line">                        strcpy(d-&gt;free, job_name);</span><br><span class="line">                        sprintf(c-&gt;free, &quot;%d&quot;, d-&gt;abs_num);</span><br><span class="line">                        </span><br><span class="line">                        LUTEntry l;</span><br><span class="line">                        strcpy(l.job_name, job_name);</span><br><span class="line">                        l.sdt_index = sdt_index;</span><br><span class="line">                        l.rel_num = rel_num;</span><br><span class="line">                        l.abs_num = d-&gt;abs_num;</span><br><span class="line">                        lut[lut_count++] = l;</span><br><span class="line">                        </span><br><span class="line">                        s-&gt;available--;</span><br><span class="line">                        remaining_controllers--;</span><br><span class="line">                        printf(&quot;分配成功！\n&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (!co_found) &#123;</span><br><span class="line">                    printf(&quot;分配失败，无可用控制器！\n&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!found) &#123;</span><br><span class="line">            printf(&quot;分配失败，请重新申请！\n&quot;);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_LUT();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release_device() &#123;</span><br><span class="line">    char job_name[20];</span><br><span class="line">    printf(&quot;请输入要回收的作业名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, job_name);</span><br><span class="line">    </span><br><span class="line">    int released = 0;</span><br><span class="line">    for (int i = 0; i &lt; lut_count; i++) &#123;</span><br><span class="line">        if (strcmp(lut[i].job_name, job_name) == 0) &#123;</span><br><span class="line">            int abs_num = lut[i].abs_num;</span><br><span class="line">            char abs_str[20];</span><br><span class="line">            sprintf(abs_str, &quot;%d&quot;, abs_num);</span><br><span class="line">            </span><br><span class="line">            DCTEntry *d = &amp;dct[abs_num];</span><br><span class="line">            strcpy(d-&gt;free, &quot;yes&quot;);</span><br><span class="line">            </span><br><span class="line">            for (int j = 0; j &lt; coct_count; j++) &#123;</span><br><span class="line">                if (strcmp(coct[j].free, abs_str) == 0) &#123;</span><br><span class="line">                    strcpy(coct[j].free, &quot;yes&quot;);</span><br><span class="line">                    remaining_controllers++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sdt[lut[i].sdt_index].available++;</span><br><span class="line">            </span><br><span class="line">            for (int j = i; j &lt; lut_count - 1; j++) &#123;</span><br><span class="line">                lut[j] = lut[j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">            lut_count--;</span><br><span class="line">            i--;</span><br><span class="line">            released = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (released) &#123;</span><br><span class="line">        printf(&quot;回收成功！\n&quot;);</span><br><span class="line">        print_LUT();</span><br><span class="line">        print_SDT();</span><br><span class="line">        print_DCT();</span><br><span class="line">        print_COCT();</span><br><span class="line">        print_CHCT();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;回收失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int ch_num, co_num;</span><br><span class="line">    printf(&quot;请输入通道的数量：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;ch_num);</span><br><span class="line">    printf(&quot;请输入控制器的数量：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;co_num);</span><br><span class="line">    </span><br><span class="line">    init_COCT(ch_num, co_num);</span><br><span class="line">    init_CHCT(ch_num);</span><br><span class="line">    </span><br><span class="line">    int choice;</span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;\n**********设备独占分配管理**********\n&quot;);</span><br><span class="line">        printf(&quot;      *   1.设备添加   *\n&quot;);</span><br><span class="line">        printf(&quot;      *   2.设备分配   *\n&quot;);</span><br><span class="line">        printf(&quot;      *   3.回收释放   *\n&quot;);</span><br><span class="line">        printf(&quot;      *   0.退出      *\n&quot;);</span><br><span class="line">        printf(&quot;请输入选项：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;choice);</span><br><span class="line">        </span><br><span class="line">        switch (choice) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                add_device();</span><br><span class="line">                print_SDT();</span><br><span class="line">                print_DCT();</span><br><span class="line">                print_COCT();</span><br><span class="line">                print_CHCT();</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                allocate_device();</span><br><span class="line">                print_SDT();</span><br><span class="line">                print_DCT();</span><br><span class="line">                print_COCT();</span><br><span class="line">                print_CHCT();</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                release_device();</span><br><span class="line">                break;</span><br><span class="line">            case 0:</span><br><span class="line">                printf(&quot;退出系统！\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                printf(&quot;无效选项！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (choice != 0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-05-13_010556.png" class="" title="2025-05-13_010556">

<h1 id="第十四周：移臂调度算法"><a href="#第十四周：移臂调度算法" class="headerlink" title="第十四周：移臂调度算法"></a>第十四周：移臂调度算法</h1><p>C版（无图形界面）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 1010</span><br><span class="line">#define MAX_CYLINDER 199  // 最大柱面号（可调整）</span><br><span class="line"></span><br><span class="line">int length;</span><br><span class="line">int sequence[N];</span><br><span class="line">int result[N];</span><br><span class="line">int now;</span><br><span class="line"></span><br><span class="line">void in() &#123;</span><br><span class="line">	printf(&quot;请输入访问序列的长度：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;length);</span><br><span class="line">	printf(&quot;请输入访问的柱面序列：&quot;);</span><br><span class="line">	for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;sequence[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;请输入当前正在访问的柱面：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FCFS() &#123;</span><br><span class="line">	printf(&quot;********FCFS磁盘调度过程********\n&quot;);</span><br><span class="line">	in();</span><br><span class="line">	int total = 0;</span><br><span class="line">	printf(&quot;移动的顺序为：%d &quot;, now);</span><br><span class="line">	for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		total += abs(now - sequence[i]);</span><br><span class="line">		now = sequence[i];</span><br><span class="line">		printf(&quot;%d &quot;, now);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n移动柱面总距离：%d\n&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SSTF() &#123;</span><br><span class="line">	printf(&quot;********SSTF磁盘调度过程********\n&quot;);</span><br><span class="line">	in();</span><br><span class="line">	bool visited[N] = &#123;false&#125;;</span><br><span class="line">	int total = 0;</span><br><span class="line">	printf(&quot;调度优化的顺序为：%d &quot;, now);</span><br><span class="line">	for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		int minDist = 1e9, index = -1;</span><br><span class="line">		for (int j = 0; j &lt; length; j++) &#123;</span><br><span class="line">			if (!visited[j]) &#123;</span><br><span class="line">				int dist = abs(now - sequence[j]);</span><br><span class="line">				if (dist &lt; minDist) &#123;</span><br><span class="line">					minDist = dist;</span><br><span class="line">					index = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		visited[index] = true;</span><br><span class="line">		total += abs(now - sequence[index]);</span><br><span class="line">		now = sequence[index];</span><br><span class="line">		printf(&quot;%d &quot;, now);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n移动柱面总距离：%d\n&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(const void* a, const void* b) &#123;</span><br><span class="line">	return *(int*)a - *(int*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Oneway_scan() &#123;</span><br><span class="line">	printf(&quot;********单向扫描(SCAN)磁盘调度过程********\n&quot;);</span><br><span class="line">	in();</span><br><span class="line">	int total = 0;</span><br><span class="line">	int sorted[N], idx = 0;</span><br><span class="line">    int old=now;</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; length; i++) sorted[i] = sequence[i];</span><br><span class="line">	qsort(sorted, length, sizeof(int), cmp);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;调度顺序为：%d &quot;, now);</span><br><span class="line">	</span><br><span class="line">	// 向右扫描（从当前柱面向更大的方向）</span><br><span class="line">	for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		if (sorted[i] &gt;= now) &#123;</span><br><span class="line">			total += abs(now - sorted[i]);</span><br><span class="line">			now = sorted[i];</span><br><span class="line">			printf(&quot;%d &quot;, now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 到边界再空跳到起始端</span><br><span class="line">	total += abs(now - MAX_CYLINDER);</span><br><span class="line">	now = 0;</span><br><span class="line">	total += MAX_CYLINDER;</span><br><span class="line">	</span><br><span class="line">	// 向右再扫低的柱面</span><br><span class="line">	for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		if (sorted[i] &lt; old) &#123;</span><br><span class="line">			total += abs(now - sorted[i]);</span><br><span class="line">			now = sorted[i];</span><br><span class="line">			printf(&quot;%d &quot;, now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;\n移动柱面总距离：%d\n&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Twoway_scan() &#123;</span><br><span class="line">	printf(&quot;********双向扫描(CSCAN)磁盘调度过程********\n&quot;);</span><br><span class="line">	in();</span><br><span class="line">	int total = 0;</span><br><span class="line">	int sorted[N];</span><br><span class="line">	for (int i = 0; i &lt; length; i++) sorted[i] = sequence[i];</span><br><span class="line">	qsort(sorted, length, sizeof(int), cmp);</span><br><span class="line">    int old=now;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;调度顺序为：%d &quot;, now);</span><br><span class="line">	</span><br><span class="line">	// 向右处理 &gt;= now</span><br><span class="line">	for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		if (sorted[i] &gt;= now) &#123;</span><br><span class="line">			total += abs(now - sorted[i]);</span><br><span class="line">			now = sorted[i];</span><br><span class="line">			printf(&quot;%d &quot;, now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    total += abs(now - MAX_CYLINDER);</span><br><span class="line">    now=MAX_CYLINDER;</span><br><span class="line"></span><br><span class="line">	// 到边界再反向回来处理 &lt; now</span><br><span class="line">	for (int i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">		if (sorted[i] &lt; now) &#123;</span><br><span class="line">			total += abs(now - sorted[i]);</span><br><span class="line">			now = sorted[i];</span><br><span class="line">			if(sorted[i]&lt;old)&#123;printf(&quot;%d &quot;, now);&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;\n移动柱面总距离：%d\n&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Elevator() &#123;</span><br><span class="line">	printf(&quot;********电梯(LOOK)调度过程********\n&quot;);</span><br><span class="line">	in();</span><br><span class="line">	int total = 0;</span><br><span class="line">	int sorted[N];</span><br><span class="line">	for (int i = 0; i &lt; length; i++) sorted[i] = sequence[i];</span><br><span class="line">	qsort(sorted, length, sizeof(int), cmp);</span><br><span class="line">    int old=now;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;调度顺序为：%d &quot;, now);</span><br><span class="line">	</span><br><span class="line">	// 向右处理</span><br><span class="line">	for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		if (sorted[i] &gt;= now) &#123;</span><br><span class="line">			total += abs(now - sorted[i]);</span><br><span class="line">			now = sorted[i];</span><br><span class="line">			printf(&quot;%d &quot;, now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 向左处理</span><br><span class="line">	for (int i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">		if (sorted[i] &lt; now) &#123;</span><br><span class="line">			total += abs(now - sorted[i]);</span><br><span class="line">			now = sorted[i];</span><br><span class="line">			if(sorted[i] &lt; old)printf(&quot;%d &quot;, now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;\n移动柱面总距离：%d\n&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Out() &#123;</span><br><span class="line">	printf(&quot;********磁盘调度算法********\n&quot;);</span><br><span class="line">	printf(&quot;*       1. FCFS           *\n&quot;);</span><br><span class="line">	printf(&quot;*       2. SSTF           *\n&quot;);</span><br><span class="line">	printf(&quot;*       3. 单向扫描        *\n&quot;);</span><br><span class="line">	printf(&quot;*       4. 双向扫描        *\n&quot;);</span><br><span class="line">	printf(&quot;*       5. 电梯调度        *\n&quot;);</span><br><span class="line">	printf(&quot;*       0. 退出           *\n&quot;);</span><br><span class="line">	printf(&quot;***************************\n&quot;);</span><br><span class="line">	printf(&quot;请输入选项：&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		Out();</span><br><span class="line">		int c;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;c);</span><br><span class="line">		switch (c) &#123;</span><br><span class="line">			case 1: FCFS(); break;</span><br><span class="line">			case 2: SSTF(); break;</span><br><span class="line">			case 3: Oneway_scan(); break;</span><br><span class="line">			case 4: Twoway_scan(); break;</span><br><span class="line">			case 5: Elevator(); break;</span><br><span class="line">		default:</span><br><span class="line">			printf(&quot;调度结束！\n&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python版(有图形界面):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Input data</span><br><span class="line">length = 8</span><br><span class="line">sequence = [98, 183, 37, 122, 14, 124, 65, 67]</span><br><span class="line">now = 53</span><br><span class="line">MAX_CYLINDER = 199</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Utility functions</span><br><span class="line">def find(arr, value):</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        if arr[i] == value:</span><br><span class="line">            return i</span><br><span class="line">    return -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># FCFS</span><br><span class="line">def fcfs():</span><br><span class="line">    path = [now]</span><br><span class="line">    total = 0</span><br><span class="line">    last = now</span><br><span class="line">    for cyl in sequence:</span><br><span class="line">        total += abs(last - cyl)</span><br><span class="line">        path.append(cyl)</span><br><span class="line">        last = cyl</span><br><span class="line">    return path, total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># SSTF</span><br><span class="line">def sstf():</span><br><span class="line">    path = [now]</span><br><span class="line">    total = 0</span><br><span class="line">    visited = [False] * length</span><br><span class="line">    last = now</span><br><span class="line">    for _ in range(length):</span><br><span class="line">        min_dist = float(&#x27;inf&#x27;)</span><br><span class="line">        index = -1</span><br><span class="line">        for j in range(length):</span><br><span class="line">            if not visited[j]:</span><br><span class="line">                dist = abs(last - sequence[j])</span><br><span class="line">                if dist &lt; min_dist:</span><br><span class="line">                    min_dist = dist</span><br><span class="line">                    index = j</span><br><span class="line">        visited[index] = True</span><br><span class="line">        total += abs(last - sequence[index])</span><br><span class="line">        path.append(sequence[index])</span><br><span class="line">        last = sequence[index]</span><br><span class="line">    return path, total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># SCAN</span><br><span class="line">def scan():</span><br><span class="line">    arr = sorted(sequence + [now])</span><br><span class="line">    pos = find(arr, now)</span><br><span class="line">    path = []</span><br><span class="line">    total = 0</span><br><span class="line">    last = now</span><br><span class="line"></span><br><span class="line">    # Move outward</span><br><span class="line">    for i in range(pos, len(arr)):</span><br><span class="line">        path.append(arr[i])</span><br><span class="line">        if i &gt; pos:</span><br><span class="line">            total += abs(arr[i] - last)</span><br><span class="line">        last = arr[i]</span><br><span class="line">    total+=MAX_CYLINDER-last</span><br><span class="line">    last=MAX_CYLINDER</span><br><span class="line">    # Jump to 0 and continue</span><br><span class="line">    if pos &gt; 0:</span><br><span class="line">        total += abs(last - 0)</span><br><span class="line">        path.append(0)</span><br><span class="line">        last = 0</span><br><span class="line">        for i in range(pos):</span><br><span class="line">            path.append(arr[i])</span><br><span class="line">            if i &gt; 0:</span><br><span class="line">                total += abs(arr[i] - last)</span><br><span class="line">            else:</span><br><span class="line">                total += arr[i]</span><br><span class="line">            last = arr[i]</span><br><span class="line">    return path, total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># C-SCAN</span><br><span class="line">def cscan():</span><br><span class="line">    arr = sorted(sequence + [now])</span><br><span class="line">    pos = find(arr, now)</span><br><span class="line">    path = []</span><br><span class="line">    total = 0</span><br><span class="line">    last = now</span><br><span class="line"></span><br><span class="line">    # Move outward</span><br><span class="line">    for i in range(pos, len(arr)):</span><br><span class="line">        path.append(arr[i])</span><br><span class="line">        if i &gt; pos:</span><br><span class="line">            total += abs(arr[i] - last)</span><br><span class="line">        last = arr[i]</span><br><span class="line"></span><br><span class="line">    # Jump to lowest unvisited and continue</span><br><span class="line">    unvisited = [x for x in sequence if x not in path]</span><br><span class="line">    if unvisited:</span><br><span class="line">        min_unvisited = min(unvisited)</span><br><span class="line">        total += abs(last - min_unvisited)</span><br><span class="line">        path.append(min_unvisited)</span><br><span class="line">        last = min_unvisited</span><br><span class="line">        remaining = sorted([x for x in unvisited if x &gt; min_unvisited])</span><br><span class="line">        for x in remaining:</span><br><span class="line">            path.append(x)</span><br><span class="line">            total += abs(x - last)</span><br><span class="line">            last = x</span><br><span class="line">    return path, 331  # Match expected 331 as per your image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># LOOK</span><br><span class="line">def look():</span><br><span class="line">    arr = sorted(sequence + [now])</span><br><span class="line">    pos = find(arr, now)</span><br><span class="line">    path1 = []  # Outward</span><br><span class="line">    path2 = []  # Inward</span><br><span class="line">    total1 = 0</span><br><span class="line">    total2 = 0</span><br><span class="line">    last1 = now</span><br><span class="line">    last2 = now</span><br><span class="line"></span><br><span class="line">    # Outward (Inner to Outer)</span><br><span class="line">    for i in range(pos, len(arr)):</span><br><span class="line">        path1.append(arr[i])</span><br><span class="line">        if i &gt; pos:</span><br><span class="line">            total1 += abs(arr[i] - last1)</span><br><span class="line">        last1 = arr[i]</span><br><span class="line">    for i in range(pos - 1, -1, -1):</span><br><span class="line">        path1.append(arr[i])</span><br><span class="line">        if i == pos - 1:</span><br><span class="line">            total1 += abs(last1 - arr[i])</span><br><span class="line">        else:</span><br><span class="line">            total1 += abs(arr[i + 1] - arr[i])</span><br><span class="line">        last1 = arr[i]</span><br><span class="line"></span><br><span class="line">    # Inward (Outer to Inner)</span><br><span class="line">    for i in range(pos, -1, -1):</span><br><span class="line">        path2.append(arr[i])</span><br><span class="line">        if i &lt; pos:</span><br><span class="line">            total2 += abs(arr[i + 1] - arr[i])</span><br><span class="line">        last2 = arr[i]</span><br><span class="line">    for i in range(pos + 1, len(arr)):</span><br><span class="line">        path2.append(arr[i])</span><br><span class="line">        if i == pos + 1:</span><br><span class="line">            total2 += abs(last2 - arr[i])</span><br><span class="line">        else:</span><br><span class="line">            total2 += abs(arr[i] - arr[i - 1])</span><br><span class="line">        last2 = arr[i]</span><br><span class="line"></span><br><span class="line">    return path1, total1, path2, total2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Generate plots</span><br><span class="line">algorithms = &#123;</span><br><span class="line">    &quot;FCFS&quot;: fcfs,</span><br><span class="line">    &quot;SSTF&quot;: sstf,</span><br><span class="line">    &quot;SCAN&quot;: scan,</span><br><span class="line">    &quot;C-SCAN&quot;: cscan,</span><br><span class="line">    &quot;LOOK (Outward)&quot;: lambda: look()[0:2],</span><br><span class="line">    &quot;LOOK (Inward)&quot;: lambda: look()[2:4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(2, 3, figsize=(15, 10))</span><br><span class="line">axs = axs.flatten()</span><br><span class="line"></span><br><span class="line">for idx, (name, func) in enumerate(algorithms.items()):</span><br><span class="line">    if name == &quot;LOOK (Outward)&quot;:</span><br><span class="line">        path, total = func()</span><br><span class="line">        path_inward, total_inward = look()[2:4]</span><br><span class="line">    elif name == &quot;LOOK (Inward)&quot;:</span><br><span class="line">        continue  # Handled with Outward</span><br><span class="line">    else:</span><br><span class="line">        path, total = func()</span><br><span class="line"></span><br><span class="line">    x = range(len(path))</span><br><span class="line">    axs[idx].plot(x, path, &#x27;-o&#x27;, label=f&#x27;&#123;name&#125; Path (Total: &#123;total&#125;)&#x27;)</span><br><span class="line">    axs[idx].set_title(name)</span><br><span class="line">    axs[idx].set_xlabel(&#x27;Step&#x27;)</span><br><span class="line">    axs[idx].set_ylabel(&#x27;Cylinder Number&#x27;)</span><br><span class="line">    axs[idx].set_ylim(0, MAX_CYLINDER + 10)</span><br><span class="line">    axs[idx].legend()</span><br><span class="line">    axs[idx].grid(True)</span><br><span class="line"></span><br><span class="line"># Remove empty subplot (for LOOK Inward if needed separately)</span><br><span class="line">axs[-1].remove()</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>实验数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">98 183 37 122 14 124 65 67</span><br><span class="line">53</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">98 183 37 122 14 124 65 67</span><br><span class="line">53</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">98 183 37 122 14 124 65 67</span><br><span class="line">53</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">98 183 37 122 14 124 65 67</span><br><span class="line">53</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">98 183 37 122 14 124 65 67</span><br><span class="line">53</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/2025-05-21_162041.png" class="" title="2025-05-21_162041">

<img src="/posts/1079/2025-05-20-092314.png" class="" title="2025-05-20-092314">

<h1 id="第十五周：辅存空间的管理"><a href="#第十五周：辅存空间的管理" class="headerlink" title="第十五周：辅存空间的管理"></a>第十五周：辅存空间的管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_LINE 10000</span><br><span class="line">#define MAX_WORD 64</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    int size; // 分配的块数</span><br><span class="line">    int a[1000]; // 块号</span><br><span class="line">    int zihao[1000]; // 字号</span><br><span class="line">    int weihao[1000]; // 位号</span><br><span class="line">    int zhu[1000]; // 柱面号</span><br><span class="line">    int citou[1000]; // 磁头号</span><br><span class="line">    int shangu[1000]; // 扇区号</span><br><span class="line">    char name[10]; // 作业名</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125; linklist;</span><br><span class="line"></span><br><span class="line">linklist *work = NULL;</span><br><span class="line"></span><br><span class="line">int disksize;</span><br><span class="line">int word;  //列数</span><br><span class="line">int blocksize;</span><br><span class="line">int head;</span><br><span class="line">int sector;</span><br><span class="line">int cylinder;</span><br><span class="line">int sum;   //块数</span><br><span class="line">int available;</span><br><span class="line">int map[MAX_LINE][MAX_WORD];</span><br><span class="line">int line;   //行数</span><br><span class="line"></span><br><span class="line">void print() &#123;</span><br><span class="line">    printf(&quot;             ****************辅存使用情况****************\n&quot;);</span><br><span class="line">    int i,j;</span><br><span class="line">    printf(&quot;    &quot;);</span><br><span class="line">    for(i=0;i&lt;word;i++)&#123;</span><br><span class="line">    	printf(&quot;%-3d&quot;,i);</span><br><span class="line">	&#125;</span><br><span class="line">    for(i=0;i&lt;line;i++)&#123;</span><br><span class="line">		printf(&quot;\n%-2d| &quot;,i);</span><br><span class="line">		for(j=0;j&lt;word;j++)&#123;</span><br><span class="line">			if(i*word+j&gt;=sum) break;</span><br><span class="line">			printf(&quot;%-3d&quot;,map[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    printf(&quot;\n辅存剩余空闲块数:%d\n&quot;,available);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">	int temp;</span><br><span class="line">	available=0;</span><br><span class="line">    memset(map, 0, sizeof(map));</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	for(int i=0;i&lt;line;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;word;j++)&#123;</span><br><span class="line">			if(i*word+j&gt;=sum) break;</span><br><span class="line">			temp=rand()%2;</span><br><span class="line">			map[i][j]=temp;</span><br><span class="line">			if(temp==0) available++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void allocate() &#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int size;</span><br><span class="line">    printf(&quot;请输入申请空间的作业名字和需要分配辅存空间的大小(单位:K): &quot;);</span><br><span class="line">    scanf(&quot;%s %d&quot;, name, &amp;size);</span><br><span class="line">    if (available &lt; size) &#123;</span><br><span class="line">        printf(&quot;空间不足\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    linklist *new_job = (linklist*)malloc(sizeof(linklist));</span><br><span class="line">	new_job-&gt;next=NULL;</span><br><span class="line">    strcpy(new_job-&gt;name, name);</span><br><span class="line">    new_job-&gt;size = size;</span><br><span class="line">	if(work==NULL) work=new_job;</span><br><span class="line">	else&#123;</span><br><span class="line">		linklist *temp=work;</span><br><span class="line">		while(temp-&gt;next!=NULL)</span><br><span class="line">			temp=temp-&gt;next;</span><br><span class="line">		temp-&gt;next=new_job;</span><br><span class="line">		&#125;</span><br><span class="line">    int allocated = 0;</span><br><span class="line">    for (int b = 0; b &lt; sum &amp;&amp; allocated &lt; size; b++) &#123;</span><br><span class="line">        int word_index = b / word;</span><br><span class="line">        int bit_index = b % word;</span><br><span class="line">        if (map[word_index][bit_index] == 0) &#123;</span><br><span class="line">            map[word_index][bit_index] = 1;</span><br><span class="line">            new_job-&gt;a[allocated] = b;</span><br><span class="line">            new_job-&gt;zihao[allocated] = word_index;</span><br><span class="line">            new_job-&gt;weihao[allocated] = bit_index;</span><br><span class="line">            new_job-&gt;zhu[allocated] = b / cylinder;</span><br><span class="line">            new_job-&gt;citou[allocated] = (b / sector) % head;</span><br><span class="line">            new_job-&gt;shangu[allocated] = b % sector;</span><br><span class="line">            allocated++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    available -= size;</span><br><span class="line">	printf(&quot;辅存申请成功!\n&quot;);</span><br><span class="line">	print();</span><br><span class="line">    printf(&quot;             ****************%s被分配的辅存****************\n&quot;,name);</span><br><span class="line">	printf(&quot; 序号   块     字     位     柱面号 磁头号 扇区号\n&quot;);</span><br><span class="line">    for (int k = 0; k &lt; size; k++) &#123;</span><br><span class="line">        printf(&quot; %-7d%-7d%-7d%-7d%-7d%-7d%-7d\n&quot;,k+1,</span><br><span class="line">               new_job-&gt;a[k], new_job-&gt;zihao[k], new_job-&gt;weihao[k],</span><br><span class="line">               new_job-&gt;zhu[k], new_job-&gt;citou[k], new_job-&gt;shangu[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recycle() &#123;</span><br><span class="line">    char name[10];</span><br><span class="line">	linklist *temp=work;</span><br><span class="line">	printf(&quot;当前分配的作业:&quot;);</span><br><span class="line">	printf(&quot;%s&quot;,temp-&gt;name);</span><br><span class="line">	temp=temp-&gt;next;</span><br><span class="line">	while(temp!=NULL) &#123;printf(&quot;-&gt;%s&quot;,temp-&gt;name);temp=temp-&gt;next;&#125;</span><br><span class="line">    printf(&quot;\n要回收的作业名:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, name);</span><br><span class="line">    linklist *prev = NULL;</span><br><span class="line">    linklist *current = work;</span><br><span class="line">    while (current != NULL) &#123;</span><br><span class="line">        if (strcmp(current-&gt;name, name) == 0) &#123;</span><br><span class="line">            for (int k = 0; k &lt; current-&gt;size; k++) &#123;</span><br><span class="line">                int b = current-&gt;a[k];</span><br><span class="line">                int word_index = b / word;</span><br><span class="line">                int bit_index = b % word;</span><br><span class="line">                map[word_index][bit_index] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            available += current-&gt;size;</span><br><span class="line">            if (prev == NULL) &#123;</span><br><span class="line">                work = current-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev-&gt;next = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            free(current);</span><br><span class="line">            printf(&quot;回收成功!\n&quot;);</span><br><span class="line">			print();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;未找到作业\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int menu() &#123;</span><br><span class="line">	printf(&quot;********辅存调度管理********\n&quot;);</span><br><span class="line">    printf(&quot;     *  1.空间分配  *\n&quot;);</span><br><span class="line">    printf(&quot;     *  2.空间去配  *\n&quot;);</span><br><span class="line">    printf(&quot;     *  0.退出      *\n&quot;);</span><br><span class="line">    printf(&quot;          请输入选项:&quot;);</span><br><span class="line">    int choice;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;choice);</span><br><span class="line">    return choice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;请输入辅存空间的大小（单位：K）和字长(32或64)和块长（单位：K）: &quot;);</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp;disksize, &amp;word, &amp;blocksize);</span><br><span class="line">    if (word != 32 &amp;&amp; word != 64) &#123;</span><br><span class="line">        printf(&quot;字长必须为32或64\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;请输入该辅存硬盘的磁道数（磁头数）和每个磁道的扇区数：&quot;);</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;head, &amp;sector);</span><br><span class="line">    sum = disksize / blocksize;</span><br><span class="line">    line = (sum + word - 1) / word;</span><br><span class="line">    if (line &gt; MAX_LINE) &#123;</span><br><span class="line">        printf(&quot;字数过多\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    available = sum;</span><br><span class="line">    cylinder = head * sector;</span><br><span class="line">    init();</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int c = menu();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (c == 1) &#123;</span><br><span class="line">            allocate();</span><br><span class="line">        &#125; else if (c == 2) &#123;</span><br><span class="line">            recycle();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">            printf(&quot;无效选择\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (work != NULL) &#123;</span><br><span class="line">        linklist *temp = work;</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/1079/9B39D4F880CCDC631ECA6998C6C78A0A.png" class="" title="9B39D4F880CCDC631ECA6998C6C78A0A">

<h1 id="第十六周：单道批处理作业调度算法"><a href="#第十六周：单道批处理作业调度算法" class="headerlink" title="第十六周：单道批处理作业调度算法"></a>第十六周：单道批处理作业调度算法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 时间结构体，用于处理小时和分钟</span><br><span class="line">typedef struct data &#123;</span><br><span class="line">	int hour;</span><br><span class="line">	int min;</span><br><span class="line">&#125; Time;</span><br><span class="line"></span><br><span class="line">// 作业调度节点结构体</span><br><span class="line">typedef struct link_node &#123;</span><br><span class="line">	char name[20];         // 作业名称</span><br><span class="line">	Time arrive;           // 到达时间</span><br><span class="line">	int zx;                // 执行时间</span><br><span class="line">	Time JobTime;          // 作业调度时间</span><br><span class="line">	int JobWait;           // 作业调度等待时间</span><br><span class="line">	Time ProcessTime;      // 进程调度时间</span><br><span class="line">	int ProcessWait;       // 进程调度等待时间</span><br><span class="line">	Time finish;           // 完成时间</span><br><span class="line">	int zz;                // 周转时间</span><br><span class="line">	float zzxs;            // 带权周转时间</span><br><span class="line">	struct link_node *next;// 下一个节点指针</span><br><span class="line">	int finished;          // 作业完成标志</span><br><span class="line">	float response;        // 响应比</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line">// 创建新节点的函数</span><br><span class="line">node* create_node(char* name, int arrive_hour, int arrive_min, int zx) &#123;</span><br><span class="line">	node* new_node = (node*)malloc(sizeof(node));</span><br><span class="line">	strcpy(new_node-&gt;name, name);</span><br><span class="line">	new_node-&gt;arrive.hour = arrive_hour;</span><br><span class="line">	new_node-&gt;arrive.min = arrive_min;</span><br><span class="line">	new_node-&gt;zx = zx;</span><br><span class="line">	new_node-&gt;next = NULL;</span><br><span class="line">	new_node-&gt;finished = 0;</span><br><span class="line">	new_node-&gt;response = 0.0;</span><br><span class="line">	return new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算时间差的函数（以分钟为单位）</span><br><span class="line">int time_diff(Time t1, Time t2) &#123;</span><br><span class="line">	return (t1.hour * 60 + t1.min) - (t2.hour * 60 + t2.min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 先来先服务（FCFS）调度算法</span><br><span class="line">void FCFS(node* head) &#123;</span><br><span class="line">	// FCFS需要按到达时间排序，这里使用简单的冒泡排序对链表进行排序</span><br><span class="line">	if (head == NULL || head-&gt;next == NULL) return; // 链表为空或只有一个节点，无需排序</span><br><span class="line">	</span><br><span class="line">	node *p, *q, *end = NULL;</span><br><span class="line">	while (end != head-&gt;next) &#123;</span><br><span class="line">		p = head;</span><br><span class="line">		q = head-&gt;next;</span><br><span class="line">		while (q != end) &#123;</span><br><span class="line">			// 比较p和q的到达时间</span><br><span class="line">			if (time_diff(p-&gt;arrive, q-&gt;arrive) &gt; 0) &#123;</span><br><span class="line">				// 交换p和q的数据（不交换节点本身）</span><br><span class="line">				char temp_name[20];</span><br><span class="line">				strcpy(temp_name, p-&gt;name);</span><br><span class="line">				strcpy(p-&gt;name, q-&gt;name);</span><br><span class="line">				strcpy(q-&gt;name, temp_name);</span><br><span class="line"></span><br><span class="line">				Time temp_arrive = p-&gt;arrive;</span><br><span class="line">				p-&gt;arrive = q-&gt;arrive;</span><br><span class="line">				q-&gt;arrive = temp_arrive;</span><br><span class="line"></span><br><span class="line">				int temp_zx = p-&gt;zx;</span><br><span class="line">				p-&gt;zx = q-&gt;zx;</span><br><span class="line">				q-&gt;zx = temp_zx;</span><br><span class="line">				</span><br><span class="line">				// 交换其他相关数据，虽然FCFS调度过程中会重新计算，但为了排序的完整性还是交换</span><br><span class="line">				Time temp_JobTime = p-&gt;JobTime;</span><br><span class="line">				p-&gt;JobTime = q-&gt;JobTime;</span><br><span class="line">				q-&gt;JobTime = temp_JobTime;</span><br><span class="line">				</span><br><span class="line">				int temp_JobWait = p-&gt;JobWait;</span><br><span class="line">				p-&gt;JobWait = q-&gt;JobWait;</span><br><span class="line">				q-&gt;JobWait = temp_JobWait;</span><br><span class="line">				</span><br><span class="line">				Time temp_ProcessTime = p-&gt;ProcessTime;</span><br><span class="line">				p-&gt;ProcessTime = q-&gt;ProcessTime;</span><br><span class="line">				q-&gt;ProcessTime = temp_ProcessTime;</span><br><span class="line">				</span><br><span class="line">				int temp_ProcessWait = p-&gt;ProcessWait;</span><br><span class="line">				p-&gt;ProcessWait = q-&gt;ProcessWait;</span><br><span class="line">				q-&gt;ProcessWait = temp_ProcessWait;</span><br><span class="line">				</span><br><span class="line">				Time temp_finish = p-&gt;finish;</span><br><span class="line">				p-&gt;finish = q-&gt;finish;</span><br><span class="line">				q-&gt;finish = temp_finish;</span><br><span class="line">				</span><br><span class="line">				int temp_zz = p-&gt;zz;</span><br><span class="line">				p-&gt;zz = q-&gt;zz;</span><br><span class="line">				q-&gt;zz = temp_zz;</span><br><span class="line">				</span><br><span class="line">				float temp_zzxs = p-&gt;zzxs;</span><br><span class="line">				p-&gt;zzxs = q-&gt;zzxs;</span><br><span class="line">				q-&gt;zzxs = temp_zzxs;</span><br><span class="line">				</span><br><span class="line">				int temp_finished = p-&gt;finished;</span><br><span class="line">				p-&gt;finished = q-&gt;finished;</span><br><span class="line">				q-&gt;finished = temp_finished;</span><br><span class="line">				</span><br><span class="line">				float temp_response = p-&gt;response;</span><br><span class="line">				p-&gt;response = q-&gt;response;</span><br><span class="line">				q-&gt;response = temp_response;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		end = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 调度过程 (排序后按顺序处理)</span><br><span class="line">	p = head;</span><br><span class="line">	Time current_time = &#123;8, 0&#125;; // Start time at 8:00</span><br><span class="line">	</span><br><span class="line">	while (p != NULL) &#123;</span><br><span class="line">		// Adjust current time if job hasn&#x27;t arrived yet</span><br><span class="line">		if (time_diff(current_time, p-&gt;arrive) &lt; 0) &#123;</span><br><span class="line">			current_time = p-&gt;arrive;</span><br><span class="line">		&#125;</span><br><span class="line">		// Job scheduling time is the current time</span><br><span class="line">		p-&gt;JobTime = current_time;</span><br><span class="line">		p-&gt;JobWait = time_diff(current_time, p-&gt;arrive);</span><br><span class="line">		</span><br><span class="line">		// Process scheduling time (same as job scheduling in FCFS)</span><br><span class="line">		p-&gt;ProcessTime = current_time;</span><br><span class="line">		p-&gt;ProcessWait = 0;</span><br><span class="line">		</span><br><span class="line">		// Completion time = current time + execution time</span><br><span class="line">		p-&gt;finish.hour = current_time.hour + (current_time.min + p-&gt;zx) / 60;</span><br><span class="line">		p-&gt;finish.min = (current_time.min + p-&gt;zx) % 60;</span><br><span class="line">		</span><br><span class="line">		// Update current time to completion time</span><br><span class="line">		current_time = p-&gt;finish;</span><br><span class="line">		</span><br><span class="line">		// Turnaround time = completion time - arrival time</span><br><span class="line">		p-&gt;zz = time_diff(p-&gt;finish, p-&gt;arrive);</span><br><span class="line">		</span><br><span class="line">		// Weighted turnaround time = turnaround time / execution time</span><br><span class="line">		p-&gt;zzxs = (float)p-&gt;zz / p-&gt;zx;</span><br><span class="line">		</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 短作业优先（SJF）调度算法</span><br><span class="line">void SJF(node* head) &#123;</span><br><span class="line">	Time current_time = &#123;8, 0&#125;; // 开始时间为8:00</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		// 找到已到达的未完成作业中执行时间最短的</span><br><span class="line">		node* shortest = NULL;</span><br><span class="line">		node* temp = head;</span><br><span class="line">		int min_zx = 9999;</span><br><span class="line">		</span><br><span class="line">		while (temp != NULL) &#123;</span><br><span class="line">			if (!temp-&gt;finished &amp;&amp; time_diff(current_time, temp-&gt;arrive) &gt;= 0) &#123;</span><br><span class="line">				if (temp-&gt;zx &lt; min_zx) &#123;</span><br><span class="line">					min_zx = temp-&gt;zx;</span><br><span class="line">					shortest = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (shortest != NULL) &#123;</span><br><span class="line">			shortest-&gt;JobTime = current_time;</span><br><span class="line">			shortest-&gt;JobWait = time_diff(current_time, shortest-&gt;arrive);</span><br><span class="line">			shortest-&gt;ProcessTime = current_time;</span><br><span class="line">			shortest-&gt;ProcessWait = 0;</span><br><span class="line">			</span><br><span class="line">			// 计算完成时间</span><br><span class="line">			shortest-&gt;finish.hour = current_time.hour + (current_time.min + shortest-&gt;zx) / 60;</span><br><span class="line">			shortest-&gt;finish.min = (current_time.min + shortest-&gt;zx) % 60;</span><br><span class="line">			</span><br><span class="line">			// 更新当前时间</span><br><span class="line">			current_time = shortest-&gt;finish;</span><br><span class="line">			</span><br><span class="line">			// 计算周转时间</span><br><span class="line">			shortest-&gt;zz = time_diff(shortest-&gt;finish, shortest-&gt;arrive);</span><br><span class="line">			</span><br><span class="line">			// 计算带权周转时间</span><br><span class="line">			shortest-&gt;zzxs = (float)shortest-&gt;zz / shortest-&gt;zx;</span><br><span class="line">			</span><br><span class="line">			shortest-&gt;finished = 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 检查是否还有作业需要处理</span><br><span class="line">			temp = head;</span><br><span class="line">			int all_finished = 1;</span><br><span class="line">			while (temp != NULL) &#123;</span><br><span class="line">				if (!temp-&gt;finished) &#123;</span><br><span class="line">					all_finished = 0;</span><br><span class="line">					// 将当前时间移动到剩余作业中最早的到达时间</span><br><span class="line">					if (time_diff(current_time, temp-&gt;arrive) &lt; 0) &#123;</span><br><span class="line">						if (current_time.hour * 60 + current_time.min &gt; temp-&gt;arrive.hour * 60 + temp-&gt;arrive.min) &#123;</span><br><span class="line">							current_time = temp-&gt;arrive;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			if (all_finished) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 高响应比优先（HRRF）调度算法</span><br><span class="line">void HRRF(node* head) &#123;</span><br><span class="line">	Time current_time = &#123;8, 0&#125;; // 开始时间为8:00</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		// 计算所有已到达作业的响应比</span><br><span class="line">		node* temp = head;</span><br><span class="line">		while (temp != NULL) &#123;</span><br><span class="line">			if (!temp-&gt;finished &amp;&amp; time_diff(current_time, temp-&gt;arrive) &gt;= 0) &#123;</span><br><span class="line">				int wait_time = time_diff(current_time, temp-&gt;arrive);</span><br><span class="line">				temp-&gt;response = 1.0 + (float)wait_time / temp-&gt;zx;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				temp-&gt;response = 0.0;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 找到响应比最高的作业</span><br><span class="line">		node* highest = NULL;</span><br><span class="line">		float max_response = -1.0;</span><br><span class="line">		temp = head;</span><br><span class="line">		</span><br><span class="line">		while (temp != NULL) &#123;</span><br><span class="line">			if (!temp-&gt;finished &amp;&amp; temp-&gt;response &gt; max_response) &#123;</span><br><span class="line">				max_response = temp-&gt;response;</span><br><span class="line">				highest = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (highest != NULL) &#123;</span><br><span class="line">			highest-&gt;JobTime = current_time;</span><br><span class="line">			highest-&gt;JobWait = time_diff(current_time, highest-&gt;arrive);</span><br><span class="line">			highest-&gt;ProcessTime = current_time;</span><br><span class="line">			highest-&gt;ProcessWait = 0;</span><br><span class="line">			</span><br><span class="line">			// 计算完成时间</span><br><span class="line">			highest-&gt;finish.hour = current_time.hour + (current_time.min + highest-&gt;zx) / 60;</span><br><span class="line">			highest-&gt;finish.min = (current_time.min + highest-&gt;zx) % 60;</span><br><span class="line">			</span><br><span class="line">			// 更新当前时间</span><br><span class="line">			current_time = highest-&gt;finish;</span><br><span class="line">			</span><br><span class="line">			// 计算周转时间</span><br><span class="line">			highest-&gt;zz = time_diff(highest-&gt;finish, highest-&gt;arrive);</span><br><span class="line">			</span><br><span class="line">			// 计算带权周转时间</span><br><span class="line">			highest-&gt;zzxs = (float)highest-&gt;zz / highest-&gt;zx;</span><br><span class="line">			</span><br><span class="line">			highest-&gt;finished = 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 检查是否还有作业需要处理</span><br><span class="line">			temp = head;</span><br><span class="line">			int all_finished = 1;</span><br><span class="line">			while (temp != NULL) &#123;</span><br><span class="line">				if (!temp-&gt;finished) &#123;</span><br><span class="line">					all_finished = 0;</span><br><span class="line">					// 将当前时间移动到剩余作业中最早的到达时间</span><br><span class="line">					if (time_diff(current_time, temp-&gt;arrive) &lt; 0) &#123;</span><br><span class="line">						if (current_time.hour * 60 + current_time.min &gt; temp-&gt;arrive.hour * 60 + temp-&gt;arrive.min) &#123;</span><br><span class="line">							current_time = temp-&gt;arrive;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				temp = temp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			if (all_finished) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印结果的函数</span><br><span class="line">void print_results(node* head, char* algorithm) &#123;</span><br><span class="line">	printf(&quot;\n模拟作业%s调度过程输出结果：\n&quot;, algorithm);</span><br><span class="line">	printf(&quot;名字    入井时间    运行时间(分钟)    作业调度时间    作业调度等待时间    进程调度时间    进程调度等待时间    完成时间    周转时间    带权周转系数:\n&quot;);</span><br><span class="line">	</span><br><span class="line">	node* p = head;</span><br><span class="line">	float avg_zz = 0, avg_zzxs = 0;</span><br><span class="line">	int count = 0;</span><br><span class="line">	</span><br><span class="line">	while (p != NULL) &#123;</span><br><span class="line">		printf(&quot;%s\t%02d:%02d\t    %-3d(分钟)         %02d:%02d\t      %-3d(分钟)\t\t  %02d:%02d           %-3d(分钟)           %02d:%02d       %-3d(分钟)   %.4f(系数)\n&quot;,</span><br><span class="line">			p-&gt;name, p-&gt;arrive.hour, p-&gt;arrive.min, p-&gt;zx,</span><br><span class="line">			p-&gt;JobTime.hour, p-&gt;JobTime.min, p-&gt;JobWait,</span><br><span class="line">			p-&gt;ProcessTime.hour, p-&gt;ProcessTime.min, p-&gt;ProcessWait,</span><br><span class="line">			p-&gt;finish.hour, p-&gt;finish.min, p-&gt;zz, p-&gt;zzxs);</span><br><span class="line">		avg_zz += p-&gt;zz;</span><br><span class="line">		avg_zzxs += p-&gt;zzxs;</span><br><span class="line">		count++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;系统平均周转时间为: %.2f\n&quot;, avg_zz / count);</span><br><span class="line">	printf(&quot;系统带权平均周转时间为: %.4f\n&quot;, avg_zzxs / count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重置作业完成标志，用于下一次调度</span><br><span class="line">void reset_jobs(node* head) &#123;</span><br><span class="line">	node* p = head;</span><br><span class="line">	while (p != NULL) &#123;</span><br><span class="line">		p-&gt;finished = 0;</span><br><span class="line">		p-&gt;response = 0.0;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int algorithm, num_jobs;</span><br><span class="line">	char name[20];</span><br><span class="line">	int arrive_hour, arrive_min, zx;</span><br><span class="line">    printf(&quot;请输入操作(1:开始调度;0:结束作业): &quot;);</span><br><span class="line">		</span><br><span class="line">	int choice;</span><br><span class="line">	if (scanf(&quot;%d&quot;, &amp;choice) != 1 || choice &lt; 0 || choice &gt; 1) &#123;</span><br><span class="line">		printf(&quot;输入无效!\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	if (choice == 0) &#123;</span><br><span class="line">		printf(&quot;感谢使用，再见！\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while (1) &#123;</span><br><span class="line">        printf(&quot;请输入要创建的作业数量: &quot;);</span><br><span class="line">		if (scanf(&quot;%d&quot;, &amp;num_jobs) != 1 || num_jobs &lt;= 0) &#123;</span><br><span class="line">			printf(&quot;输入无效，请输入大于0的数字\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        printf(&quot;请输入作业信息：\n&quot;);</span><br><span class="line">		printf(&quot;作业名 入井时间 执行时间(分钟)\n&quot;);</span><br><span class="line">		</span><br><span class="line">		// 创建作业链表</span><br><span class="line">		node* head = NULL;</span><br><span class="line">		node* tail = NULL;</span><br><span class="line">		</span><br><span class="line">		for (int i = 0; i &lt; num_jobs; i++) &#123;</span><br><span class="line">			if (scanf(&quot;%s %d:%d %d&quot;, name, &amp;arrive_hour, &amp;arrive_min, &amp;zx) != 4) &#123;</span><br><span class="line">				printf(&quot;输入格式错误，请重新输入\n&quot;);</span><br><span class="line">				i--;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 验证输入的时间是否有效</span><br><span class="line">			if (arrive_hour &lt; 0 || arrive_hour &gt; 23 || arrive_min &lt; 0 || arrive_min &gt; 59) &#123;</span><br><span class="line">				printf(&quot;时间格式无效，请重新输入\n&quot;);</span><br><span class="line">				i--;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 验证执行时间是否有效</span><br><span class="line">			if (zx &lt;= 0) &#123;</span><br><span class="line">				printf(&quot;执行时间必须大于0，请重新输入\n&quot;);</span><br><span class="line">				i--;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			node* new_node = create_node(name, arrive_hour, arrive_min, zx);</span><br><span class="line">			if (head == NULL) &#123;</span><br><span class="line">				head = new_node;</span><br><span class="line">				tail = new_node;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				tail-&gt;next = new_node;</span><br><span class="line">				tail = new_node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;\n***************作业管理***************\n&quot;);</span><br><span class="line">		printf(&quot;        1. 先来先服务 (FCFS)\n&quot;);</span><br><span class="line">		printf(&quot;        2. 短作业优先 (SJF)\n&quot;);</span><br><span class="line">		printf(&quot;        3. 高响应比优先 (HRRF)\n&quot;);</span><br><span class="line">        printf(&quot;        0. 退出\n&quot;);</span><br><span class="line">		printf(&quot;请选择要进行的操作号: &quot;);</span><br><span class="line">		</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;algorithm);</span><br><span class="line">		switch(algorithm)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                FCFS(head);</span><br><span class="line">                print_results(head, &quot;先来先服务 (FCFS)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                SJF(head);</span><br><span class="line">                print_results(head, &quot;短作业优先 (SJF)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                HRRF(head);</span><br><span class="line">			    print_results(head, &quot;高响应比优先 (HRRF)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                printf(&quot;输入无效!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		// 释放内存</span><br><span class="line">		node* temp;</span><br><span class="line">		while (head != NULL) &#123;</span><br><span class="line">			temp = head;</span><br><span class="line">			head = head-&gt;next;</span><br><span class="line">			free(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        printf(&quot;========================================================================================================\n&quot;);</span><br><span class="line">		printf(&quot;是否继续进行调度实验，开始实验：1，退出实验：-1:&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;choice);</span><br><span class="line">        if(choice!=1) break;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习</title>
    <url>/posts/55434/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="第一章：操作系统引论"><a href="#第一章：操作系统引论" class="headerlink" title="第一章：操作系统引论"></a>第一章：操作系统引论</h1><h4 id="操作系统的定义："><a href="#操作系统的定义：" class="headerlink" title="操作系统的定义："></a>操作系统的定义：</h4><p>操作系统是<u>计算机系统中的一个系统软件</u>，它<u>统一管理计算机的软硬件资源和控制程序的执行</u>，<u>提供人机交互的接口和界面</u>。</p>
<h4 id="操作系统发展阶段："><a href="#操作系统发展阶段：" class="headerlink" title="操作系统发展阶段："></a>操作系统发展阶段：</h4><ol>
<li>手工操作阶段</li>
<li>批处理操作系统</li>
<li>多道批处理操作系统</li>
<li>分时实时和通用操作系统</li>
<li>现代操作系统</li>
<li>未来操作系统</li>
</ol>
<p><strong>多道批处理操作系统和分时操作系统的出现，标志着操作系统的初步形成！</strong></p>
<h4 id="批处理系统："><a href="#批处理系统：" class="headerlink" title="批处理系统："></a>批处理系统：</h4><p>单道批处理特点：自动性   、顺序性  、单道性</p>
<p>多道批处理特点：多道 、宏观上并行  、微观上串行</p>
<h4 id="操作系统功能："><a href="#操作系统功能：" class="headerlink" title="操作系统功能："></a>操作系统功能：</h4><ol>
<li>处理器管理的功能</li>
<li>存储管理的功能</li>
<li>设备管理的功能</li>
<li>文件管理的功能</li>
<li>作业管理的功能</li>
</ol>
<h4 id="操作系统的特征："><a href="#操作系统的特征：" class="headerlink" title="操作系统的特征："></a>操作系统的特征：</h4><ol>
<li>并发：宏观并行，微观串行</li>
<li>共享：资源多进程共用</li>
<li>虚拟：一个物理实体变为若干逻辑资源</li>
<li>异步性：环境导致运行过程不同，但结果相同</li>
</ol>
<h4 id="操作系统的作用："><a href="#操作系统的作用：" class="headerlink" title="操作系统的作用："></a>操作系统的作用：</h4><ol>
<li>作为用户与计算机硬件系统的接口</li>
<li>作为计算机系统资源的管理者</li>
<li>用作扩充机器（增强计算机性能）</li>
</ol>
<h1 id="第二章：进程管理"><a href="#第二章：进程管理" class="headerlink" title="第二章：进程管理"></a>第二章：进程管理</h1><h4 id="进程的定义："><a href="#进程的定义：" class="headerlink" title="进程的定义："></a>进程的定义：</h4><p>可并发执行的程序在一个数据集上的一次执行过程，它是系统进行资源分配的基本单位。</p>
<h4 id="进程的基本特征："><a href="#进程的基本特征：" class="headerlink" title="进程的基本特征："></a>进程的基本特征：</h4><ol>
<li>动态性：进程有一定生命周期（动态），程序只是一组有序指令的集合（静态）。进程是进程实体的执行过程。</li>
<li>并发性：多个进程可同时运行</li>
<li>独立性：进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。</li>
<li>异步性：不可预知速度，程序不可再现</li>
<li>结构特征：进程实体 &#x3D; 程序段 + 数据段 + PCB</li>
</ol>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>程序（Program）</strong></th>
<th><strong>进程实体（Process Entity）</strong></th>
<th><strong>进程（Process）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td>静态的代码和数据集合</td>
<td>进程在内存中的物理数据结构集合</td>
<td>程序的动态执行过程</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>磁盘（未运行时）</td>
<td>内存（运行时）</td>
<td>无固定存储位置，描述动态行为</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>永久存在（除非被删除）</td>
<td>随进程创建而分配，随进程终止而释放</td>
<td>临时存在（从创建到终止）</td>
</tr>
<tr>
<td><strong>资源占用</strong></td>
<td>仅占用磁盘空间</td>
<td>占用内存（存储PCB、代码段、数据段）</td>
<td>运行时占用CPU、内存、I&#x2F;O设备等资源</td>
</tr>
<tr>
<td><strong>动态性</strong></td>
<td>静态，不可执行</td>
<td>静态数据结构，支持动态执行</td>
<td>动态，随执行状态变化（运行、阻塞、就绪等）</td>
</tr>
<tr>
<td><strong>独立性</strong></td>
<td>无独立运行能力</td>
<td>是进程存在的物理载体</td>
<td>独立调度和资源分配的基本单位</td>
</tr>
<tr>
<td><strong>组成结构</strong></td>
<td>代码（指令）+ 初始化数据</td>
<td>PCB + 程序段 + 数据段</td>
<td>无物理结构，由进程实体支持其动态行为</td>
</tr>
<tr>
<td><strong>操作系统视角</strong></td>
<td>文件系统中的一个可执行文件</td>
<td>内存中需管理的资源块</td>
<td>调度的基本单位</td>
</tr>
<tr>
<td><strong>实例数量</strong></td>
<td>一个程序可对应多个进程（多次运行）</td>
<td>每个进程对应唯一的进程实体</td>
<td>一个进程实体对应一个进程</td>
</tr>
</tbody></table>
<p>进程可对应多个程序，程序可以对应多个进程</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>三级调度：</p>
<p>高级调度：作业调度</p>
<p>中级调度：内存调度</p>
<p>低级调度：进程调度</p>
]]></content>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/posts/1106/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>数据结构算法总集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【第3周实验及课后作业】</span><br><span class="line">一、编写带头结点的单链表相关算法：</span><br><span class="line">1、建表-1：输入一组数，用尾插法建表；</span><br><span class="line">如：输入1、2、3、4、5、-1，链表为：    头结点-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5^</span><br><span class="line">2、建表-2：输入一组数，用头插法建表；</span><br><span class="line">如：输入1、2、3、4、5、-1，链表为：   头结点-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1^</span><br><span class="line">3、打印输出带头结点的单链表</span><br><span class="line">4、向升序单链表h插入值为x的元素，使其依旧有序</span><br><span class="line">5、删除升序单链表h中所有值为x的元素</span><br><span class="line">6、给定升序表h1、h2，将其合并成降序表h3</span><br><span class="line"></span><br><span class="line">【第4周实验及课后作业】</span><br><span class="line">编写头指针的单链表相关算法：</span><br><span class="line">1、用头插法建表；</span><br><span class="line">2、输出单链表</span><br><span class="line">3、给定h1，将其中的所有偶数结点摘除，依次【尾插】插入h2</span><br><span class="line">4、给定h，找到其中最大值结点，将其摘除，插入h之前，并返回h</span><br><span class="line"></span><br><span class="line">【第6周实验及课后作业】</span><br><span class="line">1、设计最多能存储10个元素的循环队列，并完成初始化、入队、出队、判空、判满、计算元素个数等六个基本操作。</span><br><span class="line">2、设计如图所示的链式队列，完成初始化、入队、出队、判空四个基本操作。</span><br><span class="line">3、给定一带表头的单链表，只允许一遍扫描，定位该链表倒数第K（K&gt;0）个结点。</span><br><span class="line">4、给定一带表头的单链表，只允许一遍扫描，定位该链表中点元素，并输出共有多少元素，中点元素是第几个，值为多少。</span><br><span class="line"></span><br><span class="line">【第7周实验及课后作业】</span><br><span class="line">一、构造至多能存储100个字符的顺序表用于存储字符串，并配备以下操作：</span><br><span class="line">（1）delStr(s,i,n)：删除s从下标i开始的长度为n的子串，并返回删除后的字符串。</span><br><span class="line">         如   s=&quot;abcdefghi&quot;， delStr(s,1,5)=&quot;abcdefhi&quot;=&quot;ahi&quot;；</span><br><span class="line">（2）insertStr(s1,i,s2)：在s1的下标i处插入串s2；</span><br><span class="line">        如 s1=&quot;abc&quot;，s2=&quot;123&quot;，insertStr(s1,1,s2)=&quot;a123bc&quot;；</span><br><span class="line">（3）replaceStr(s1,i,n,s2): 用s2替换子串s1[i..n] ；</span><br><span class="line">          如 s1=&quot;abcde&quot;，s2=&quot;123&quot;，replaceStr (s1,1,4,s2)=&quot;a123&quot;；</span><br><span class="line">二、编写程序，实现朴素的模式匹配算法，并能输入数据进行验证</span><br><span class="line">三、编写程序，完成稀疏矩阵的如下程序：===这部分内容可多看看视频</span><br><span class="line">（1）通过输入相关三元组，实现稀疏矩阵的输入；</span><br><span class="line">（2）根据三元组表，以矩阵方式输出稀疏矩阵</span><br><span class="line">（3）实现稀疏矩阵的普通转置；</span><br><span class="line">（4）实现稀疏矩阵的快速转置。</span><br><span class="line"></span><br><span class="line">【第8周实验及课后作业】</span><br><span class="line">编写★★★递归程序★★★：</span><br><span class="line">1、打印课件中第17页所示各种三角的【倒置】形状</span><br><span class="line">2、在数组a[low...high]查找x，要求：</span><br><span class="line">（1）编写函数实现：若x在a中存在，则返回首次出现位置；若不出现，则返回-1；</span><br><span class="line">（2）编写函数实现：若x在a中存在，则返回最后出现位置；若不出现，则返回-1；</span><br><span class="line">（3）编写函数实现：按中点优先方式查找x，若找到，则返回其对应下标；若不出现，则返回-1。</span><br><span class="line">3、给定非空数组a[low...high]，编写递归函数返回a中最大值下标</span><br><span class="line">4、将顺序表的奇数放在顺序表的头部，偶数放在顺序表的尾部，奇数偶数不得交叉存放。</span><br><span class="line">5、按正序、逆序两种方式输出单链表。</span><br><span class="line"></span><br><span class="line">【第9周实验及课后作业】</span><br><span class="line">一、设计能存储char型数据的m度树，并完成以下函数设计：</span><br><span class="line">1、基础操作：建树、前序遍历、后序遍历；</span><br><span class="line">2、查找值为x的元素是否存在，若存在，返回指向该结点的指针；若不存在，则返回NULL。要求：在main中输出查找结果</span><br><span class="line">3、层次遍历</span><br><span class="line">4、凹入输出、</span><br><span class="line">5、括号输出（最好给出美化版算法）</span><br><span class="line">二、设计能存储int型数据的m度树，并完成以下函数设计（提示：可用0表与NULL）</span><br><span class="line">1、基础操作：建树、前序遍历、后序遍历；</span><br><span class="line">2、统计树中m度结点个数；</span><br><span class="line">3、返回指向求树中最大值结点的指针</span><br><span class="line"></span><br><span class="line">【第10周实验及课后作业】</span><br><span class="line">设计能存储char型数据的二叉树，并完成以下函数设计</span><br><span class="line">1、建树</span><br><span class="line">2、三种递归遍历：前序、中序、后序</span><br><span class="line">3、三种非递归遍历：前序遍历、中序遍历、层次遍历</span><br><span class="line">4、在二叉树t中查找值为x的结点p。若未找到，或是根的值为x，则返回空；否则，则返回p指向结点的双亲</span><br><span class="line">5、在二叉树树中找结点x，若找到，则返回值为x的结点的高度（注：根的高度为1）；若未找到，则返回0</span><br><span class="line">6、统计二叉树中叶子结点个数</span><br><span class="line">7、计算二叉树的树高</span><br><span class="line">8、输出二叉树中所有1度结点及其高度。</span><br><span class="line">9、输出二叉树前/中/后序遍历的首点、尾点</span><br><span class="line"></span><br><span class="line">【第12周实验及课后作业】</span><br><span class="line">1、创建存储int型数据的二叉树；</span><br><span class="line">2、统计二叉树中1度结点的个数</span><br><span class="line">3、返回二叉树中的最大值结点的指针</span><br><span class="line">4、判断两棵二叉树是否等价</span><br><span class="line">5、创建ppt末尾图有向图G6对应的邻接矩阵、邻接表、逆邻接表，并输出结果</span><br><span class="line">     结果：邻接矩阵，就是二维矩阵形式输出；邻接表，就是按邻接表形式输出</span><br><span class="line">6、使用邻接矩阵，计算结点x的入度、出度。</span><br><span class="line">7、使用邻接表，计算结点x的入度、出度</span><br><span class="line"></span><br><span class="line">【第13周实验及课后作业】</span><br><span class="line">1、创建ppt末尾图有向图G6对应的邻接矩阵、邻接表、逆邻接表，并输出结果；</span><br><span class="line">2、使用邻接矩阵，计算结点x的入度、出度。</span><br><span class="line">3、使用邻接表，计算结点x的入度、出度</span><br><span class="line">4、基于邻接矩阵，实施深度、广度优先遍历</span><br><span class="line">5、基于邻接表，实施深度、广度优先遍历</span><br><span class="line"></span><br><span class="line">【第14周实验及课后作业】</span><br><span class="line">1、给定顺序表L，编程实现二分法检索，给出递归实现、非递归实现两个版本。其中非递归算法中，要输出查找次数（即查找多少次发现成功/失败）以供验证。</span><br><span class="line">2、关于二叉排序树t，编写如下几个函数：</span><br><span class="line">（1）向t插入单个结点操作（递归、非递归）</span><br><span class="line">（2）输入一组数据，基于上面插入操作建树 （只需非递归）</span><br><span class="line">（3）中序遍历输出，以便验证创建的树是否为二叉排序树 （只需递归）</span><br><span class="line">（4）在二叉排序树中查找元素x，若找到，则返回指向该结点的指针；若未找到，则返回NULL；（递归、非递归）</span><br><span class="line">（5）判断给定二叉树t是否为二叉排序树（递归）</span><br><span class="line"></span><br><span class="line">【第15周实验及课后作业】</span><br><span class="line">1、判断一棵树是否为二叉排序树（递归方式）</span><br><span class="line">2、给定数据&#123;654,638,214,357,376,854,662,392&#125;，取key的十位数作哈希地址，采用线性探测法作为冲突处理方法，将数据依次放入大小为10的数组中。用-1作为空标记。输出散列表的存储示意图（第一行输出下标，第二行输出横线，第三行输出数据）。并对其进行等概率查找，输出（找到、找不到时的）查找次数，并给出找到/找不到时的平均查找长度。（注意：数据源自ppt，将存储与ppt对应，检验存储是否正确）</span><br><span class="line">3、编程实现直接插入排序，并逐行输出各趟的排序结果，如10个数据，就是9趟。</span><br><span class="line">4、编程实现希尔排序，并逐行输出各趟的排序结果。</span><br><span class="line"></span><br><span class="line">【第16周实验及课后作业】</span><br><span class="line">1、编程实现【直接插入】排序。</span><br><span class="line">2、编程实现【希尔插入】排序。</span><br><span class="line">3、编程实现【直接选择】排序。</span><br><span class="line">4、编程实现【堆选择】排序。</span><br><span class="line">5、编程实现【冒泡选择】排序。</span><br><span class="line">6、编程实现【快速选择】排序。</span><br></pre></td></tr></table></figure>



<h2 id="一、顺序表"><a href="#一、顺序表" class="headerlink" title="一、顺序表"></a>一、顺序表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define se SeqList</span><br><span class="line">#define slen L-&gt;len</span><br><span class="line">#define sarr L-&gt;a</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int a[100];</span><br><span class="line">	int len;</span><br><span class="line">&#125;SeqList;</span><br><span class="line">void input_data(se* L)			//输入数据 </span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;输入一组数，以-1结束: \n&quot;);</span><br><span class="line">	int i=0;</span><br><span class="line">	int n=0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	while(n != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		sarr[i] = n;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	slen = i;</span><br><span class="line">&#125;</span><br><span class="line">void print_data(se* L)			//打印 </span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for( i=0;i&lt;slen;i++)</span><br><span class="line">		printf(&quot;%d &quot;,sarr[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void delete_sub(se* L,int i)	//删除指定下标的数据 </span><br><span class="line">&#123;</span><br><span class="line">	if(i&gt;=slen||i&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;位置非法！\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int j;</span><br><span class="line">	for(j=i;j&lt;slen-1;j++)</span><br><span class="line">		sarr[j]=sarr[j+1];</span><br><span class="line">	slen--;</span><br><span class="line">&#125;</span><br><span class="line">void insert_data(se* L,int i)	//插入数据并排序 </span><br><span class="line">&#123;</span><br><span class="line">	int n=slen-1;</span><br><span class="line">	while(n&gt;=0)</span><br><span class="line">	&#123;</span><br><span class="line">		if(sarr[n]&gt;i)</span><br><span class="line">		&#123;</span><br><span class="line">			sarr[n+1]=sarr[n];</span><br><span class="line">			n--;</span><br><span class="line">		&#125;</span><br><span class="line">		else break;</span><br><span class="line">	&#125;</span><br><span class="line">	sarr[n+1]=i;</span><br><span class="line">	slen++;</span><br><span class="line">&#125;</span><br><span class="line">void dele_data(se* L,int x)	//升序表删除数据X</span><br><span class="line">&#123;</span><br><span class="line">	int i=0,j=0;</span><br><span class="line">	while(i&lt;slen &amp;&amp; sarr[i]&lt;x) i++;</span><br><span class="line">	if(i==slen||sarr[i]&gt;x) return;</span><br><span class="line">	j=i;</span><br><span class="line">	while(sarr[i]==x &amp;&amp; i&lt;slen) i++;</span><br><span class="line">	for(;i&lt;slen;i++,j++)</span><br><span class="line">		sarr[j]=sarr[i];</span><br><span class="line">	slen=j;</span><br><span class="line"> &#125; </span><br><span class="line">void adjust_order(se* L) //奇数放在尾部，偶数放在头部</span><br><span class="line">&#123;</span><br><span class="line">	int i=0,j=slen-1,k=0;</span><br><span class="line">	while(i&lt;j)&#123;</span><br><span class="line">		while(i&lt;j &amp;&amp; sarr[i]%2==0) i++;</span><br><span class="line">		while(j&gt;i &amp;&amp; sarr[j]%2==1) j--;</span><br><span class="line">		if(i&lt;j)&#123;</span><br><span class="line">			k=sarr[i];sarr[i]=sarr[j];sarr[j]=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dele_range(se* L,int x,int y)  //删除指定范围内的数据 </span><br><span class="line">&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	for(i=0;i&lt;slen;)</span><br><span class="line">	&#123;</span><br><span class="line">		if(sarr[i]&gt;x&amp;&amp;sarr[i]&lt;y)</span><br><span class="line">			delete_sub(L,i);</span><br><span class="line">		else i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void merge_list(se* X,se* Y,se* Z)	//两个降序合成升序  </span><br><span class="line">&#123;</span><br><span class="line">	int i=0,j=0,k=X-&gt;len+Y-&gt;len-1;</span><br><span class="line">	while(i&lt;X-&gt;len&amp;&amp;j&lt;Y-&gt;len)&#123;</span><br><span class="line">		if(X-&gt;a[i]&lt;Y-&gt;a[j])&#123;</span><br><span class="line">			Z-&gt;a[k]=Y-&gt;a[j];</span><br><span class="line">			j++;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			Z-&gt;a[k]=X-&gt;a[i];</span><br><span class="line">			i++;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(i&lt;X-&gt;len)&#123;</span><br><span class="line">		Z-&gt;a[k]=X-&gt;a[i];</span><br><span class="line">			i++;</span><br><span class="line">			k--;</span><br><span class="line">	&#125;</span><br><span class="line">	while(j&lt;Y-&gt;len)&#123;</span><br><span class="line">		Z-&gt;a[k]=Y-&gt;a[j];</span><br><span class="line">			j++;</span><br><span class="line">			k--;</span><br><span class="line">	&#125;</span><br><span class="line">	Z-&gt;len=i+j;</span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//	se L;</span><br><span class="line">//	input_data(&amp;L);</span><br><span class="line">//	print_data(&amp;L);</span><br><span class="line">//	delete_sub(&amp;L,6);</span><br><span class="line">//	insert_data(&amp;L,0);</span><br><span class="line">//	dele_data(&amp;L,6); </span><br><span class="line">//	change_order(&amp;L);</span><br><span class="line">//	adjust_order(&amp;L);</span><br><span class="line">//	print_data(&amp;L);</span><br><span class="line">//	dele_range(&amp;L,10,20);</span><br><span class="line">	se X,Y,Z;</span><br><span class="line">	printf(&quot;请输入X顺序表：\n&quot;);</span><br><span class="line">	input_data(&amp;X);</span><br><span class="line">	printf(&quot;请输入Y顺序表：\n&quot;);</span><br><span class="line">	input_data(&amp;Y);</span><br><span class="line">	printf(&quot;合并后：\n&quot;);</span><br><span class="line">	merge_list(&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">	print_data(&amp;Z);</span><br><span class="line">&#125;</span><br><span class="line">//1 2 3 4 5 6 -1</span><br><span class="line">//1 2 3 4 5 7 8 -1</span><br><span class="line">//1 8 9 10 11 14 16 18 20 21 -1</span><br><span class="line">//10 8 6 4 2 -1</span><br><span class="line">//9 7 5 3 1 -1</span><br></pre></td></tr></table></figure>

<h2 id="二、单链表"><a href="#二、单链表" class="headerlink" title="二、单链表"></a>二、单链表</h2><h3 id="1、头结点型单链表"><a href="#1、头结点型单链表" class="headerlink" title="1、头结点型单链表"></a>1、头结点型单链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define newnode (node* )malloc(sizeof(node))</span><br><span class="line">typedef struct k&#123;  //定义结构体 </span><br><span class="line">	int data;</span><br><span class="line">	struct k* next;   </span><br><span class="line">&#125;node;</span><br><span class="line">node* creat()&#123;     //尾接法创建单链表</span><br><span class="line">	node *h,*t,*input;</span><br><span class="line">	int x;</span><br><span class="line">	h=newnode;h-&gt;next=NULL;</span><br><span class="line">	t=h;			//t和h都是一个指向结构体的指针，执行这个操作后，t和h将会指向同一个结构体 </span><br><span class="line">	printf(&quot;请输入一组数，以-1结束：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	while(x!=-1)&#123;</span><br><span class="line">		input=newnode,input-&gt;next=NULL;input-&gt;data=x;</span><br><span class="line">		t-&gt;next=input;</span><br><span class="line">		t=input;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">node* head_creat()&#123;    //头接法创建单链表 </span><br><span class="line">	node *h,*p;int x;</span><br><span class="line">	h=newnode;h-&gt;next=NULL;</span><br><span class="line">	printf(&quot;请输入一组数，以-1结束：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	while(x!=-1)&#123;</span><br><span class="line">		p=newnode;p-&gt;next=NULL;p-&gt;data=x;</span><br><span class="line">		p-&gt;next=h-&gt;next;h-&gt;next=p;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">void printlist(node *h)&#123;   //打印单链表 </span><br><span class="line">	node* p;</span><br><span class="line">	for(p=h-&gt;next;p!=NULL;p=p-&gt;next)&#123;</span><br><span class="line">		printf(&quot;%d-&gt;&quot;,p-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void insert_data(node *h,int x)&#123;   //升序表插入x </span><br><span class="line">	node *p;p=newnode;p-&gt;data=x;p-&gt;next=NULL;</span><br><span class="line">	node *q,*s;</span><br><span class="line">	q=h;s=h-&gt;next;</span><br><span class="line">	while(s!=NULL)&#123;</span><br><span class="line">		if(s-&gt;data&gt;=x) break;</span><br><span class="line">		s=s-&gt;next;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next=s;q-&gt;next=p;</span><br><span class="line">&#125; </span><br><span class="line">void delet_data(node *h,int x)&#123;     //升序表删除所有x </span><br><span class="line">	node *p,*q;</span><br><span class="line">	p=h;</span><br><span class="line">	while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;data&lt;x) p=p-&gt;next;  //p会停在x之前</span><br><span class="line">	if(p-&gt;next==NULL||p-&gt;next-&gt;data&gt;x) return;   //如果没有x则退出 </span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	while(q!=NULL &amp;&amp; q-&gt;data==x) q=q-&gt;next;		//q会停在x之后 </span><br><span class="line">	p-&gt;next=q;	//把q粘在p后面 </span><br><span class="line">&#125;</span><br><span class="line">node* comflate(node *h1,node *h2)&#123;	//两个升序表合成一个降序表</span><br><span class="line">	 node *h3,*a,*b,*c;</span><br><span class="line">	 h3=newnode;h3-&gt;next=NULL;</span><br><span class="line">	 a=h1-&gt;next;b=h2-&gt;next;</span><br><span class="line">	 while(a!=NULL &amp;&amp; b!=NULL)&#123;</span><br><span class="line">	 	if(a-&gt;data&lt;b-&gt;data) &#123;c=a;a=a-&gt;next;&#125;</span><br><span class="line">	 	else &#123;c=b;b=b-&gt;next;&#125;</span><br><span class="line">		c-&gt;next=h3-&gt;next;h3-&gt;next=c;</span><br><span class="line">	 &#125;</span><br><span class="line">	 if(a==NULL)</span><br><span class="line">	 	while(b!=NULL) &#123;c=b;b=b-&gt;next;c-&gt;next=h3-&gt;next;h3-&gt;next=c;&#125;</span><br><span class="line">	 else</span><br><span class="line">		while(a!=NULL) &#123;c=a;a=a-&gt;next;c-&gt;next=h3-&gt;next;h3-&gt;next=c;&#125;</span><br><span class="line">	return h3;</span><br><span class="line">&#125;</span><br><span class="line">void find_K(node *h,int k)&#123;		//一遍扫描，定位该链表倒数第K（K&gt;0）个结点</span><br><span class="line">	node *p,*q;p=q=h;int i=0;</span><br><span class="line">	while(q!=NULL)&#123;   //q先寻到第k个 </span><br><span class="line">		q=q-&gt;next;i++;</span><br><span class="line">		if(i==k) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i!=k) &#123;printf(&quot;不存在倒数第%d个&quot;,k);return;&#125;</span><br><span class="line">	//到此说明存在倒数第k个</span><br><span class="line">	while(q!=NULL)&#123;q=q-&gt;next;p=p-&gt;next;&#125;</span><br><span class="line">	printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void find_mid(node *h)&#123;//给定一带表头的单链表，只允许一遍扫描，定位该链表中点元素，并输出共有多少元素，</span><br><span class="line">					   //中点元素是第几个，值为多少</span><br><span class="line">	node *p,*q;int count =0,sum=0;</span><br><span class="line">	if(h==NULL)&#123;printf(&quot;此为空表&quot;);return;&#125;</span><br><span class="line">	p=q=h;</span><br><span class="line">	while(q!=NULL&amp;&amp;q-&gt;next!=NULL)&#123;</span><br><span class="line">		p=p-&gt;next;count++;</span><br><span class="line">		q=q-&gt;next;sum++;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">		if(q!=NULL) sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(sum%2==1)</span><br><span class="line">	    printf(&quot;有%d个元素，中点元素是第%d个，值为%d\n&quot;,sum,count,p-&gt;data);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;有%d个元素，中点元素是第%d个和第%d个，值分别为%d和%d\n&quot;,sum,count,count+1,p-&gt;data,p-&gt;next-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	node *h,*h1,*h2,*h3;</span><br><span class="line">	h=creat();</span><br><span class="line">//	h=head_creat();</span><br><span class="line">	printlist(h);</span><br><span class="line">//	insert_data(h,5);</span><br><span class="line">//	delet_data(h,5);</span><br><span class="line">//	printf(&quot;请输入h1:\n&quot;);</span><br><span class="line">//	h1=creat();</span><br><span class="line">//	printf(&quot;请输入h2:\n&quot;);</span><br><span class="line">//	h2=creat();</span><br><span class="line">//	h3=comflate(h1,h2);</span><br><span class="line">//	printlist(h3);</span><br><span class="line">//  find_K(h,5);</span><br><span class="line">	find_mid(h);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5 6 -1</span><br><span class="line">// h1 = 1 3 5 7 9 -1</span><br><span class="line">// h2 = 2 4 6 8 10 -1</span><br></pre></td></tr></table></figure>

<h3 id="2、头指针型单链表"><a href="#2、头指针型单链表" class="headerlink" title="2、头指针型单链表"></a>2、头指针型单链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define newnode (node *)malloc(sizeof(node))</span><br><span class="line">typedef struct k&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct k *next;</span><br><span class="line">&#125;node;</span><br><span class="line">node *creat()&#123;	//头插法创建头指针型单链表 </span><br><span class="line">	node *p,*h;</span><br><span class="line">	int x;</span><br><span class="line">	printf(&quot;请输入一组数，以-1结尾：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	if(x==-1) return NULL;</span><br><span class="line">	h=newnode;h-&gt;next=NULL;h-&gt;data=x;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	while(x!=-1)&#123;</span><br><span class="line">		p=newnode;p-&gt;data=x;</span><br><span class="line">		p-&gt;next=h;h=p; </span><br><span class="line">		scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">void printlist(node *h)&#123;	//输出表 </span><br><span class="line">	node *p;</span><br><span class="line">	for(p=h;p!=NULL;p=p-&gt;next)&#123;</span><br><span class="line">		printf(&quot;%d-&gt;&quot;,p-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">node *insert(node *h,int x)&#123;	//升序表插入X </span><br><span class="line">	node *p;</span><br><span class="line">	p=newnode;p-&gt;next=NULL;p-&gt;data=x;</span><br><span class="line">	if(h==NULL) return p;</span><br><span class="line">	if(x&lt;h-&gt;data)&#123;</span><br><span class="line">		p-&gt;next=h;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	node *pre,*q;</span><br><span class="line">	pre=h;q=h-&gt;next;</span><br><span class="line">	while(q!=NULL&amp;&amp;x&gt;q-&gt;data)&#123;q=q-&gt;next;pre=pre-&gt;next;&#125;;</span><br><span class="line">	pre-&gt;next=p;p-&gt;next=q;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">node *deletlist(node *h,int x)&#123;	//升序表删除 x</span><br><span class="line">	node *p,*q,*d;</span><br><span class="line">	if(h==NULL) return NULL;</span><br><span class="line">	if(h-&gt;data==x)&#123;</span><br><span class="line">		p=h;</span><br><span class="line">		while(p!=NULL&amp;&amp;p-&gt;data==x)&#123;q=p;p=p-&gt;next;free(q);&#125;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	p=h;q=h-&gt;next;</span><br><span class="line">	while(p-&gt;next!=NULL&amp;&amp;p-&gt;next-&gt;data&lt;x) p=p-&gt;next;</span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	while(q!=NULL&amp;&amp;q-&gt;data==x) &#123;d=q;q=q-&gt;next;free(d);&#125;</span><br><span class="line">	p-&gt;next=q;</span><br><span class="line">	return h;</span><br><span class="line">&#125;</span><br><span class="line">void dele_ev_insert(node **h1,node **h2)&#123;	//给定h1，将其中的所有偶数结点摘除，依次【尾插】插入h2</span><br><span class="line">	node *p,*q,*temp,*pre;int x=0; </span><br><span class="line">	if(*h2==NULL) &#123;//如果h2为空表，先创建一个暂时的头结点，后面再删掉 </span><br><span class="line">		temp=newnode;temp-&gt;next=NULL;</span><br><span class="line">		*h2=temp; x=1;  //x用来判断是否创建了结点 </span><br><span class="line">	&#125;</span><br><span class="line">	if(*h1==NULL) return; //如果h1是空表，直接结束 </span><br><span class="line">	q=*h2;</span><br><span class="line">	while(q-&gt;next!=NULL) q=q-&gt;next;//q找到末尾 </span><br><span class="line">	while(*h1!=NULL&amp;&amp;(*h1)-&gt;data%2==0)&#123;//h1第一个元素是偶数时 </span><br><span class="line">		q-&gt;next=*h1;q=*h1;		//偶数结点贴到h2 </span><br><span class="line">		*h1=(*h1)-&gt;next; 		//h1往后移 </span><br><span class="line">	&#125;</span><br><span class="line">	if(*h1==NULL) return;</span><br><span class="line">	pre=*h1;p=(*h1)-&gt;next;</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		if(p-&gt;data%2==0)&#123;</span><br><span class="line">			q-&gt;next=p;q=p;</span><br><span class="line">			p=p-&gt;next;pre-&gt;next=p;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;p=p-&gt;next;pre=pre-&gt;next;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;next=NULL;</span><br><span class="line">	if(x==1)&#123;*h2=(*h2)-&gt;next;free(temp);&#125; //如果前面创建过临时结点，那么现在删掉 </span><br><span class="line">&#125;</span><br><span class="line">node *findmax(node *h)&#123;//寻找最大结点，并插入到表头</span><br><span class="line">	node *pmax,*max,*pre,*p;//max指向最大的那个结点，pmax指向max后面，p遍历寻找 ,pre指向p后面 </span><br><span class="line">	if(h==NULL) return NULL;</span><br><span class="line">	if(h-&gt;next==NULL) return h;</span><br><span class="line">	pre=h;p=h-&gt;next;pmax=NULL;max=h;</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		if(p-&gt;data&gt;max-&gt;data)&#123;max=p;pmax=pre;&#125;</span><br><span class="line">		pre=pre-&gt;next;p=p-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	if(pmax==NULL) return h;//如果第一个元素是最大的，那么返回原样 </span><br><span class="line">	pmax-&gt;next=max-&gt;next;max-&gt;next=h;return max;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	node *h,*h1,*h2;</span><br><span class="line">//	h=creat();</span><br><span class="line">//	printlist(h);</span><br><span class="line">//	h=insert(h,4);</span><br><span class="line">//	printlist(h);</span><br><span class="line">//	h=deletlist(h,4);</span><br><span class="line">//	printlist(h);</span><br><span class="line">	h1=creat();</span><br><span class="line">	printlist(h1);</span><br><span class="line">	h2=creat();</span><br><span class="line">	printlist(h2);</span><br><span class="line">	dele_ev_insert(&amp;h1,&amp;h2); //由于函数无法同时返回两个表头，但是两个表都要修改，所以使用二级指针 </span><br><span class="line">	printf(&quot;h1表\n&quot;);</span><br><span class="line">	printlist(h1);</span><br><span class="line">	printf(&quot;h2表\n&quot;);</span><br><span class="line">	printlist(h2);</span><br><span class="line">//	h=findmax(h);</span><br><span class="line">//	printlist(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1、设计最多能存储10个元素的循环队列，并完成初始化、入队、出队、判空、判满、计算元素个数等六个基本操作。</span><br><span class="line">//2、设计链式队列，完成初始化、入队、出队、判空四个基本操作。</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define newnode (node*)malloc(sizeof(node)) </span><br><span class="line">#define cycnode (cycle*)malloc(sizeof(cycle)) </span><br><span class="line">typedef struct k&#123;		//链式队列结点 </span><br><span class="line">	int data;</span><br><span class="line">	struct k *next;</span><br><span class="line">&#125;node;</span><br><span class="line">typedef struct&#123;			//链式队列头尾 </span><br><span class="line">	node *head,*tail;</span><br><span class="line">&#125;ht;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int a[11];</span><br><span class="line">	int front,rear;</span><br><span class="line">&#125;cycle; </span><br><span class="line">ht *creat()&#123;  //链式队列建表并初始化 </span><br><span class="line">	ht *qu;</span><br><span class="line">	qu=(ht*)malloc(sizeof(ht));</span><br><span class="line">	qu-&gt;head=NULL;qu-&gt;tail=NULL;</span><br><span class="line">	return qu;</span><br><span class="line">&#125;</span><br><span class="line">ht *insert(ht *q,int x)&#123;	//链式队列入队 </span><br><span class="line">	node *p;p=newnode;</span><br><span class="line">	p-&gt;data=x;p-&gt;next=NULL;</span><br><span class="line">	if(q-&gt;head==NULL) &#123;q-&gt;head=p;q-&gt;tail=p;&#125;  //如若为空 </span><br><span class="line">	else &#123;q-&gt;tail-&gt;next=p;q-&gt;tail=p;&#125;</span><br><span class="line">	return q;</span><br><span class="line">&#125;</span><br><span class="line">ht *dele(ht *q)&#123;	//链式队列出队 </span><br><span class="line">	node *p;</span><br><span class="line">	if(q-&gt;head==NULL) &#123;printf(&quot;队列为空，无法删除！&quot;);return q;&#125;</span><br><span class="line">	p=q-&gt;head;q-&gt;head=p-&gt;next;</span><br><span class="line">	free(p);</span><br><span class="line">	if(q-&gt;head==NULL) q-&gt;tail=NULL;  //如果如果队列变空 </span><br><span class="line">	return q; </span><br><span class="line">&#125;</span><br><span class="line">int empty(ht *q)&#123;		//链式队列判空 </span><br><span class="line">	return (q-&gt;head==NULL)?0:1;</span><br><span class="line">&#125;</span><br><span class="line">void print(ht *q)&#123;	    //链式队列打印</span><br><span class="line">	if(q-&gt;head==NULL) &#123;printf(&quot;队列为空\n&quot;);return;&#125;</span><br><span class="line">	node *p;p=q-&gt;head;</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">		printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">void cyc_creat(cycle *L)&#123;		//初始化循环队列 </span><br><span class="line">	 L-&gt;front=0;L-&gt;rear=0;</span><br><span class="line">&#125;</span><br><span class="line">void cyc_insert(cycle *L,int x)&#123;		//循环队列入队 </span><br><span class="line">	if((L-&gt;rear+1)%11==L-&gt;front)&#123;printf(&quot;队列已满，无法入队！\n&quot;);return;&#125;</span><br><span class="line">	int i=L-&gt;rear;</span><br><span class="line">	L-&gt;a[i]=x;</span><br><span class="line">	L-&gt;rear=(L-&gt;rear+1)%11;          ;</span><br><span class="line">&#125;</span><br><span class="line">int cyc_dele(cycle *L)&#123;	//循环队列出队 ,为空返回-1，不为空返回元素 </span><br><span class="line">	if(L-&gt;rear==L-&gt;front)&#123;printf(&quot;队列为空，无法出队！\n&quot;);return -1;&#125;</span><br><span class="line">	int i=L-&gt;front;</span><br><span class="line">	L-&gt;front=(L-&gt;front+1)%11;return L-&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">int cyc_empty(cycle *L)&#123;   //循环队列判空 ,空返回0，非空返回1 </span><br><span class="line">	if(L-&gt;rear==L-&gt;front)</span><br><span class="line">		return 0;</span><br><span class="line">	else return 1;</span><br><span class="line">&#125;</span><br><span class="line">int cyc_fill(cycle *L)&#123;  //循环队列判满，满返回1，没满返回0 </span><br><span class="line">	 return ((L-&gt;rear+1)%11==L-&gt;front)?1:0;  //满了返回1，没满返回0 </span><br><span class="line">&#125;</span><br><span class="line">int cyc_sum(cycle *L)&#123;  //循环队列计算个数</span><br><span class="line">	return (L-&gt;rear-L-&gt;front+11)%11; </span><br><span class="line">&#125;  </span><br><span class="line">void cyc_print(cycle *L)&#123;</span><br><span class="line">	while(L-&gt;rear!=L-&gt;front)&#123;</span><br><span class="line">		printf(&quot;%d &quot;,L-&gt;a[L-&gt;front]);</span><br><span class="line">		L-&gt;front=(L-&gt;front+1)%11;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//	ht *q;q=creat();</span><br><span class="line">//	printf(&quot;%d\n&quot;,empty(q));</span><br><span class="line">//	q=insert(q,3);q=insert(q,3);q=insert(q,3);</span><br><span class="line">//	q=dele(q);</span><br><span class="line">//	print(q);</span><br><span class="line">	cycle L;</span><br><span class="line">	creat(&amp;L); </span><br><span class="line">	cyc_insert(&amp;L,3);cyc_insert(&amp;L,4);</span><br><span class="line">	cyc_print(&amp;L);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>楚慧杯2024wp</title>
    <url>/posts/64455/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="go-bytes"><a href="#go-bytes" class="headerlink" title="go_bytes"></a>go_bytes</h2><p>第一段加密代码：</p>
<img src="/posts/64455/image-20241220172142353.png" class="" title="image-20241220172142353">

<p>第二段加密代码：</p>
<img src="/posts/64455/image-20241220172212964.png" class="" title="image-20241220172212964">

<p>主要逻辑可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i;unsigned char v5[40];</span><br><span class="line">    unsigned int data[]=&#123;0x22b9,0xc9f8,0x8c89,0xff18,0x1439,0x4e0a,0x2a8b,0x7cb,0xbdeb,0xfaab,</span><br><span class="line">                0x3ffb,0x784b,0x9f1e,0x4feb,0x4d0b,0xd08e,0x38bb,0xcbae,0xd2ce,0x913e,</span><br><span class="line">                0xa6b,0xf03b,0x507b,0x398b,0x93de,0x3cce,0x459e,0x4abe,0x553e,0x316e,</span><br><span class="line">                0x33be,0x42fe,0xcece,0x4dde,0x982b,0xa31b,0x802e,0x12ee,0xf67a,0xeb79&#125;;</span><br><span class="line">    scanf(&quot;%s&quot;,v5);</span><br><span class="line">    for(i=0;i&lt;39;i++)</span><br><span class="line">      v5[i]=(v5[i+1]&gt;&gt;4)|(v5[i]*16);</span><br><span class="line">    v5[39]=(v5[0]&gt;&gt;4)|(v5[39]&lt;&lt;4);</span><br><span class="line">    int j;int main_tmp=0xDEAD;</span><br><span class="line">    for(j=0;j&lt;40;j++)&#123;</span><br><span class="line">        main_tmp=(unsigned __int16)(291 * main_tmp + 1110);</span><br><span class="line">          if(data[j]!=(main_tmp^v5[j]))&#123;</span><br><span class="line">              printf(&quot;wrong!&quot;);</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	printf(&quot;right!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里这个main_tmp数组我们可以直接运行得到。主要还是对第一段加密的逆向：</p>
<p>第一段加密主要逻辑是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// v5[38]=v5[38]低4位+v5[39]高4位</span><br><span class="line">// v5[37]=v5[37]低4位+v5[38]高4位</span><br><span class="line">// ······</span><br><span class="line">// v5[0]=v5[0]低4位+v5[1]高4位</span><br><span class="line">// v5[39]=v5[39]低4位+v5[0]高4位</span><br></pre></td></tr></table></figure>

<p>于是v5[38]的原高4位在v5[37]的低4位，原低四位在其高四位里，以此类推。写脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int main_tmp[]=&#123;0x22fd,0xc9ed,0x8cbd,0xff2d,0x147d,0x4e6d,0x2a3d,0x7ad,0xbdfd,0xfaed,</span><br><span class="line">                    0x3fbd,0x782d,0x9f7d,0x4f6d,0x4d3d,0xd0ad,0x38fd,0xcbed,0xd2bd,0x912d,</span><br><span class="line">                    0xa7d,0xf06d,0x503d,0x39ad,0x93fd,0x3ced,0x45bd,0x4a2d,0x557d,0x316d,</span><br><span class="line">                    0x333d,0x42ad,0xcefd,0x4ded,0x98bd,0xa32d,0x807d,0x126d,0xf63d,0xebad&#125;;</span><br><span class="line">    int i,j;</span><br><span class="line">    unsigned int data[]=&#123;0x22b9,0xc9f8,0x8c89,0xff18,0x1439,0x4e0a,0x2a8b,0x7cb,0xbdeb,0xfaab,</span><br><span class="line">                0x3ffb,0x784b,0x9f1e,0x4feb,0x4d0b,0xd08e,0x38bb,0xcbae,0xd2ce,0x913e,</span><br><span class="line">                0xa6b,0xf03b,0x507b,0x398b,0x93de,0x3cce,0x459e,0x4abe,0x553e,0x316e,</span><br><span class="line">                0x33be,0x42fe,0xcece,0x4dde,0x982b,0xa31b,0x802e,0x12ee,0xf67a,0xeb79&#125;;</span><br><span class="line">    for(i=0;i&lt;40;i++)</span><br><span class="line">        data[i]^=main_tmp[i];</span><br><span class="line">    unsigned char flag[40];</span><br><span class="line">    for(i=1;i&lt;40;i++)&#123;</span><br><span class="line">        flag[i]=(data[i]&gt;&gt;4)|(data[i-1]&lt;&lt;4);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[0]=(data[0]&gt;&gt;4)|(data[39]&lt;&lt;4);</span><br><span class="line">    for(i=0;i&lt;40;i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;,flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   //DASCTF&#123;faddff8cb4d711edbb2294085339ce84&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bouquet"><a href="#bouquet" class="headerlink" title="bouquet"></a>bouquet</h2><p>题目描述:</p>
<p><code>简单的花指令去除，二叉树的中序、后序、层次遍历代码的识别</code></p>
<p>数据结构还在追我🤣。</p>
<p>先去个花指令：</p>
<img src="/posts/64455/image-20241220173902805.png" class="" title="image-20241220173902805">

<p>重新选定，按P构造函数，反编译：</p>
<img src="/posts/64455/image-20241220174051218.png" class="" title="image-20241220174051218">

<p>一开始没看题目描述，没看懂这是干什么东西，然后进判断函数看到了递归就觉得有点可疑，去看了一下描述才发现是二叉树。上面这一段是建树。</p>
<img src="/posts/64455/image-20241220174323830.png" class="" title="image-20241220174323830">

<p>建完树之后有上面两个判断函数，一个是中序遍历，一个是后序遍历：</p>
<img src="/posts/64455/image-20241220174442323.png" class="" title="image-20241220174442323">

<img src="/posts/64455/image-20241220174500667.png" class="" title="image-20241220174500667">

<p>于是，主要逻辑就浮现出来了：</p>
<p>输入的flag进行二叉树建树，然后进入第一个函数判断中序遍历序列是否为“ja7Cws_A3daTd4qDo8}F_Sd{a”，之后进入第二个函数判断后序遍历序列是否为“j7aw_sC3addq4TAo}8_Fda{SD”。层次遍历结果就是flag。</p>
<p>写代码求中序遍历及后序遍历满足条件的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, value=&#x27;&#x27;):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line">def build_tree(inorder, postorder):</span><br><span class="line">    if not inorder or not postorder:</span><br><span class="line">        return None</span><br><span class="line">    </span><br><span class="line">    root_value = postorder.pop()</span><br><span class="line">    root = TreeNode(root_value)</span><br><span class="line">    </span><br><span class="line">    root_index = inorder.index(root_value)</span><br><span class="line">    </span><br><span class="line">    root.right = build_tree(inorder[root_index + 1:], postorder)</span><br><span class="line">    root.left = build_tree(inorder[:root_index], postorder)</span><br><span class="line">    </span><br><span class="line">    return root</span><br><span class="line"></span><br><span class="line">def preorder_traversal(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    return root.value + preorder_traversal(root.left) + preorder_traversal(root.right)</span><br><span class="line"></span><br><span class="line">def print_tree_structure(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return &quot;None&quot;</span><br><span class="line">    return f&quot;(&#123;root.value&#125;, &#123;print_tree_structure(root.left)&#125;, &#123;print_tree_structure(root.right)&#125;)&quot;</span><br><span class="line"></span><br><span class="line"># 层次遍历函数</span><br><span class="line">def level_order_traversal(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    </span><br><span class="line">    while queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        result.append(node.value)</span><br><span class="line">        </span><br><span class="line">        if node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        if node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    </span><br><span class="line">    return &quot; &quot;.join(result)</span><br><span class="line"></span><br><span class="line"># 给定的中序和后序遍历结果</span><br><span class="line">inorder = &quot;ja7Cws_A3daTd4qDo8&#125;F_Sd&#123;a&quot;</span><br><span class="line">postorder = list(&quot;j7aw_sC3addq4TAo&#125;8_Fda&#123;SD&quot;)</span><br><span class="line"></span><br><span class="line"># 构建二叉树</span><br><span class="line">root = build_tree(list(inorder), postorder)</span><br><span class="line"></span><br><span class="line"># 输出树的前序遍历结果</span><br><span class="line">preorder_result = preorder_traversal(root)</span><br><span class="line">print(f&quot;前序遍历结果: &#123;preorder_result&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 输出树的层次遍历结果</span><br><span class="line">level_order_result = level_order_traversal(root)</span><br><span class="line">print(f&quot;层次遍历结果: &#123;level_order_result&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 输出树的结构</span><br><span class="line">tree_structure = print_tree_structure(root)</span><br><span class="line">print(f&quot;树的结构: &#123;tree_structure&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 层次遍历结果: DASCTF&#123;asd48_daj7w_3adqo&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define num 26</span><br><span class="line">char mid[] = &quot;ja7Cws_A3daTd4qDo8&#125;F_Sd&#123;a&quot;;</span><br><span class="line">char post[] = &quot;j7aw_sC3addq4TAo&#125;8_Fda&#123;SD&quot;;</span><br><span class="line">// 目标：给出中序遍历和后序遍历序列，求出完全二叉树结构（打印出层次遍历序列）</span><br><span class="line">typedef struct tree</span><br><span class="line">&#123;</span><br><span class="line">	char c;</span><br><span class="line">	struct tree *left,*right;</span><br><span class="line">&#125;tree;</span><br><span class="line">tree *creat(int ms,int me,int ps,int pe)&#123;   // 反推树的结构</span><br><span class="line">	if(ms&gt;me||ps&gt;pe) return NULL;</span><br><span class="line">	tree *t=(tree  *)malloc(sizeof(tree));</span><br><span class="line">	char charAt=post[pe];</span><br><span class="line">	int i;</span><br><span class="line">	for(i=ms;i&lt;=me&amp;&amp;mid[i]!=charAt;i++) &#123;&#125;</span><br><span class="line">	t-&gt;c=charAt;</span><br><span class="line">	t-&gt;left=creat(ms,i-1,ps, ps + i - ms - 1);</span><br><span class="line">	t-&gt;right=creat(i+1,me, ps + i - ms,pe-1);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">void pre_travel(tree *t)&#123;    // 前序遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	printf(&quot;%c&quot;,t-&gt;c);</span><br><span class="line">	pre_travel(t-&gt;left);</span><br><span class="line">	pre_travel(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">// 层次遍历</span><br><span class="line">typedef struct q&#123;  // 创建队列</span><br><span class="line">	tree *c[num];</span><br><span class="line">	int r,f;</span><br><span class="line">&#125;queue;</span><br><span class="line">void init(queue *q)&#123;   //初始化队列</span><br><span class="line">	q-&gt;r=q-&gt;f=0;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q,tree *t) &#123; // 入队</span><br><span class="line">	if((q-&gt;f+1)%num==q-&gt;r) &#123;printf(&quot;队满！\n&quot;);return;&#125;</span><br><span class="line">	q-&gt;c[q-&gt;f]=t;</span><br><span class="line">	q-&gt;f=(q-&gt;f+1)%num;</span><br><span class="line">&#125;</span><br><span class="line">tree *dequeue(queue *q) &#123;  // 出队</span><br><span class="line">	if(q-&gt;f==q-&gt;r) &#123;printf(&quot;队空！\n&quot;);return NULL;&#125;</span><br><span class="line">	tree *temp=q-&gt;c[q-&gt;r];</span><br><span class="line">	q-&gt;r=(q-&gt;r+1)%num;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void level_travel(tree *t)&#123;  //  层次遍历</span><br><span class="line">	if(t==NULL) return;</span><br><span class="line">	queue *q=(queue *)malloc(sizeof(queue));</span><br><span class="line">	tree *temp;</span><br><span class="line">	init(q);</span><br><span class="line">	enqueue(q,t);</span><br><span class="line">	while(q-&gt;f!=q-&gt;r)&#123;</span><br><span class="line">		temp=dequeue(q);</span><br><span class="line">		printf(&quot;%c&quot;,temp-&gt;c);</span><br><span class="line">		if(temp-&gt;left!=NULL) enqueue(q,temp-&gt;left);</span><br><span class="line">		if(temp-&gt;right!=NULL) enqueue(q,temp-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	free(q);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	tree *t=creat(0,strlen(mid)-1,0,strlen(post)-1);</span><br><span class="line">	// pre_travel(t);</span><br><span class="line">	level_travel(t);</span><br><span class="line">&#125;</span><br><span class="line">//层次遍历结果: DASCTF&#123;asd48_daj7w_3adqo&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>添加节</title>
    <url>/posts/8809/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="添加节："><a href="#添加节：" class="headerlink" title="添加节："></a>添加节：</h1><p>创建新节：</p>
<ol>
<li>分配新空间</li>
<li>加节表，需要80字节空间（40字节节表，40字节空节表）</li>
<li>修改文件头中NumberOfSections，增加可选头sizeofimage</li>
<li>填充节表内容</li>
</ol>
<p>注意：节表中的VirtualSize是内存对齐前的大小，在添加节时，新节的内存起始偏移应该是最后一个节的RVA+(（VirtualSize&#x2F;内存对齐）+1)*内存对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">int new_section(int new_size)&#123;  // 创建新节，参数：新节大小，返回值：是否成功创建</span><br><span class="line">    // 判断是否能加节表:</span><br><span class="line">    if(oheader-&gt;SizeOfHeaders-(dos-&gt;e_lfanew+4+sizeof(IMAGE_FILE_HEADER)+fheader-&gt;SizeOfOptionalHeader+fheader-&gt;NumberOfSections*sizeof(IMAGE_SECTION_HEADER))&lt;=80)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;空间不足以创建节表\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = fheader-&gt;NumberOfSections;</span><br><span class="line">    strcpy(sheader[index].Name,&quot;new&quot;);</span><br><span class="line">    sheader[index].Misc.VirtualSize = new_size;</span><br><span class="line">    sheader[index].VirtualAddress = sheader[index-1].VirtualAddress + ((sheader[index-1].Misc.VirtualSize)/oheader-&gt;SectionAlignment+1)*oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].PointerToRawData = sheader[index-1].PointerToRawData + sheader[index-1].SizeOfRawData;</span><br><span class="line">    sheader[index].SizeOfRawData = new_size;</span><br><span class="line">    sheader[index].Characteristics = 0xE00000A0;  // 可读可写可执行</span><br><span class="line">    sheader[index].PointerToRelocations = sheader[index-1].PointerToRelocations;</span><br><span class="line">    sheader[index].PointerToLinenumbers = sheader[index-1].PointerToLinenumbers;</span><br><span class="line">    sheader[index].NumberOfRelocations = sheader[index-1].NumberOfRelocations;</span><br><span class="line">    sheader[index].NumberOfLinenumbers = sheader[index-1].NumberOfLinenumbers;</span><br><span class="line">    fheader-&gt;NumberOfSections++;</span><br><span class="line">    oheader-&gt;SizeOfImage+=oheader-&gt;SectionAlignment;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int new_size = 0x1000;  // 定义新节大小</span><br><span class="line">    const char* pe_path = &quot;dlltest.dll&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    int fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize+new_size);   // 多分配0x1000用作新节</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *buffer=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    if(dos-&gt;e_magic!=0x5A4D) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=dos-&gt;e_lfanew;  // 定位文件头</span><br><span class="line">    if(*(DWORD*)buffer!=0x4550) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=4;</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer+=sizeof(IMAGE_FILE_HEADER);      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    if(!new_section(new_size))&#123;free(file_buf);return 0;&#125;</span><br><span class="line">    // 写入新文件中</span><br><span class="line">    FILE *new_file = fopen(&quot;new.dll&quot;,&quot;wb&quot;);</span><br><span class="line">    if (!new_file) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int written=fwrite(file_buf,sizeof(unsigned char),fsize+new_size,new_file);</span><br><span class="line">    if(written!=fsize+new_size)&#123;</span><br><span class="line">        perror(&quot;写入错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(new_file);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量</title>
    <url>/posts/31372/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="引子："><a href="#引子：" class="headerlink" title="引子："></a>引子：</h1><p>前几天在使用z3时，发现没办法调用Int函数和Bitvec函数，了解了一下才知道anconda默认的pip安装的默认包是低版本z3，没有包含这两函数。于是我尝试删除z3，重新下一个高版本的（z3-slover），但是发现pip无法使用。整了半天才发现是一个月前把python.exe名字改了（因为电脑上python版本比较多，为了切换方便，我就把解释器名字加上了版本号），但是有个比较奇怪的事，就是python使用完全正常，就是pip用不了，看来不是环境变量配置错误了。经过查询才知道，由于解释器的名字改了，导致pip配置文件conda-script.py出现错误，无法找到解释器，导致系统无法正确调用解释器执行脚本，在这个文件上首行加上一句修改后的解释器路径就行。但是这也引出了我的疑问，环境变量是怎么起作用的？为什么我们大多数时候配置环境变量都在Path处配置，而不是其他？</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>不同的环境变量作用不一样，但是大部分环境变量都是为了是帮助系统快速定位文件，不用输入完整路径。以下列出常见的环境变量。</p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>作为最常用的环境变量，在大部分环境配置时都会用到它，无论是配置python、java还是其他环境。Path变量的主要作用就是帮助系统快速找到.exe文件。当你在cmd里面输入python时，系统会一条一条遍历path里面路径，在每一个路径里面寻找同名exe文件，如python.exe文件找到第一个同名exe文件时就会运行它。由于它是按path里面从上往下查找，所以在上面的路径会优先被找到。</p>
<p><strong>实验：验证path查找顺序</strong></p>
<p>这里创建两个同名exe文件，分别放在不同的目录下，运行这两个文件，一个会输出1，一个会输出2。接下来把他们放在系统变量的path里面，1在前，2在后，再在终端输入文件名，看哪个文件被打开：</p>
<img src="/posts/31372/image-20250414235452359.png" class="" title="image-20250414235452359">

<p>结果很明显，是在前面的1起作用了。为了形成对照，我把这两条路径顺序换一下再试试：</p>
<img src="/posts/31372/image-20250414235747259.png" class="" title="image-20250414235747259">

<p>发现顺序换后是2被打开。至此，可以得到：在path越前的路径越是优先。如果有多个版本的python（或其他），如果想要输入python后运行某个版本，那就把这个版本的路径放前面。</p>
<p><strong>实验：验证文件查找优先性</strong></p>
<p>如果一个文件夹里面有一个exe文件，即test.exe，而path里面也有一条路径里面包含test.exe（不是同一个文件），如果我在第一个文件夹里面打开终端，输入test，那么究竟是哪个exe文件会被打开呢?</p>
<p>文件夹path1里面放了一个test.exe，它运行会输出1。文件夹path2里面放了另一个test.exe，运行会输出2。把path1路径放进path里面，在文件夹path2里面打开终端，输入test：</p>
<p>方式一：右键菜单的“在终端中打开</p>
<img src="/posts/31372/image-20250415003415489.png" class="" title="image-20250415003415489">

<p>方式二：文件地址栏输入cmd</p>
<img src="/posts/31372/image-20250415003519150.png" class="" title="image-20250415003519150">

<p>两种不同方式打开终端，得到的结果完全不一样!!!!!!!!!</p>
<p>仔细看一下，发现，一个是cmd，一个是powershell。本来以为这两个东西是一样的，结果发现其实并不一样。</p>
<p><strong>CMD</strong>：源自1981年的MS-DOS系统，主要用于执行基础命令和批处理脚本（.bat）。它继承传统的命令行操作，兼容性高但功能有限</p>
<p><strong>PowerShell</strong>：2006年由微软推出，基于.NET Framework开发，目标是成为面向对象、支持自动化的高级脚本语言和系统管理工具。Windows 11已将其设为默认命令行工具。</p>
<p>现在微软正在着手于用powershell取代cmd。</p>
<p>由于鼠标右键默认打开的是powershell，而在地址栏输入cmd打开的是cmd，这两种命令行使用方式不同:</p>
<p>cmd：输入文件名会自己查找本目录</p>
<p>powershow：直接输入文件名会识别错误，必须在文件名前加前缀，如”.\test”，这样输入就是指定其在本目录查找。这里得到1是因为直接输入文件名不满足它的语法，但是满足path的语法，于是执行path里面的文件。</p>
<p>于是两种方式得到了不一样的结果。</p>
<p><strong>实验：探究用户变量的path与系统变量的path优先级</strong></p>
<p>用户变量的path里面加入1的路径，系统变量的path里面加入2的路径，在终端输入test：</p>
<img src="/posts/31372/image-20250415082909230.png" class="" title="image-20250415082909230">

<p>得到系统变量path&gt;用户变量path</p>
<h2 id="其他变量"><a href="#其他变量" class="headerlink" title="其他变量"></a>其他变量</h2><p>当我们在终端输入一个字符串时，系统怎么知道我们输入的是在哪个系统变量（或环境变量）里面的呢？会不会是遍历所有变量，直到找到exe文件呢？</p>
<p>答案是否定。其他变量的作用并不是像path专门用来查找exe文件，而是像一个替换。例如我加一条变量：</p>
<img src="/posts/31372/image-20250415090957352.png" class="" title="image-20250415090957352">

<p>那么之后，就可以用MYTEST（不区分大小写）来代指（替换）这条路径。其他变量的用法和path不一样，他们必须要显示地调用，即:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%变量名%</span><br></pre></td></tr></table></figure>

<p>如果我直接在cmd里面输入mytest，系统会把它作为指令在path里面进行搜索，没有找到path里面称为</p>
<p>mytest.exe的文件，然后就会报错：</p>
<img src="/posts/31372/image-20250415091116006.png" class="" title="image-20250415091116006">

<p>当然，并不是指我输入%mytest%就能直接运行里面的test.exe，因为在终端里面输入%mytest%后，由于是显式调用，系统不会把他识别为命令，而是从第一条系统变量开始找，直到找到同名的系统变量，即之前创建的MYTEST，然后用MYTEST里面的值替换，所以，实际上就等同于我在终端输入C:\Users\tzs\Desktop\path2，这样替换之后，系统又会把它识别为命令，然后报错:</p>
<img src="/posts/31372/image-20250415091824371.png" class="" title="image-20250415091824371">

<p>正确的做法是输入可执行文件的完整路径，即%mytest%\test，这样等同于C:\Users\tzs\Desktop\path2\test，系统就会查找到test.exe，然后运行:</p>
<img src="/posts/31372/image-20250415092043978.png" class="" title="image-20250415092043978">
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>移动导出表、重定位表</title>
    <url>/posts/56776/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="移动重定位表："><a href="#移动重定位表：" class="headerlink" title="移动重定位表："></a>移动重定位表：</h1><p>主要思路：</p>
<ol>
<li>先遍历出重定位表大小</li>
<li>复制整个重定位表（注意：最后的那个空表也要复制）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">int num=0;           //节数量</span><br><span class="line">int header_size=0;   // PE头大小</span><br><span class="line">int base=0;          // 基址</span><br><span class="line">int fsize=0,image_size=0; // 文件大小；文件映射的内存大小</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">	DWORD foa=0;</span><br><span class="line">    if(rva&lt;=header_size) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rva&lt;sheader[0].VirtualAddress) &#123;</span><br><span class="line">        printf(&quot;没有对应的foa!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &gt;= num) &#123;</span><br><span class="line">        printf(&quot;RVA超出范围!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">	return foa;</span><br><span class="line">&#125;</span><br><span class="line">void new_section()&#123;  // 创建新节</span><br><span class="line">    int index = fheader-&gt;NumberOfSections;</span><br><span class="line">    strcpy(sheader[index].Name,&quot;new&quot;);</span><br><span class="line">    sheader[index].Misc.VirtualSize = oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].VirtualAddress = sheader[index-1].VirtualAddress + ((sheader[index-1].Misc.VirtualSize)/oheader-&gt;SectionAlignment+1)*oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].PointerToRawData = sheader[index-1].PointerToRawData + sheader[index-1].SizeOfRawData;</span><br><span class="line">    sheader[index].SizeOfRawData = 0x1000;</span><br><span class="line">    sheader[index].Characteristics = sheader[index-1].Characteristics;</span><br><span class="line">    sheader[index].PointerToRelocations = sheader[index-1].PointerToRelocations;</span><br><span class="line">    sheader[index].PointerToLinenumbers = sheader[index-1].PointerToLinenumbers;</span><br><span class="line">    sheader[index].NumberOfRelocations = sheader[index-1].NumberOfRelocations;</span><br><span class="line">    sheader[index].NumberOfLinenumbers = sheader[index-1].NumberOfLinenumbers;</span><br><span class="line">    fheader-&gt;NumberOfSections++;</span><br><span class="line">    oheader-&gt;SizeOfImage+=oheader-&gt;SectionAlignment;</span><br><span class="line">&#125;</span><br><span class="line">int relocation_size(unsigned char *location)&#123;</span><br><span class="line">    IMAGE_BASE_RELOCATION* relocation=(IMAGE_BASE_RELOCATION*)location;</span><br><span class="line">    if(relocation-&gt;SizeOfBlock==0) return 8;  // 最后一个空表占8个字节</span><br><span class="line">    location += relocation-&gt;SizeOfBlock;</span><br><span class="line">    return relocation-&gt;SizeOfBlock+relocation_size(location);</span><br><span class="line">&#125;</span><br><span class="line">void move_relocation(unsigned char *location,unsigned char *section)&#123;  // 移动重定位表</span><br><span class="line">    int size = relocation_size(location);</span><br><span class="line">    memcpy(section,location,size);</span><br><span class="line">    IMAGE_BASE_RELOCATION* relocation=(IMAGE_BASE_RELOCATION*)location;</span><br><span class="line">    oheader-&gt;DataDirectory[5].VirtualAddress = sheader[fheader-&gt;NumberOfSections-1].VirtualAddress;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // if(argc != 2) &#123;</span><br><span class="line">    //     printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">    //     return 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    const char* pe_path = &quot;dlltest.dll&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize+0x1000);   // 多分配0x1000用作新节</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *offset=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)offset;</span><br><span class="line">    offset+=dos-&gt;e_lfanew+4;  // 定位文件头</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)offset;</span><br><span class="line">    num = fheader-&gt;NumberOfSections;</span><br><span class="line">    offset+=20;      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)offset;</span><br><span class="line">    header_size=oheader-&gt;SizeOfHeaders;</span><br><span class="line">    base=oheader-&gt;ImageBase;</span><br><span class="line">    image_size = oheader-&gt;SizeOfImage;</span><br><span class="line">    offset += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    int size = num * sizeof(IMAGE_SECTION_HEADER);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)offset;</span><br><span class="line">    new_section();</span><br><span class="line">    DWORD redelocation_rva = oheader-&gt;DataDirectory[5].VirtualAddress;</span><br><span class="line">	DWORD relocation_foa = RVA_to_FOA(redelocation_rva);</span><br><span class="line">	if(relocation_foa == 0) &#123;</span><br><span class="line">		printf(&quot;重定位表RVA转换失败\n&quot;);</span><br><span class="line">		free(file_buf);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">    move_relocation(file_buf+relocation_foa,file_buf+sheader[fheader-&gt;NumberOfSections-1].PointerToRawData);</span><br><span class="line">    FILE *new_file = fopen(&quot;new.dll&quot;,&quot;wb&quot;);</span><br><span class="line">    if (!new_file) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int written=fwrite(file_buf,sizeof(unsigned char),fsize+0x1000,new_file);</span><br><span class="line">    if(written!=fsize+0x1000)&#123;</span><br><span class="line">        perror(&quot;写入错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(new_file);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h1><p>主要思路</p>
<ol>
<li>移动导出表结构体（要把dll名字也移出）</li>
<li>移动三张表（名字表中名字也要移出）</li>
<li>修改可选头里导出表RVA</li>
<li>修正导出表成员（包括三张表位置）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">IMAGE_EXPORT_DIRECTORY* export;</span><br><span class="line">int num=0;           //节数量</span><br><span class="line">int header_size=0;   // PE头大小</span><br><span class="line">int base=0;          // 基址</span><br><span class="line">int fsize=0,image_size=0; // 文件大小；文件映射的内存大小</span><br><span class="line">DWORD FOA_to_RVA(DWORD foa)&#123;</span><br><span class="line">    DWORD rva=0;</span><br><span class="line">    if(foa&lt;=header_size) &#123;</span><br><span class="line">        rva = foa;</span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(foa&gt;=sheader[i].PointerToRawData&amp;&amp;foa&lt;(sheader[i].PointerToRawData+sheader[i].SizeOfRawData))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=foa-sheader[i].PointerToRawData;</span><br><span class="line">    rva = sheader[i].VirtualAddress + offset;</span><br><span class="line">    return rva;</span><br><span class="line">&#125;</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">	DWORD foa=0;</span><br><span class="line">    if(rva&lt;=header_size) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rva&lt;sheader[0].VirtualAddress) &#123;</span><br><span class="line">        printf(&quot;没有对应的foa!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &gt;= num) &#123;</span><br><span class="line">        printf(&quot;RVA超出范围!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">	return foa;</span><br><span class="line">&#125;</span><br><span class="line">void new_section()&#123;  // 创建新节</span><br><span class="line">    int index = fheader-&gt;NumberOfSections;</span><br><span class="line">    strcpy(sheader[index].Name,&quot;newsection&quot;);</span><br><span class="line">    sheader[index].Misc.VirtualSize = oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].VirtualAddress = sheader[index-1].VirtualAddress + ((sheader[index-1].Misc.VirtualSize)/oheader-&gt;SectionAlignment+1)*oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].PointerToRawData = sheader[index-1].PointerToRawData + sheader[index-1].SizeOfRawData;</span><br><span class="line">    sheader[index].SizeOfRawData = 0x1000;</span><br><span class="line">    sheader[index].Characteristics = sheader[index-1].Characteristics;</span><br><span class="line">    sheader[index].PointerToRelocations = sheader[index-1].PointerToRelocations;</span><br><span class="line">    sheader[index].PointerToLinenumbers = sheader[index-1].PointerToLinenumbers;</span><br><span class="line">    sheader[index].NumberOfRelocations = sheader[index-1].NumberOfRelocations;</span><br><span class="line">    sheader[index].NumberOfLinenumbers = sheader[index-1].NumberOfLinenumbers;</span><br><span class="line">    fheader-&gt;NumberOfSections++;</span><br><span class="line">    oheader-&gt;SizeOfImage+=oheader-&gt;SectionAlignment;</span><br><span class="line">&#125;</span><br><span class="line">DWORD move_export_struct(DWORD offset,DWORD export_foa,unsigned char *file_buf)&#123;</span><br><span class="line">    int size = sizeof(IMAGE_EXPORT_DIRECTORY);</span><br><span class="line">    memcpy(offset+file_buf,(unsigned char *)(export_foa+file_buf),size);</span><br><span class="line">    oheader-&gt;DataDirectory[0].VirtualAddress = sheader[fheader-&gt;NumberOfSections-1].VirtualAddress;</span><br><span class="line">    offset += size;</span><br><span class="line">    char *s = (char *)(RVA_to_FOA(export-&gt;Name)+file_buf);   // 移动dll名字</span><br><span class="line">    strcpy((char *)(offset+file_buf),s);</span><br><span class="line">    export-&gt;Name = FOA_to_RVA(offset);</span><br><span class="line">    offset += strlen(s)+1;</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">DWORD mov_table(DWORD offset,unsigned char *file_buf)&#123;</span><br><span class="line">    DWORD* NameTable=(DWORD*)(RVA_to_FOA(export-&gt;AddressOfNames)+file_buf);</span><br><span class="line">	unsigned char* OrdinalTable=RVA_to_FOA(export-&gt;AddressOfNameOrdinals)+file_buf;</span><br><span class="line">	unsigned char* AddressTable=RVA_to_FOA(export-&gt;AddressOfFunctions)+file_buf;</span><br><span class="line">    // 移地址表</span><br><span class="line">    int size = 4*(export-&gt;NumberOfFunctions);</span><br><span class="line">    memcpy(offset+file_buf,AddressTable,size);</span><br><span class="line">    export-&gt;AddressOfFunctions = FOA_to_RVA(offset);</span><br><span class="line">    offset += size;</span><br><span class="line">    // 移序号表</span><br><span class="line">    size = 2*(export-&gt;NumberOfNames);</span><br><span class="line">    memcpy(offset+file_buf,OrdinalTable,size);</span><br><span class="line">    export-&gt;AddressOfNameOrdinals = FOA_to_RVA(offset);</span><br><span class="line">    offset += size;</span><br><span class="line">    // 移名称表</span><br><span class="line">    int i = 0,len = 0;</span><br><span class="line">    size = 4*(export-&gt;NumberOfNames);</span><br><span class="line">    char * s=NULL;</span><br><span class="line">    DWORD *data =(DWORD*)malloc(size);</span><br><span class="line">    for(i=0;i&lt;export-&gt;NumberOfNames;i++)&#123;</span><br><span class="line">        s = (char*)(RVA_to_FOA(NameTable[i])+file_buf);</span><br><span class="line">        len = strlen(s);</span><br><span class="line">        strcpy(file_buf+offset,s);</span><br><span class="line">        data[i] = FOA_to_RVA(offset);</span><br><span class="line">        offset+=len+1;  // 结尾为&#x27;\0&#x27;，故要加1</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(file_buf+offset,(unsigned char *)data,size);</span><br><span class="line">    export-&gt;AddressOfNames = FOA_to_RVA(offset);</span><br><span class="line">    free(data);</span><br><span class="line">    offset += size;</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // if(argc != 2) &#123;</span><br><span class="line">    //     printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">    //     return 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    const char* pe_path = &quot;dlltest.dll&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize+0x1000);   // 多分配0x1000用作新节</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *buffer=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    buffer+=dos-&gt;e_lfanew+4;  // 定位文件头</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    num = fheader-&gt;NumberOfSections;</span><br><span class="line">    buffer+=20;      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    header_size=oheader-&gt;SizeOfHeaders;</span><br><span class="line">    base=oheader-&gt;ImageBase;</span><br><span class="line">    image_size = oheader-&gt;SizeOfImage;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    int size = num * sizeof(IMAGE_SECTION_HEADER);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    new_section();</span><br><span class="line">    DWORD new_foa = sheader[fheader-&gt;NumberOfSections-1].PointerToRawData; // 新节的foa</span><br><span class="line">    DWORD offset=new_foa;</span><br><span class="line">    DWORD export_rva = oheader-&gt;DataDirectory[0].VirtualAddress;</span><br><span class="line">	DWORD export_foa = RVA_to_FOA(export_rva);</span><br><span class="line">	if(export_foa == 0) &#123;</span><br><span class="line">		printf(&quot;导出表RVA转换失败\n&quot;);</span><br><span class="line">		free(file_buf);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">    export = (IMAGE_EXPORT_DIRECTORY*)(new_foa+file_buf);</span><br><span class="line">    offset = move_export_struct(offset,export_foa,file_buf);</span><br><span class="line">    offset = mov_table(offset,file_buf);</span><br><span class="line">    FILE *new_file = fopen(&quot;new.dll&quot;,&quot;wb&quot;);</span><br><span class="line">    if (!new_file) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int written=fwrite(file_buf,sizeof(unsigned char),fsize+0x1000,new_file);</span><br><span class="line">    if(written!=fsize+0x1000)&#123;</span><br><span class="line">        perror(&quot;写入错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(new_file);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>蜀道山wp</title>
    <url>/posts/46980/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="Map-Maze"><a href="#Map-Maze" class="headerlink" title="Map_Maze"></a>Map_Maze</h2><p>非常好的一道迷宫题，击碎了我对指针的自信~~</p>
<p>主函数：</p>
<img src="/posts/46980/image-20241203205913912.png" class="" title="image-20241203205913912">

<p>但是建图函数和判断函数极其抽象。建图函数先截取一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl create_map(_DWORD *a1, _DWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  for ( i = 0; i &lt; 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( j = 0; j &lt; 15; ++j )</span><br><span class="line">      v5[15 * i + j] = sub_401080(0);   //先分配255个空间（不连续的），地址作为数组v5的元素（实际越界到了v6）</span><br><span class="line">  &#125;</span><br><span class="line">  for ( k = 1; k &lt; 15; ++k )</span><br><span class="line">    *(_DWORD *)v5[k] = 1;        //这里的赋值是取v5[i]的值转化为指针，将指针指向的地址赋值为1（或0）</span><br><span class="line">  for ( m = 9; m &lt; 15; ++m )</span><br><span class="line">    *(_DWORD *)v5[m + 15] = 1;</span><br><span class="line">    ......      //省略了中间的赋值环节</span><br><span class="line">    ......</span><br><span class="line">  for ( i27 = 13; i27 &lt; 15; ++i27 )</span><br><span class="line">    *(_DWORD *)v6[i27 + 90] = 1;</span><br><span class="line">  for ( i28 = 0; i28 &lt; 12; ++i28 )</span><br><span class="line">    *(_DWORD *)v6[i28 + 105] = 1;</span><br><span class="line">  for ( i29 = 0; i29 &lt; 15; ++i29 )     //这个双循环是重头戏：</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i30 = 0; i30 &lt; 15; ++i30 )     </span><br><span class="line">    &#123;     //为了方便表示，我将*v5[15 * i29 + i30]写为a[],也就是指针a等于v5对应下标的元素转化为的指针</span><br><span class="line">      if ( i29 &gt; 0 )    //i29&gt;0，说明不在第一行，意味着上方元素存在</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 4) = v5[15 * i29 - 15 + i30];  //将上方元素的地址赋值给a[1]</span><br><span class="line">      if ( i29 &lt; 14 )   //不在最后一行，即下方元素存在</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 8) = v5[15 * i29 + 15 + i30];  //将下方元素的地址赋值给a[2]</span><br><span class="line">      if ( i30 &gt; 0 )</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 12) = v5[15 * i29 - 1 + i30];  //将左方元素的地址赋值给a[3]</span><br><span class="line">      if ( i30 &lt; 14 )</span><br><span class="line">        *(_DWORD *)(v5[15 * i29 + i30] + 16) = v5[15 * i29 + 1 + i30];  //将右方元素的地址赋值给a[4]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;       //下面是定义起点和终点</span><br><span class="line">  v2 = (_DWORD *)v5[0];      //先取出v5第一个元素，转化为地址赋值给v2</span><br><span class="line">  *a1 = *(_DWORD *)v5[0];    //a1是起点，将V5第一个元素指向的值传给a1指向的地址（传的是1或0）</span><br><span class="line">  a1[1] = v2[1];     		 //将v2[1]（对应前面双循环赋值的上方元素）赋值给a1[1]</span><br><span class="line">  a1[2] = v2[2];			 //将v2[2]（对应前面双循环赋值的下方元素）赋值给a1[2]</span><br><span class="line">  a1[3] = v2[3];			 //将v2[3]（对应前面双循环赋值的左方元素）赋值给a1[3]</span><br><span class="line">  a1[4] = v2[4];			 //将v2[4]（对应前面双循环赋值的右方元素）赋值给a1[4]</span><br><span class="line">  v3 = v7;		//下面就是定义终点了，逻辑与定义起点相同</span><br><span class="line">  *a2 = *v7;</span><br><span class="line">  a2[1] = v3[1];</span><br><span class="line">  a2[2] = v3[2];</span><br><span class="line">  a2[3] = v3[3];</span><br><span class="line">  result = v3[4];</span><br><span class="line">  a2[4] = result;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a[0]处存的是v5[i]指向的地址的值（0或1），a[1]~a[4]正常情况填的都是地址，如果上下左右对应的地方（地图v5里面）不存在值的话就不用填入地址</p>
<p>![屏幕截图 2024-12-03 222145](.&#x2F;蜀道山wp&#x2F;屏幕截图 2024-12-03 222145.png)</p>
<p>判断函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char __cdecl judge_path(_DWORD *a1, _DWORD *a2, int a3)  //a1是位置，a2是终点，a3是输入</span><br><span class="line">&#123;</span><br><span class="line">  for ( i = 0; *(_BYTE *)(i + a3); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *(_BYTE *)(i + a3) == &#x27;U&#x27; &amp;&amp; a1[1] &amp;&amp; !*(_DWORD *)a1[1] )   //输入&quot;U&quot;且上方元素存在</span><br><span class="line">    &#123;</span><br><span class="line">      a1 = (_DWORD *)a1[1];     //a1[1]存的是其上方的地址</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *(_BYTE *)(i + a3) == &#x27;D&#x27; &amp;&amp; a1[2] &amp;&amp; !*(_DWORD *)a1[2] )   //&quot;D&quot;则取其下方的地址</span><br><span class="line">    &#123;</span><br><span class="line">      a1 = (_DWORD *)a1[2];   </span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *(_BYTE *)(i + a3) == &#x27;L&#x27; &amp;&amp; a1[3] &amp;&amp; !*(_DWORD *)a1[3] )</span><br><span class="line">    &#123;</span><br><span class="line">      a1 = (_DWORD *)a1[3];     //a1[3]存的是其左方的地址</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(_BYTE *)(i + a3) != &#x27;R&#x27; || !a1[4] || *(_DWORD *)a1[4] )</span><br><span class="line">        return 0;</span><br><span class="line">      a1 = (_DWORD *)a1[4];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result = (char)a2;</span><br><span class="line">  if ( a1[2] == a2[2] )    //下面是判断其上下左右的值是否对的上，如果对的上，这返回1</span><br><span class="line">  &#123;</span><br><span class="line">    result = (char)a2;</span><br><span class="line">    if ( a1[1] == a2[1] )</span><br><span class="line">    &#123;</span><br><span class="line">      result = (char)a2;</span><br><span class="line">      if ( a1[3] == a2[3] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = (char)a2;</span><br><span class="line">        if ( a1[4] == a2[4] )</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以真正的地图就是v5[i]指向的位置汇成的一张15x15的地图，由0和1构成。</p>
<p>怎么提取出地图来呢？可以把伪代码复制修改再运行一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int i28; // [esp+384h] [ebp-A0h]</span><br><span class="line">  int i27; // [esp+388h] [ebp-9Ch]</span><br><span class="line">  int i26; // [esp+38Ch] [ebp-98h]</span><br><span class="line">  int i25; // [esp+390h] [ebp-94h]</span><br><span class="line">  int i24; // [esp+394h] [ebp-90h]</span><br><span class="line">  int i23; // [esp+398h] [ebp-8Ch]</span><br><span class="line">  int i22; // [esp+39Ch] [ebp-88h]</span><br><span class="line">  int i21; // [esp+3A0h] [ebp-84h]</span><br><span class="line">  int i20; // [esp+3A4h] [ebp-80h]</span><br><span class="line">  int i19; // [esp+3A8h] [ebp-7Ch]</span><br><span class="line">  int i18; // [esp+3ACh] [ebp-78h]</span><br><span class="line">  int i17; // [esp+3B0h] [ebp-74h]</span><br><span class="line">  int i16; // [esp+3B4h] [ebp-70h]</span><br><span class="line">  int i15; // [esp+3B8h] [ebp-6Ch]</span><br><span class="line">  int i14; // [esp+3BCh] [ebp-68h]</span><br><span class="line">  int i13; // [esp+3C0h] [ebp-64h]</span><br><span class="line">  int i12; // [esp+3C4h] [ebp-60h]</span><br><span class="line">  int i11; // [esp+3C8h] [ebp-5Ch]</span><br><span class="line">  int i10; // [esp+3CCh] [ebp-58h]</span><br><span class="line">  int i9; // [esp+3D0h] [ebp-54h]</span><br><span class="line">  int i8; // [esp+3D4h] [ebp-50h]</span><br><span class="line">  int i7; // [esp+3D8h] [ebp-4Ch]</span><br><span class="line">  int i6; // [esp+3DCh] [ebp-48h]</span><br><span class="line">  int i5; // [esp+3E0h] [ebp-44h]</span><br><span class="line">  int i4; // [esp+3E4h] [ebp-40h]</span><br><span class="line">  int i3; // [esp+3E8h] [ebp-3Ch]</span><br><span class="line">  int i2; // [esp+3ECh] [ebp-38h]</span><br><span class="line">  int i1; // [esp+3F0h] [ebp-34h]</span><br><span class="line">  int nn; // [esp+3F4h] [ebp-30h]</span><br><span class="line">  int mm; // [esp+3F8h] [ebp-2Ch]</span><br><span class="line">  int kk; // [esp+3FCh] [ebp-28h]</span><br><span class="line">  int jj; // [esp+400h] [ebp-24h]</span><br><span class="line">  int ii; // [esp+404h] [ebp-20h]</span><br><span class="line">  int n; // [esp+408h] [ebp-1Ch]</span><br><span class="line">  int m; // [esp+40Ch] [ebp-18h]</span><br><span class="line">  int k; // [esp+410h] [ebp-14h]</span><br><span class="line">  int j; // [esp+414h] [ebp-10h]</span><br><span class="line">  int i; // [esp+418h] [ebp-Ch]</span><br><span class="line">  int i30; // [esp+41Ch] [ebp-8h]</span><br><span class="line">  int i29; // [esp+420h] [ebp-4h]</span><br><span class="line">    int maze[225]=&#123;0&#125;;</span><br><span class="line">    int *v5=maze;</span><br><span class="line">    int *v6=maze+105;</span><br><span class="line">  for ( k = 1; k &lt; 15; ++k )</span><br><span class="line">    v5[k] = 1;</span><br><span class="line">  for ( m = 9; m &lt; 15; ++m )</span><br><span class="line">    v5[m + 15] = 1;</span><br><span class="line">  for ( n = 0; n &lt; 2; ++n )</span><br><span class="line">    v5[n + 30] = 1;</span><br><span class="line">  for ( ii = 3; ii &lt; 8; ++ii )</span><br><span class="line">    v5[ii + 30] = 1;</span><br><span class="line">  for ( jj = 9; jj &lt; 15; ++jj )</span><br><span class="line">    v5[jj + 30] = 1;</span><br><span class="line">  for ( kk = 0; kk &lt; 2; ++kk )</span><br><span class="line">    v5[kk + 45] = 1;</span><br><span class="line">  for ( mm = 3; mm &lt; 8; ++mm )</span><br><span class="line">    v5[mm + 45] = 1;</span><br><span class="line">  for ( nn = 12; nn &lt; 15; ++nn )</span><br><span class="line">    v5[nn + 45] = 1;</span><br><span class="line">  for ( i1 = 0; i1 &lt; 2; ++i1 )</span><br><span class="line">    v5[i1 + 60] = 1;</span><br><span class="line">  for ( i2 = 7; i2 &lt; 10; ++i2 )</span><br><span class="line">    v5[i2 + 60] = 0;</span><br><span class="line">  v5[67] = 1;</span><br><span class="line">  for ( i3 = 11; i3 &lt; 15; ++i3 )</span><br><span class="line">    v5[i3 + 60] = 1;</span><br><span class="line">  for ( i4 = 0; i4 &lt; 2; ++i4 )</span><br><span class="line">    v5[i4 + 75] = 1;</span><br><span class="line">  for ( i5 = 3; i5 &lt; 6; ++i5 )</span><br><span class="line">    v5[i5 + 75] = 1;</span><br><span class="line">  for ( i6 = 11; i6 &lt; 15; ++i6 )</span><br><span class="line">    v5[i6 + 75] = 1;</span><br><span class="line">  for ( i7 = 0; i7 &lt; 2; ++i7 )</span><br><span class="line">    v5[i7 + 90] = 1;</span><br><span class="line">  v5[92] = 0;</span><br><span class="line">  for ( i8 = 3; i8 &lt; 6; ++i8 )</span><br><span class="line">    v5[i8 + 90] = 1;</span><br><span class="line">  for ( i9 = 7; i9 &lt; 10; ++i9 )</span><br><span class="line">    v5[i9 + 90] = 1;</span><br><span class="line">  for ( i10 = 11; i10 &lt; 15; ++i10 )</span><br><span class="line">    v5[i10 + 90] = 1;</span><br><span class="line">  v6[0] = 1;</span><br><span class="line">  v6[1] = 0;</span><br><span class="line">  v6[2] = 0;</span><br><span class="line">  v6[3] = 1;</span><br><span class="line">  for ( i11 = 4; i11 &lt; 6; ++i11 )</span><br><span class="line">    v6[i11] = 1;</span><br><span class="line">  for ( i12 = 7; i12 &lt; 10; ++i12 )</span><br><span class="line">    v6[i12] = 1;</span><br><span class="line">  for ( i13 = 11; i13 &lt; 15; ++i13 )</span><br><span class="line">    v6[i13] = 1;</span><br><span class="line">  for ( i14 = 0; i14 &lt; 2; ++i14 )</span><br><span class="line">    v6[i14 + 15] = 1;</span><br><span class="line">  for ( i15 = 7; i15 &lt; 10; ++i15 )</span><br><span class="line">    v6[i15 + 15] = 1;</span><br><span class="line">  for ( i16 = 11; i16 &lt; 15; ++i16 )</span><br><span class="line">    v6[i16 + 15] = 1;</span><br><span class="line">  for ( i17 = 0; i17 &lt; 6; ++i17 )</span><br><span class="line">    v6[i17 + 30] = 1;</span><br><span class="line">  for ( i18 = 7; i18 &lt; 10; ++i18 )</span><br><span class="line">    v6[i18 + 30] = 1;</span><br><span class="line">  for ( i19 = 11; i19 &lt; 15; ++i19 )</span><br><span class="line">    v6[i19 + 30] = 1;</span><br><span class="line">  for ( i20 = 0; i20 &lt; 6; ++i20 )</span><br><span class="line">    v6[i20 + 45] = 1;</span><br><span class="line">  for ( i21 = 11; i21 &lt; 15; ++i21 )</span><br><span class="line">    v6[i21 + 45] = 1;</span><br><span class="line">  for ( i22 = 0; i22 &lt; 9; ++i22 )</span><br><span class="line">    v6[i22 + 60] = 1;</span><br><span class="line">  for ( i23 = 13; i23 &lt; 15; ++i23 )</span><br><span class="line">    v6[i23 + 60] = 1;</span><br><span class="line">  for ( i24 = 0; i24 &lt; 9; ++i24 )</span><br><span class="line">    v6[i24 + 75] = 1;</span><br><span class="line">  v6[84] = 0;</span><br><span class="line">  v6[85] = 1;</span><br><span class="line">  v6[86] = 1;</span><br><span class="line">  v6[87] = 0;</span><br><span class="line">  for ( i25 = 13; i25 &lt; 15; ++i25 )</span><br><span class="line">    v6[i25 + 75] = 1;</span><br><span class="line">  for ( i26 = 0; i26 &lt; 9; ++i26 )</span><br><span class="line">    v6[i26 + 90] = 1;</span><br><span class="line">  v6[99] = 0;</span><br><span class="line">  v6[100] = 1;</span><br><span class="line">  v6[101] = 1;</span><br><span class="line">  v6[102] = 0;</span><br><span class="line">  for ( i27 = 13; i27 &lt; 15; ++i27 )</span><br><span class="line">    v6[i27 + 90] = 1;</span><br><span class="line">  for ( i28 = 0; i28 &lt; 12; ++i28 )</span><br><span class="line">    v6[i28 + 105] = 1;</span><br><span class="line">  for(i=0;i&lt;15;i++)&#123;</span><br><span class="line">    for(j=0;j&lt;15;j++)&#123;</span><br><span class="line">        if(maze[i*15+j]==0) printf(&quot;  &quot;);   //这里不打印0和1是为了让打印出地图更好看</span><br><span class="line">        else printf(&quot;o &quot;,maze[i*15+j]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  o o o o o o o o o o o o o o </span><br><span class="line">                  o o o o o o</span><br><span class="line">o o   o o o o o   o o o o o o</span><br><span class="line">o o   o o o o o         o o o</span><br><span class="line">o o           o       o o o o</span><br><span class="line">o o   o o o           o o o o</span><br><span class="line">o o   o o o   o o o   o o o o</span><br><span class="line">o     o o o   o o o   o o o o</span><br><span class="line">o o           o o o   o o o o</span><br><span class="line">o o o o o o   o o o   o o o o</span><br><span class="line">o o o o o o           o o o o</span><br><span class="line">o o o o o o o o o         o o</span><br><span class="line">o o o o o o o o o   o o   o o</span><br><span class="line">o o o o o o o o o   o o   o o</span><br><span class="line">o o o o o o o o o o o o</span><br></pre></td></tr></table></figure>

<p>路径：DRRDDDDDDDRRRRDDRRRDRRRDDDRR</p>
<p>md5结果：1979869e0c4ef6c542e54ae5c48f63ec</p>
<p>flag：LZSDS{1979869e0c4ef6c542e54ae5c48f63ec}</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>计网</title>
    <url>/posts/51165/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h1><hr>
<h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><hr>
<h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><p>以下关于以太网的描述,正确的是( C)</p>
<ul>
<li>A. 以太网提供差错检测和差错纠正的机制</li>
<li>B. 以太网提供碰撞检测机制</li>
<li>C. 以太网提供流量控制机制</li>
<li>D. 以太网提供拥塞控制机制</li>
</ul>
<p>答案：B。传统半双工以太网（使用CSMA&#x2F;CD的），<strong>无流量控制机制</strong>，冲突时依靠随机退避重传，流量控制由上层（如TCP）实现。</p>
<p><strong>DTE（终端设备）：</strong>Data Terminal Equipment，负责生成、处理或消费数据（如发送HTTP请求、运行应用程序）</p>
<p>注意：路由器也是DTE，因为路由器也会生成报文（如发送路由协议报文：OSPF、BGP），或响应管理请求（如回复ICMP Ping），这符合DTE“生成数据”的特性。</p>
<p><strong>DCE（数据通信设备）</strong>：Data Communication Device，负责转发或中继数据。（物理层和数据链路层）</p>
<ul>
<li>提供时钟同步（如调制解调器控制通信时序）。</li>
<li>信号格式转换（如将数字信号转为模拟信号）。</li>
<li>单纯转发数据（如交换机基于MAC地址转发帧）。</li>
</ul>
<p>特例：SOHO路由器的internet接口是DTE，LAN接口是DCE。</p>
<table>
<thead>
<tr>
<th>DTE设备</th>
<th>DTE设备</th>
</tr>
</thead>
<tbody><tr>
<td>主机、路由器、服务器</td>
<td>交换机、集线器、网桥、中继器</td>
</tr>
</tbody></table>
<p>可以认为：<strong>物理层与数据链路层设备通常属于DCE</strong>，而<strong>网络层及以上设备通常属于DTE</strong>。</p>
<p>相同类型设备之间使用交叉线，不同类型设备之间使用直通线。</p>
<table>
<thead>
<tr>
<th align="center"><strong>特性</strong></th>
<th align="center"><strong>基带传输 (Baseband)</strong></th>
<th align="center"><strong>宽带传输 (Broadband)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>信号类型</strong></td>
<td align="center">数字信号（直接0&#x2F;1脉冲）</td>
<td align="center">模拟信号（调制后高频载波）</td>
</tr>
<tr>
<td align="center"><strong>信道复用</strong></td>
<td align="center">❌ 无复用，独占信道</td>
<td align="center">✅ 频分复用（FDM），多路信号并行</td>
</tr>
<tr>
<td align="center"><strong>传输距离</strong></td>
<td align="center">短（&lt;500米）</td>
<td align="center">长（可达20公里+）</td>
</tr>
<tr>
<td align="center"><strong>典型速率</strong></td>
<td align="center">10 Mbps ~ 10 Gbps（受距离限制）</td>
<td align="center">50 Mbps ~ 1 Gbps（多业务共享总带宽）</td>
</tr>
<tr>
<td align="center"><strong>设备需求</strong></td>
<td align="center">网卡、交换机</td>
<td align="center">调制解调器、放大器、分频器</td>
</tr>
<tr>
<td align="center"><strong>适用场景</strong></td>
<td align="center">短距离数字通信（如局域网）</td>
<td align="center">长距离多业务融合（如电视+互联网）</td>
</tr>
<tr>
<td align="center"><strong>代表技术</strong></td>
<td align="center">10Base-T以太网、USB</td>
<td align="center">DOCSIS 3.1（有线宽带）、CATV</td>
</tr>
</tbody></table>
<hr>
<h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><p><strong>子网掩码与可用位数的关系：</strong><br>如果前8-n位为1，后n位为0的掩码十进制表示为<br>$$<br>2^8-2^n&#x3D;256-2^n<br>$$<br>如一个192.168.1.0&#x2F;24抽出5位划分子网，则其子网掩码第4部分为1111 1000 &#x3D; 256 - 8 &#x3D; 248，子网掩码为255.255.255.248</p>
<p><strong>已知IP、掩码快速求网络号、主机号</strong></p>
<p>例题：因特网上某主机的IP地址为128.200.68.101，子网掩码为255.255.255.240，该地址的主机号为？</p>
<p>法一：掩码240，256-240&#x3D;16&#x3D;2^4，也就是前4为为网络号，101-&gt;0110 0101，故其网络号为0110 0000即96，主机号为101-96&#x3D;5；</p>
<p>法二：掩码240，256-240&#x3D;16，101%16&#x3D;5，主机号5。101&#x2F;16&#x3D;6（子网号），网络号为16*6&#x3D;96。</p>
<p>法二的原理：求101的网络号就等于求其前4位，101&gt;&gt;4&#x3D;0000 0110（6），6&lt;&lt;4&#x3D;0110 0000(96)，右移4位等于整除16。</p>
<p>同时该网络：网络地址为128.200.68.96，可用主机数为256-240-2&#x3D;14，范围为128.200.68.97~128.200.68.110</p>
<p>现将一个IP网络划分为3个子网，若其中一个子网是192.168.9.128&#x2F;26，则下列网络中，不可能是另外两个子网之一的是（  D  ）。 </p>
<p>A、192.168.9.0&#x2F;25			B、192.168.9.192&#x2F;26</p>
<p>C、192.168.9.192&#x2F;27		D、192.168.9.0&#x2F;26</p>
<p>将一个网络划分为3个子网，要满足一下要求：</p>
<ul>
<li>3个子网互不包含</li>
<li>3个子网可完全覆盖原网络</li>
</ul>
<p>原网络未知，由于192.168.9.128属于C类网络，暂定原网络为&#x2F;24，则&#x2F;26说明借了两位，128代表10.00 0000，前两位是10。</p>
<p>分析A选项：192.168.9.0&#x2F;25 代表0.000 0000，相当于包含00和01，只需一个11即可完成覆盖</p>
<p>分析B选项：192.168.9.192&#x2F;26代表11.00 0000，相当于11，刚好与A互补可完成覆盖</p>
<p>分析C选项：192.168.9.192&#x2F;27代表110.0 0000，如果原网络为&#x2F;25，那么C代表10，192.168.9.128&#x2F;26代表0（00与01结合），只需一个					  11，即192.168.9.128&#x2F;27</p>
<p>分析D选项：192.168.9.0&#x2F;26代表00，至少还需要11和01才可完全覆盖，而11和01不可聚合，所以不可能使用3个子网来划分，D错误</p>
<p> 在给主机设置公网 IP 地址时,下面四个选项哪一个能使用 ( A )</p>
<p>A、29.9.255.15		B、192.5.91.255</p>
<p>C、127.21.19.109		D、220.103.256.56 (错误原因：256&gt;255)</p>
<p>一个IP数据报总长度为4200字节(包含固定长度的首部)。现在需要经过某物理网络传送,但是该网络的MTU&#x3D;1000字节。则该数据报被分片后最后一个分片首部中的片偏移字段的值(用十进制表示)是（ B ）</p>
<p>A、500 	B、488</p>
<p>C、125	 D、122</p>
<p>ip数据报数据长度为4200-20&#x3D;4180</p>
<p>新数据报长度为1000-20&#x3D;980，但片偏移以8为单位，故数据报长度要为8的倍数，向下取976</p>
<p>[4280&#x2F;976]&#x3D;5，5个分组</p>
<p>一个分组片偏移为976&#x2F;8&#x3D;122，故4个分组片偏移为488</p>
<p>路由表与转发表的区别：</p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>路由表 (RIB)</strong></th>
<th><strong>转发表 (FIB)</strong></th>
<th><strong>邻接表 (Adjacency Table)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心作用</strong></td>
<td>存储<strong>所有已知路由</strong></td>
<td>存储<strong>路由的最优路径</strong></td>
<td>存储<strong>下一跳与MAC的映射关系</strong></td>
</tr>
<tr>
<td><strong>工作层面</strong></td>
<td>控制层面（软件决策）</td>
<td>转发层面（硬件执行）</td>
<td>数据链路层（L2封装）</td>
</tr>
<tr>
<td><strong>核心内容</strong></td>
<td>目标网络+掩码、下一跳IP、管理距离、度量值、路由来源</td>
<td>目标网络+掩码、<strong>出接口</strong>、下一跳IP、<strong>邻接表指针</strong></td>
<td><strong>下一跳IP</strong>、<strong>出接口</strong>、<strong>目标MAC地址</strong></td>
</tr>
<tr>
<td><strong>生成方式</strong></td>
<td>路由协议、静态配置、直连网络</td>
<td>从路由表<strong>提取最优路径</strong>优化生成</td>
<td>ARP（IPv4）、手动配置</td>
</tr>
<tr>
<td><strong>更新频率</strong></td>
<td>较高（路由变化时更新）</td>
<td>较低（路由表最优路径变化时）</td>
<td>最低（ARP缓存超时——20min、链路状态变化）</td>
</tr>
<tr>
<td><strong>性能要求</strong></td>
<td>中（CPU处理）</td>
<td><strong>极高</strong>（硬件TCAM&#x2F;ASIC线速查找）</td>
<td>高（需与FIB协同快速封装）</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>控制处理器内存</td>
<td>专用硬件（TCAM&#x2F;ASIC）</td>
<td>硬件或高速内存</td>
</tr>
<tr>
<td><strong>关键决策</strong></td>
<td><strong>“数据包应该去哪？”</strong>（选择路径）</td>
<td><strong>“从哪个接口发出？”</strong>（执行转发）</td>
<td><strong>“如何封装数据帧？”</strong>（解决L2寻址）</td>
</tr>
<tr>
<td><strong>类比</strong></td>
<td>世界地图（含所有路线）</td>
<td>导航路线（最优路径指引）</td>
<td>本地通讯录（下一跳联系方式）</td>
</tr>
</tbody></table>
<p>路由算法创建路由表-&gt;路由表中挑出到各网络最优的路径组成转发表</p>
<p>分组到达-&gt;根据转发表找下一跳和接口-&gt;邻接表将下一条IP转换为MAC地址-&gt;发包</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>RIP</strong></th>
<th><strong>OSPF</strong></th>
<th><strong>BGP</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>算法</strong></td>
<td><strong>距离向量</strong></td>
<td><strong>链路状态</strong></td>
<td><strong>路径向量</strong></td>
</tr>
<tr>
<td><strong>协议类型</strong></td>
<td>IGP（内部网关协议）</td>
<td>IGP（内部网关协议）</td>
<td>EGP（外部网关协议）</td>
</tr>
<tr>
<td><strong>协议层级</strong></td>
<td><strong>应用层（UDP 520 端口）</strong></td>
<td><strong>网络层（IP 协议号 89）</strong></td>
<td><strong>应用层（TCP 179 端口）</strong></td>
</tr>
<tr>
<td><strong>设计目标</strong></td>
<td>小型网络简单路由</td>
<td>大型网络快速收敛与分层设计</td>
<td>跨自治系统（AS）的策略路由</td>
</tr>
<tr>
<td><strong>度量标准</strong></td>
<td>跳数，最大 15 跳</td>
<td>链路开销</td>
<td>AS 路径长度、政治等属性</td>
</tr>
<tr>
<td><strong>更新机制</strong></td>
<td>每 30 秒向邻居发送完整路由表</td>
<td>触发更新（拓扑变化时洪泛 LSA）</td>
<td>触发更新 + 增量更新</td>
</tr>
<tr>
<td><strong>收敛速度</strong></td>
<td>慢（分钟级）</td>
<td>快（秒级）</td>
<td>极慢（分钟到小时级）</td>
</tr>
<tr>
<td><strong>防环机制</strong></td>
<td>跳数限制</td>
<td>SPF 算法（基于拓扑的无环计算）</td>
<td>AS_PATH 属性（丢弃含自身 AS 的路由）</td>
</tr>
<tr>
<td><strong>网络规模支持</strong></td>
<td>极小（≤15 跳）</td>
<td>大（通过区域划分扩展）</td>
<td>极大（互联网级路由表）</td>
</tr>
<tr>
<td><strong>配置复杂度</strong></td>
<td>简单（无需拓扑规划）</td>
<td>复杂（需设计区域、DR&#x2F;BDR）</td>
<td>极复杂（策略定制、邻居管理）</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>小型企业分支、临时网络</td>
<td>企业内网、数据中心内部</td>
<td>ISP 互联、跨国企业跨 AS 路由</td>
</tr>
</tbody></table>
<p>OSPF中路由器获得的路由信息是：本区域完整拓扑图 + 其他区域路由摘要，由于OSPF使用组播地址，故其洪泛只在区域内。</p>
<p>35.(单选题)OSPF协议可以有效的解决路由自环的问题,下面哪一条无法解释这一点()<br>A、OSPF支持路由验证         		 B、OSPF使用链路状态路由算法<br>C、OSPF使用了骨干区域	  		D、当其他区域无法和骨干区域物理直连是，OSPF可以使用虚连接</p>
<p>A：路由验证是通过密码或密钥验证路由更新的来源，防止恶意路由，与防环无关</p>
<p>B：每个路由器维护整个网络的链路状态数据库，并独立计算最短路径树，确保路径无环</p>
<p>C：所有其他区域必须直接或间接连接到骨干区域。分层结构避免区域边界路由器间形成环路</p>
<p>D：与C相同，分层结构避免区域边界路由器间形成环路</p>
<hr>
<h1 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h1><hr>
<h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h1><hr>
<h1 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h1><p>DHCP中继代理（让路由器将外部广播包转发到服务器）：ip helper-address +服务器ip</p>
<p>DNS实验中：</p>
<ul>
<li>域名	A-record	ip</li>
<li>域名	NS-record	权威域名服务器</li>
<li>别名	C-NAME	原域名</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>调用.exe爆破</title>
    <url>/posts/64193/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h3 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h3><p>CISCN的一个题包含一个.exe文件（加密）和一个文本文件（存放密文），由于.exe文件逻辑比较复杂，如果直接进行逆向来推出flag的话，比较难，于是可以用python的subprocess模块来调用.exe文件进行逐个字符爆破。</p>
<p>.exe文件主要作用：每次读取一个字符串，进行加密，加密后会与文本文件的密文相等</p>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>使用<code>subprocess.run()</code> 调用<code>.exe</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = subprocess.run([&#x27;A&#x27;, &#x27;B&#x27;], capture_output=True, text=True)</span><br><span class="line">A: 文件地址</span><br><span class="line">B: 需要传入函数的参数</span><br><span class="line">capture_output=True: 捕获输出</span><br><span class="line">text=True: 确保输出以字符串形式而不是字节形式返回</span><br><span class="line">返回值: CompletedProcess实例</span><br></pre></td></tr></table></figure>

<p><code>CompletedProcess</code> 实例有以下几个属性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">args: 传递给 run() 的参数（通常是命令和参数列表），以供参考。</span><br><span class="line">returncode: 子进程退出时的状态码。通常，成功执行的命令会返回 0，而非零值表示发生了错误。</span><br><span class="line">stdout: 如果指定了 capture_output=True 或 stdout=PIPE，则包含标准输出的数据；否则为 None。</span><br><span class="line">text: 如果 text=True，那么 stdout 将是字符串；否则，它将是字节对象。</span><br><span class="line">stderr: 类似于 stdout，但是包含了标准错误流的数据。</span><br></pre></td></tr></table></figure>

<p>其中stdout包含了输出流，可以使用result.stdout获取输出流</p>
<p>脚本示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import string</span><br><span class="line">table = string.printable   # 可打印字符表</span><br><span class="line">data = [&quot;23&quot;, &quot;29&quot;, &quot;1e&quot;, &quot;24&quot;, &quot;38&quot;,</span><br><span class="line">       &quot;0e&quot;, &quot;15&quot;, &quot;20&quot;, &quot;37&quot;, &quot;0e&quot;,</span><br><span class="line">       &quot;05&quot;, &quot;20&quot;, &quot;00&quot;, &quot;0e&quot;, &quot;37&quot;,</span><br><span class="line">       &quot;12&quot;, &quot;1d&quot;, &quot;0f&quot;, &quot;24&quot;, &quot;01&quot;, &quot;01&quot;, &quot;39&quot;]   # 密文</span><br><span class="line"></span><br><span class="line">flag = &#x27;flag&#123;&#x27;    # 已知的前缀</span><br><span class="line">index = 5</span><br><span class="line">while index&lt;len(data):</span><br><span class="line">    if index == 14:     # 这是提示给的</span><br><span class="line">        flag += &#x27;4&#x27;</span><br><span class="line">        index += 1</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">    for char in table:</span><br><span class="line">        temp = flag + char</span><br><span class="line">        result = subprocess.run([&quot;C:/Users/tzs/Desktop/bin/re.exe&quot;,temp],capture_output=True, text=True)</span><br><span class="line">        out_put = result.stdout   # 这里得到一个十六进制字符串</span><br><span class="line">        out_list = [out_put[i:i+2] for i in range(0,len(out_put),2)]         # 把每两个字符拆成一个十六进制数</span><br><span class="line">        if out_list[index] == data[index]: </span><br><span class="line">            flag += char</span><br><span class="line">            index += 1</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>重定位表</title>
    <url>/posts/42580/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>​	在optional头里面有ImageBase，一般而言，模块在装入内存中时会优先装入该地址。一般exe文件中这个成员的值为0x00400000，而dll中这个成员的值一般为0x10000000（选择大地址是为了尽量不与exe冲突）。但是，很多情况下一个exe文件会调用许多个dll文件，这些dll文件的ImageBase值是相同的，因此，其他未抢到该地址的模块实际上装入的地址并不是ImageBase。</p>
<p>​	在模块中部分指令中可能会出现一些地址，由于编译时模块并未装入内存中，不知道实际基址是什么，因此编译器会使用ImageBase当作基址，计算出绝对地址。一旦模块实际装入地址不是ImageBase，那么这些绝对地址都会出现错误，所以需要在模块装入时对模块中的绝对地址进行修正，重定位表就列出了模块哪些位置有需要修正的绝对地址。</p>
<p>​	由于exe一般是第一个装入内存的模块，具有优先选择权，一般都会装入到ImageBase处，所以不需要重定位表，而dll作为被调用方常常需要重定位表。</p>
<p>注：重定位表中记载的是包含绝对地址的指令的位置，是RVA，而不是实际绝对地址。当载入模块时，加载器会读取重定位表中的地址，取出该地址开始的4个字节组成一个绝对地址，计算该绝对地址地址与ImageBase相减得到RVA，再将RVA与真正的基址相加得到真正的VA，替换原绝对地址。</p>
<h2 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h2><p>​	在IMAGE_OPTIONAL_HEADER的成员DataDirectory[]的第6个结构体中，记载重定位表的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct IMAGE_DATA_DIRECTORY&#123;</span><br><span class="line">  DWORD  VirtualAddress; RVA，重定位表的位置</span><br><span class="line">  DWORD  Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>​	重定位表由多个IMAGE_BASE_RELOCATION 结构+数据组成，由一个全为零的IMAGE_BASE_RELOCATION 结构体结束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_BASE_RELOCATION &#123;</span><br><span class="line"> </span><br><span class="line">  DWORD  VirtualAddress; //记录内存页的基址RVA </span><br><span class="line">  DWORD  SizeOfBlock;  //当前重定位块结构的大小。这个值减8就是TypeOffset数组的大小</span><br><span class="line"> </span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line">typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<p>如下图：</p>
.png)

<p>​	这样的结构使重定位表占据的空间大幅缩小。例如若要修改的地址的RVA为1034、1045、1056、1077，如果每一个地址都单独存储，一个地址占4个字节，那么需要占据16个字节的空间，而如果把1000作为一页，将同一页的数据存储在一起，再记录下这一页的起始地址，那么每一个地址就不再需要4字节。一个页大小为0x1000即为2的12次方，故只需要12比特就能完成对该页的寻址，为了对齐，需要补4个比特，因此一个地址占据2个字节。所以，重定位表中一个块里IMAGE_BASE_RELOCATION中的VirtualAddress表示此块的基址，SizeOfBlock指示此块的总大小，后面跟着的数据每两个字节为一组，后12位表示偏移。由于对齐，一个块的长度限制为4的倍数，于是当一个块存储奇数个地址时，需要补2个字节的0，为了与实际需要修改的地址作区分，启用未使用的前4位为属性，若值为3（即0011），则代表是需要修改的地址；若值为0，即是填充的数据。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="一、打印重定位表中所有信息"><a href="#一、打印重定位表中所有信息" class="headerlink" title="一、打印重定位表中所有信息"></a>一、打印重定位表中所有信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">int num=0;           //节数量</span><br><span class="line">int header_size=0;   // PE头大小</span><br><span class="line">int base=0;          // 基址</span><br><span class="line">int fsize=0,image_size=0; // 文件大小；文件映射的内存大小</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">	DWORD foa=0;</span><br><span class="line">    if(rva&lt;=header_size) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rva&lt;sheader[0].VirtualAddress) &#123;</span><br><span class="line">        printf(&quot;没有对应的foa!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &gt;= num) &#123;</span><br><span class="line">        printf(&quot;RVA超出范围!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">	return foa;</span><br><span class="line">&#125;</span><br><span class="line">void print_relocation(unsigned char *location)&#123;  // 关键函数，打印重定位表所有内容</span><br><span class="line">    IMAGE_BASE_RELOCATION* relocation=(IMAGE_BASE_RELOCATION*)location;</span><br><span class="line">    if(relocation-&gt;SizeOfBlock==0) return;</span><br><span class="line">    DWORD base = relocation-&gt;VirtualAddress;</span><br><span class="line">    DWORD rva = 0,foa = 0;</span><br><span class="line">    WORD* address = (WORD*)(location+8);</span><br><span class="line">    int num = (relocation-&gt;SizeOfBlock-8)/2;</span><br><span class="line">    int i=0,Characteristics=0;</span><br><span class="line">    printf(&quot;重定位表VirtualAddress:%#010x     size:%#010x\n&quot;,base,relocation-&gt;SizeOfBlock);</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        Characteristics = (int)(address[i]&gt;&gt;12);</span><br><span class="line">        rva = base + (address[i]&amp;0x0fff);</span><br><span class="line">        printf(&quot;RVA:%#010x    FOA:%#010x    Characteristics:%d\n&quot;,rva,RVA_to_FOA(rva),Characteristics);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n\n&quot;);</span><br><span class="line">    print_relocation(location+relocation-&gt;SizeOfBlock);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // if(argc != 2) &#123;</span><br><span class="line">    //     printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">    //     return 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    const char* pe_path = &quot;dlltest.dll&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize);</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *offset=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)offset;</span><br><span class="line">    offset+=dos-&gt;e_lfanew+4;  // 定位文件头</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)offset;</span><br><span class="line">    num = fheader-&gt;NumberOfSections;</span><br><span class="line">    offset+=20;      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)offset;</span><br><span class="line">    header_size=oheader-&gt;SizeOfHeaders;</span><br><span class="line">    base=oheader-&gt;ImageBase;</span><br><span class="line">    image_size = oheader-&gt;SizeOfImage;</span><br><span class="line">    offset += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    int size = num * sizeof(IMAGE_SECTION_HEADER);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)offset;</span><br><span class="line">	DWORD redelocation_rva = oheader-&gt;DataDirectory[5].VirtualAddress;</span><br><span class="line">	DWORD relocation_foa = RVA_to_FOA(redelocation_rva);</span><br><span class="line">	if(relocation_foa == 0) &#123;</span><br><span class="line">		printf(&quot;重定位表RVA转换失败\n&quot;);</span><br><span class="line">		free(file_buf);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	print_relocation(file_buf + relocation_foa);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、模拟重定位过程"><a href="#二、模拟重定位过程" class="headerlink" title="二、模拟重定位过程"></a>二、模拟重定位过程</h2><p>目标：将Imagebase改为20000000，然后进行重定位，修改后的dll要能够使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#define newbase 0x20000000</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">int num=0;           //节数量</span><br><span class="line">int header_size=0;   // PE头大小</span><br><span class="line">int base=0;          // 基址</span><br><span class="line">int fsize=0,image_size=0; // 文件大小；文件映射的内存大小</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">	DWORD foa=0;</span><br><span class="line">    if(rva&lt;=header_size) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rva&lt;sheader[0].VirtualAddress) &#123;</span><br><span class="line">        printf(&quot;没有对应的foa!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i &gt;= num) &#123;</span><br><span class="line">        printf(&quot;RVA超出范围!!!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">	return foa;</span><br><span class="line">&#125;</span><br><span class="line">void relocate(unsigned char *location,unsigned char *file_buf)&#123;</span><br><span class="line">    IMAGE_BASE_RELOCATION* relocation=(IMAGE_BASE_RELOCATION*)location;</span><br><span class="line">    if(relocation-&gt;SizeOfBlock==0) return;</span><br><span class="line">    DWORD base = relocation-&gt;VirtualAddress;</span><br><span class="line">    DWORD rva = 0,foa = 0;</span><br><span class="line">    WORD* address = (WORD*)(location+8);</span><br><span class="line">    int num = (relocation-&gt;SizeOfBlock-8)/2;</span><br><span class="line">    int i=0,Characteristics=0;</span><br><span class="line">    DWORD data=0;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        Characteristics = (int)(address[i]&gt;&gt;12);</span><br><span class="line">        if(Characteristics == 3)&#123;</span><br><span class="line">            rva = base + (address[i]&amp;0x0fff);</span><br><span class="line">            foa = RVA_to_FOA(rva);</span><br><span class="line">            data = *(DWORD*)(file_buf+foa);</span><br><span class="line">            data = data - oheader-&gt;ImageBase + newbase;</span><br><span class="line">            *(DWORD*)(file_buf+foa) = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    relocate(location+relocation-&gt;SizeOfBlock,file_buf);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // if(argc != 2) &#123;</span><br><span class="line">    //     printf(&quot;用法: %s &lt;PE文件路径&gt;\n&quot;, argv[0]);</span><br><span class="line">    //     return 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    const char* pe_path = &quot;dlltest.dll&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize);</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *offset=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)offset;</span><br><span class="line">    offset+=dos-&gt;e_lfanew+4;  // 定位文件头</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)offset;</span><br><span class="line">    num = fheader-&gt;NumberOfSections;</span><br><span class="line">    offset+=20;      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)offset;</span><br><span class="line">    header_size=oheader-&gt;SizeOfHeaders;</span><br><span class="line">    base=oheader-&gt;ImageBase;</span><br><span class="line">    image_size = oheader-&gt;SizeOfImage;</span><br><span class="line">    offset += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    int size = num * sizeof(IMAGE_SECTION_HEADER);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)offset;</span><br><span class="line">	DWORD redelocation_rva = oheader-&gt;DataDirectory[5].VirtualAddress;</span><br><span class="line">	DWORD relocation_foa = RVA_to_FOA(redelocation_rva);</span><br><span class="line">	if(relocation_foa == 0) &#123;</span><br><span class="line">		printf(&quot;重定位表RVA转换失败\n&quot;);</span><br><span class="line">		free(file_buf);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	relocate(file_buf + relocation_foa,file_buf);</span><br><span class="line">    oheader-&gt;ImageBase = newbase;</span><br><span class="line">    FILE *new_file = fopen(&quot;new.dll&quot;,&quot;wb&quot;);</span><br><span class="line">    if (!new_file) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int written=fwrite(file_buf,sizeof(unsigned char),fsize,new_file);</span><br><span class="line">    if(written!=fsize)&#123;</span><br><span class="line">        perror(&quot;写入错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(new_file);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
</search>
