<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":"ture","show_result":"ture","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":"ture"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="位卑未敢忘忧国，事定犹须待阖棺">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="位卑未敢忘忧国，事定犹须待阖棺">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="comhacker">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            

	<div class="tag-cloud">
	  <div class="tag-cloud-tags" id="tags">
		<a href="/tags/PE/" style="font-size: 16px; color: #fff">PE</a> <a href="/tags/Reverse/" style="font-size: 16px; color: #fff">Reverse</a> <a href="/tags/Win32/" style="font-size: 16px; color: #fff">Win32</a> <a href="/tags/wp/" style="font-size: 16px; color: #fff">wp</a> <a href="/tags/%E4%BD%9C%E4%B8%9A/" style="font-size: 16px; color: #fff">作业</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 16px; color: #fff">其他</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16px; color: #fff">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16px; color: #fff">数据结构</a> <a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 16px; color: #fff">杂记</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 16px; color: #fff">汇编</a>
	  </div>
	</div>
	<br>
	
	<script type="text/javascript">
     var alltags = document.getElementsByClassName('tag-cloud-tags');
     var tags = alltags[0].getElementsByTagName('a');
     for (var i = tags.length - 1; i >= 0; i--) {
       var r=Math.floor(Math.random()*75+130);
       var g=Math.floor(Math.random()*75+100);
       var b=Math.floor(Math.random()*75+80);
       tags[i].style.background = "rgb("+r+","+g+","+b+")";
     }
</script>

<style>
  .tag-cloud-tags{
    /*font-family: Helvetica, Tahoma, Arial;*/
    /*font-weight: 100;*/
    text-align: center;
    counter-reset: tags;
  }
  .tag-cloud-tags a{
    border-radius: 6px;
    padding-right: 5px;
    padding-left: 5px;
    margin: 8px 5px 0px 0px;
  }
  .tag-cloud-tags a:before{
    content: "";
  }

  .tag-cloud-tags a:hover{
     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);
     transform: scale(1.1);
     /*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/
     transition-duration: 0.15s;
  }
</style>

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/49201/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/49201/" class="post-title-link" itemprop="url">通用控件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-27 20:52:34" itemprop="dateCreated datePublished" datetime="2025-07-27T20:52:34+08:00">2025-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-28 20:42:26" itemprop="dateModified" datetime="2025-07-28T20:42:26+08:00">2025-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="一、搭建对话框"><a href="#一、搭建对话框" class="headerlink" title="一、搭建对话框"></a>一、搭建对话框</h1><p>使用DiaLog搭建如图所示的对话框</p>


<h1 id="二、标准控件与通用控件"><a href="#二、标准控件与通用控件" class="headerlink" title="二、标准控件与通用控件"></a>二、标准控件与通用控件</h1><h2 id="标准控件："><a href="#标准控件：" class="headerlink" title="标准控件："></a>标准控件：</h2><p>是 Windows 最早版本（Windows 1.x, 2.x, 3.x）提供的基础控件。</p>
<p>常见以下类型：</p>
<ul>
<li><code>BUTTON</code>：按钮（包括普通按钮、复选框、单选按钮、分组框）</li>
<li><code>STATIC</code>：静态文本、图标、矩形框、分隔线</li>
<li><code>EDIT</code>：单行或多行文本编辑框</li>
<li><code>LISTBOX</code>：列表框</li>
<li><code>COMBOBOX</code>：组合框（下拉列表框）</li>
<li><code>SCROLLBAR</code>：滚动条（也常用于窗口本身）</li>
</ul>
<p>它们提供核心的交互功能（点击、选择、输入文本、简单列表），<strong>在应用程序启动时即可直接使用</strong>，主要通过父窗口接收 <code>WM_COMMAND</code> 通知消息（对于按钮、编辑框、列表框、组合框）。</p>
<h2 id="通用控件："><a href="#通用控件：" class="headerlink" title="通用控件："></a>通用控件：</h2><p>随着 Windows 95 和 Windows NT 4.0 引入，微软提供了更现代、更丰富的控件，通用控件是对标准控件库的扩展。他们由 <code>ComCtl32.dll</code> 实现和管理。在创建前必须<strong>先初始化</strong>通用控件库！必须调用 <code>InitCommonControlsEx</code> 函数注册控件窗口类才能使用。 </p>
<p>InitCommonControlsEx函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL InitCommonControlsEx(</span><br><span class="line">  [in] const INITCOMMONCONTROLSEX *picce</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中，INITCOMMONCONTROLSEX结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagINITCOMMONCONTROLSEX &#123;</span><br><span class="line">  DWORD dwSize;		// 结构体大小</span><br><span class="line">  DWORD dwICC;		// 将从 DLL 加载哪些公共控件类的位标志集。</span><br><span class="line">&#125; INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;</span><br></pre></td></tr></table></figure>

<p>dwICC常用的是ICC_WIN95_CLASSES（加载动画控件、标头、热键、列表视图、进度栏、状态栏、选项卡、工具提示、工具栏、跟踪条、树视图和向上-向下控件类）。</p>
<p>初始化流程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 包含头文件和静态库</span><br><span class="line">#include &lt;commctrl.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;comctl32.lib&quot;)</span><br><span class="line"></span><br><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">    _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">    _In_ LPWSTR    lpCmdLine,</span><br><span class="line">    _In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">	// 初始化</span><br><span class="line">    INITCOMMONCONTROLSEX icex;</span><br><span class="line">    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);</span><br><span class="line">    icex.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line">    InitCommonControlsEx(&amp;icex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：现在VS2022貌似不需要初始化也能直接运行</p>
<h3 id="WM-NOTIFY消息："><a href="#WM-NOTIFY消息：" class="headerlink" title="WM_NOTIFY消息："></a>WM_NOTIFY消息：</h3><p>通用控件主要通过父窗口接收 <code>WM_NOTIFY</code> 消息。此消息有两个参数：</p>
<h4 id="wParam"><a href="#wParam" class="headerlink" title="wParam:"></a>wParam:</h4><p>控件标识符（ID）</p>
<h4 id="lParam："><a href="#lParam：" class="headerlink" title="lParam："></a>lParam：</h4><p>一个指向通知信息结构体的指针。</p>
<p>这个结构体（基础版）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagNMHDR &#123;</span><br><span class="line">    HWND hwndFrom;    // 发送通知的控件句柄</span><br><span class="line">    UINT_PTR idFrom;   // 控件ID（与 wParam 相同）</span><br><span class="line">    UINT code;         // 通知码（如 LVN_ITEMCHANGED）</span><br><span class="line">&#125; NMHDR;</span><br></pre></td></tr></table></figure>

<p>常见通知码：</p>
<table>
<thead>
<tr>
<th align="center">通知码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>NM_CLICK</strong></td>
<td align="center">鼠标单击控件</td>
</tr>
<tr>
<td align="center"><strong>NM_DBLCLK</strong></td>
<td align="center">鼠标双击控件</td>
</tr>
<tr>
<td align="center"><strong>NM_RCLICK</strong></td>
<td align="center">鼠标右键单击</td>
</tr>
<tr>
<td align="center"><strong>NM_RDBLCLK</strong></td>
<td align="center">鼠标右键双击</td>
</tr>
</tbody></table>
<p>如果基础版不足以表示信息，可以使用扩充版结构体（有很多种，下面只是其中一种）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 列表视图项变更通知</span><br><span class="line">typedef struct tagNMLISTVIEW &#123;</span><br><span class="line">    NMHDR hdr;          // 基础头(就是上面那个结构体)</span><br><span class="line">    int iItem;          // 项索引</span><br><span class="line">    int iSubItem;       // 子项索引</span><br><span class="line">    UINT uNewState;     // 新状态</span><br><span class="line">    UINT uOldState;     // 旧状态</span><br><span class="line">    UINT uChanged;      // 变化标志</span><br><span class="line">    POINT ptAction;     // 事件位置</span><br><span class="line">    LPARAM lParam;      // 自定义数据</span><br><span class="line">&#125; NMLISTVIEW;</span><br></pre></td></tr></table></figure>

<h1 id="三、完善对话框"><a href="#三、完善对话框" class="headerlink" title="三、完善对话框"></a>三、完善对话框</h1><h2 id="列表划分列："><a href="#列表划分列：" class="headerlink" title="列表划分列："></a>列表划分列：</h2><p>目标：向列表里面添加4个列</p>
<p>完成效果(如图红框)：</p>


<h3 id="关键数据结构："><a href="#关键数据结构：" class="headerlink" title="关键数据结构："></a>关键数据结构：</h3><h4 id="GetDlgItem函数："><a href="#GetDlgItem函数：" class="headerlink" title="GetDlgItem函数："></a>GetDlgItem函数：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWND GetDlgItem(</span><br><span class="line">  [in, optional] HWND hDlg,			// Dialog对话框句柄</span><br><span class="line">  [in]           int  nIDDlgItem	// 控件标识符（ID）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：返回对话框子控件的句柄</p>
<h4 id="SendMessage函数："><a href="#SendMessage函数：" class="headerlink" title="SendMessage函数："></a>SendMessage函数：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRESULT SendMessage(</span><br><span class="line">  [in] HWND   hWnd,			// 窗口的句柄</span><br><span class="line">  [in] UINT   Msg,			// 要发送的消息</span><br><span class="line">  [in] WPARAM wParam,		// 附加信息</span><br><span class="line">  [in] LPARAM lParam		// 附加信息</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="LVM-SETEXTENDEDLISTVIEWSTYLE消息："><a href="#LVM-SETEXTENDEDLISTVIEWSTYLE消息：" class="headerlink" title="LVM_SETEXTENDEDLISTVIEWSTYLE消息："></a>LVM_SETEXTENDEDLISTVIEWSTYLE消息：</h4><p>是一个专门用于设置列表视图控件扩展样式的消息。它的两个参数：</p>
<ul>
<li><p>wParam：指定要影响 lParam中的样式。若参数为零， 则 lParam 中的所有样式都将受到影响。</p>
</li>
<li><p>lParam：指定要设置的扩展列表视图控件样式。</p>
</li>
</ul>
<p>这两个参数都使用 ListView扩展样式。这里使用的是LVS_EX_FULLROWSELECT：这是一个扩展样式标志，用于启用整行选择功能。当启用时，用户点击行的任意位置（任何列）都将高亮显示整行。如果不设置，那么只有第一列（通常只有标签列）可以触发选中，其他列不会高亮整行。</p>
<h4 id="LVM-INSERTCOLUMN消息："><a href="#LVM-INSERTCOLUMN消息：" class="headerlink" title="LVM_INSERTCOLUMN消息："></a>LVM_INSERTCOLUMN消息：</h4><p>用于在列表视图控件中插入新列。 </p>
<ul>
<li><em>wParam</em>：新列的索引</li>
<li><em>lParam</em>：指向包含新列属性的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/commctrl/ns-commctrl-lvcolumna"><strong>LVCOLUMN</strong></a> 结构的指针。</li>
</ul>
<h4 id="LV-COLUMN结构体-："><a href="#LV-COLUMN结构体-：" class="headerlink" title="LV_COLUMN结构体 ："></a>LV_COLUMN结构体 ：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagLVCOLUMNA &#123;</span><br><span class="line">  UINT  mask;	// 指定哪些成员包含有效信息的变量</span><br><span class="line">  int   fmt;	// 列标题和列中子项文本的对齐方式。</span><br><span class="line">  int   cx;		// 列的宽度</span><br><span class="line">  LPSTR pszText;	// 接收或设置标题文本的缓冲区</span><br><span class="line">  int   cchTextMax;		// 缓冲区的大小</span><br><span class="line">  int   iSubItem;	// 与列关联的子项的索引（第一列索引为0，第二列索引为1、、、、）</span><br><span class="line">  int   iImage;		// 图像列表中图像的从零开始的索引</span><br><span class="line">  int   iOrder;		// 从零开始的列偏移量</span><br><span class="line">  int   cxMin;		//  列的最小宽度</span><br><span class="line">  int   cxDefault;	// 应用程序定义的值通常用于存储列的默认宽度</span><br><span class="line">  int   cxIdeal;	//  列的理想宽度</span><br><span class="line">&#125; LVCOLUMNA, *LPLVCOLUMNA;</span><br></pre></td></tr></table></figure>

<p>mask常用取值：</p>
<table>
<thead>
<tr>
<th><strong>LVCF_FMT</strong></th>
<th><strong>fmt</strong> 成员有效。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LVCF_WIDTH</strong></td>
<td><strong>cx</strong> 成员有效。</td>
</tr>
<tr>
<td><strong>LVCF_TEXT</strong></td>
<td><strong>pszText</strong> 成员有效。</td>
</tr>
<tr>
<td><strong>LVCF_SUBITEM</strong></td>
<td><strong>iSubItem</strong> 成员有效。</td>
</tr>
</tbody></table>
<p>fmt常用值：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>LVCFMT_LEFT</strong></td>
<td align="left">文本左对齐。</td>
</tr>
<tr>
<td align="left"><strong>LVCFMT_RIGHT</strong></td>
<td align="left">文本右对齐。</td>
</tr>
<tr>
<td align="left"><strong>LVCFMT_CENTER</strong></td>
<td align="left">文本居中。</td>
</tr>
</tbody></table>
<h4 id="ListView-InsertColumn宏"><a href="#ListView-InsertColumn宏" class="headerlink" title="ListView_InsertColumn宏"></a><em>ListView_InsertColumn</em>宏</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ListView_InsertColumn(</span><br><span class="line">         HWND       hwnd,		// 列表视图控件的句柄。</span><br><span class="line">         int        iCol,		// 新列的索引</span><br><span class="line">   const LPLVCOLUMN pcol		// 指向包含新列属性的 LVCOLUMN 结构的指针。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：在列表视图控件中插入新列。 可以使用此宏或显式发送 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Controls/lvm-insertcolumn">LVM_INSERTCOLUMN</a> 消息。效果与使用SendMessage发送LVM_INSERTCOLUMN消息相同。</p>
<p>返回值：如果成功，则返回新列的索引，否则返回 -1</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void InitProcessList(HWND hwndDlg)&#123;</span><br><span class="line">    // 获取句柄</span><br><span class="line">    HWND HwndList=NULL;</span><br><span class="line">    HwndList = GetDlgItem(hwndDlg,IDC_LIST_PROCESS );</span><br><span class="line"></span><br><span class="line">    // 设置整行选中</span><br><span class="line">    SendMessage(HwndList, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);</span><br><span class="line"></span><br><span class="line">    // 获取控件总宽度</span><br><span class="line">    RECT rc;</span><br><span class="line">    GetClientRect(HwndList, &amp;rc);</span><br><span class="line">    int listWidth = rc.right - rc.left;</span><br><span class="line"></span><br><span class="line">    LV_COLUMN lv;</span><br><span class="line">    memset(&amp;lv, 0,sizeof(LV_COLUMN));</span><br><span class="line">    // 设置第一列</span><br><span class="line">    TCHAR Name[20] = TEXT(&quot;进程名&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM ;</span><br><span class="line">    lv.pszText = Name;				//  列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;         // 标题中间对齐</span><br><span class="line">    lv.cx = 200;								//列宽</span><br><span class="line">    lv.iSubItem = 0;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 0, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 0, &amp;lv);</span><br><span class="line"></span><br><span class="line">    // 设置第二列</span><br><span class="line">    TCHAR Name2[] = TEXT(&quot;PID&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM;</span><br><span class="line">    lv.pszText = Name2;				//列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;</span><br><span class="line">    lv.cx = 100;								//列宽</span><br><span class="line">    lv.iSubItem = 1;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 1, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 1, &amp;lv);</span><br><span class="line"></span><br><span class="line">    // 设置第三列</span><br><span class="line">    TCHAR Name3[] = TEXT(&quot;镜像基址&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM;</span><br><span class="line">    lv.pszText = Name3;				//列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;</span><br><span class="line">    lv.cx = 100;								//列宽</span><br><span class="line">    lv.iSubItem = 2;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 2, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 2, &amp;lv);</span><br><span class="line"></span><br><span class="line">    // 设置第四列</span><br><span class="line">    TCHAR Name4[] = TEXT(&quot;镜像大小&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM;</span><br><span class="line">    lv.pszText = Name4;				//列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;</span><br><span class="line">    lv.cx = listWidth - 200 - 100*2;	// 这里列宽取剩余大小是为了防止有剩余导致多出一个空列</span><br><span class="line">    lv.iSubItem = 3;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 3, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 3, &amp;lv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列表添加信息"><a href="#列表添加信息" class="headerlink" title="列表添加信息"></a>列表添加信息</h2><p>目标：向列表里面添加两行</p>
<p>完成效果：</p>


<h3 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构:"></a>关键数据结构:</h3><h4 id="LV-ITEM结构体："><a href="#LV-ITEM结构体：" class="headerlink" title="LV_ITEM结构体："></a>LV_ITEM结构体：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagLVITEMA &#123;</span><br><span class="line">  UINT   mask;			// 指定以下哪些属性有效（iItem和iSubItem无需设置，默认有效）</span><br><span class="line">  int    iItem;			// 此结构引用的项的从零开始的索引。（人话：行索引）</span><br><span class="line">  int    iSubItem;		// 此结构引用的子项的基于一个索引，如果此结构引用项而不是子项，则为零。（人话：列索引）</span><br><span class="line">  UINT   state;</span><br><span class="line">  UINT   stateMask;</span><br><span class="line">  LPSTR  pszText;		// 指向或接受包含项文本的字符串的指针。（人话：要填入的内容）</span><br><span class="line">  int    cchTextMax;	// 缓冲区大小</span><br><span class="line">  int    iImage;</span><br><span class="line">  LPARAM lParam;</span><br><span class="line">  int    iIndent;</span><br><span class="line">  int    iGroupId;</span><br><span class="line">  UINT   cColumns;</span><br><span class="line">  PUINT  puColumns;</span><br><span class="line">  int    *piColFmt;</span><br><span class="line">  int    iGroup;</span><br><span class="line">&#125; LVITEMA, *LPLVITEMA;</span><br></pre></td></tr></table></figure>

<p>作用：声明要添加的信息的各个属性。</p>
<h4 id="ListView-InsertItem宏："><a href="#ListView-InsertItem宏：" class="headerlink" title="ListView_InsertItem宏："></a>ListView_InsertItem宏：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ListView_InsertItem(</span><br><span class="line">         HWND     hwnd,			// 列表句柄</span><br><span class="line">   const LPLVITEM pitem			// 指向 LVITEM 结构的指针，该结构指定列表视图项的属性</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：发送发送 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Controls/lvm-insertitem">LVM_INSERTITEM</a> 消息，使列表添加新项（行）。</p>
<h4 id="LVM-INSERTITEM消息："><a href="#LVM-INSERTITEM消息：" class="headerlink" title="LVM_INSERTITEM消息："></a>LVM_INSERTITEM消息：</h4><p>作用：在列表视图控件中插入新项（省流：开辟一个新项（行））。</p>
<ul>
<li><em>wParam</em>：必须为零。</li>
<li><em>lParam</em>：指向 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/commctrl/ns-commctrl-lvitema"><strong>LVITEM</strong></a> 结构的指针，该结构指定列表视图项的属性。</li>
</ul>
<h4 id="ListView-SetItem宏："><a href="#ListView-SetItem宏：" class="headerlink" title="ListView_SetItem宏："></a>ListView_SetItem宏：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL ListView_SetItem(</span><br><span class="line">         HWND     hwnd,			// 列表句柄</span><br><span class="line">   const LPLVITEM pitem			// 指向LV_ITEM结构的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：发送 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Controls/lvm-setitem">LVM_SETITEM</a> 消息来让列表添加信息。</p>
<h4 id="LVM-SETITEM消息："><a href="#LVM-SETITEM消息：" class="headerlink" title="LVM_SETITEM消息："></a>LVM_SETITEM消息：</h4><p>作用：设置列表视图项的部分或全部属性（省流：给项添加信息）。是在LVM_INSERTITEM发送完毕后，创建完一个项后对此项的补充</p>
<ul>
<li><em>wParam</em>：必须为零。</li>
<li><em>lParam</em>：指向包含新项属性的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/commctrl/ns-commctrl-lvitema"><strong>LVITEM</strong></a> 结构的指针。</li>
</ul>
<h4 id="ListView-SetItemText宏："><a href="#ListView-SetItemText宏：" class="headerlink" title="ListView_SetItemText宏："></a>ListView_SetItemText宏：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VOID ListView_SetItemText(</span><br><span class="line">   HWND    hwndLV,			// 列表视图控件的句柄。</span><br><span class="line">   int     i,				// 列表视图项的从零开始的索引（行索引）</span><br><span class="line">   int     iSubItem_,		// 子项的基于一个索引。（列索引）</span><br><span class="line">   LPCTSTR pszText_			// 指向包含新文本的以 null 结尾的字符串的指针。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：发送 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Controls/lvm-setitemtext">LVM_SETITEMTEXT</a> 消息，更改列表视图项或子项的文本。</p>
<h4 id="LVM-SETITEMTEXT消息："><a href="#LVM-SETITEMTEXT消息：" class="headerlink" title="LVM_SETITEMTEXT消息："></a>LVM_SETITEMTEXT消息：</h4><p>作用：用于更改列表视图项或子项的文本。</p>
<ul>
<li><em>wParam</em>：列表视图项的从零开始的索引。</li>
<li><em>lParam</em>：指向 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/commctrl/ns-commctrl-lvitema"><strong>LVITEM</strong></a> 结构的指针。</li>
</ul>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void InsertInfo(HWND hwndDlg) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取列表句柄</span><br><span class="line">    HWND HwndList = NULL;</span><br><span class="line">    HwndList = GetDlgItem(hwndDlg, IDC_LIST_PROCESS);</span><br><span class="line"></span><br><span class="line">    LV_ITEM lvi;</span><br><span class="line">    memset(&amp;lvi, 0, sizeof(LV_ITEM));</span><br><span class="line"></span><br><span class="line">    // 列表插入第一项</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;test.exe&quot;);</span><br><span class="line">    lvi.iSubItem = 0;</span><br><span class="line">    lvi.mask = LVIF_TEXT;  // 指定pszText有效</span><br><span class="line">    lvi.iItem = 0;</span><br><span class="line">    //ListView_InsertItem(HwndList, &amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_INSERTITEM, 0, (DWORD)&amp; lvi);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 设置第一项第二列的信息</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;100&quot;);</span><br><span class="line">    lvi.iSubItem = 1;</span><br><span class="line">    //ListView_SetItem(HwndList,&amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_SETITEM, 0, (DWORD)&amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置第一项第三列的信息</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;0x77ffee&quot;);</span><br><span class="line">    lvi.iSubItem = 2;</span><br><span class="line">    //ListView_SetItem(HwndList,&amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_SETITEM, 0, (DWORD)&amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置第一项第四列的信息</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;0x100&quot;);</span><br><span class="line">    lvi.iSubItem = 3;</span><br><span class="line">    //ListView_SetItem(HwndList,&amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_SETITEM, 0, (DWORD)&amp;lvi);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 列表插入第二项</span><br><span class="line">    lvi.mask = LVIF_TEXT;  // 指定pszText有效</span><br><span class="line">    lvi.iItem = 1;</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;MyWin32.exe&quot;);</span><br><span class="line">    lvi.iSubItem = 0;</span><br><span class="line">    //ListView_InsertItem(HwndList, &amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_INSERTITEM, 0, (DWORD)&amp;lvi);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 设置第二项第二列的信息</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;101&quot;);</span><br><span class="line">    lvi.iSubItem = 1;</span><br><span class="line">    //ListView_SetItem(HwndList,&amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_SETITEM, 0, (DWORD)&amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置第二项第三列的信息</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;0x77ff00&quot;);</span><br><span class="line">    lvi.iSubItem = 2;</span><br><span class="line">    //ListView_SetItem(HwndList,&amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_SETITEM, 0, (DWORD)&amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置第二项第四列的信息</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;0x200&quot;);</span><br><span class="line">    lvi.iSubItem = 3;</span><br><span class="line">    //ListView_SetItem(HwndList,&amp;lvi);</span><br><span class="line">    SendMessage(HwndList, LVM_SETITEM, 0, (DWORD)&amp;lvi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void InsertInfo(HWND hwndDlg) &#123;</span><br><span class="line">    HWND hList = GetDlgItem(hwndDlg, IDC_LIST_PROCESS);</span><br><span class="line"></span><br><span class="line">    LVITEM lvi = &#123; 0 &#125;;</span><br><span class="line">    lvi.mask = LVIF_TEXT;</span><br><span class="line"></span><br><span class="line">    // 插入第 0 行</span><br><span class="line">    lvi.iItem = 0;</span><br><span class="line">    lvi.iSubItem = 0;</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;test.exe&quot;);</span><br><span class="line">    ListView_InsertItem(hList, &amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置其他列</span><br><span class="line">    ListView_SetItemText(hList, 0, 1, (LPWSTR)TEXT(&quot;100&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 0, 2, (LPWSTR)TEXT(&quot;0x77ffee&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 0, 3, (LPWSTR)TEXT(&quot;0x100&quot;));</span><br><span class="line"></span><br><span class="line">    // 插入第 1 行</span><br><span class="line">    lvi.iItem = 1;</span><br><span class="line">    lvi.iSubItem = 0;</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;MyWin32.exe&quot;);</span><br><span class="line">    ListView_InsertItem(hList, &amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置其他列</span><br><span class="line">    ListView_SetItemText(hList, 1, 1, (LPWSTR)TEXT(&quot;101&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 1, 2, (LPWSTR)TEXT(&quot;0x77ff00&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 1, 3, (LPWSTR)TEXT(&quot;0x200&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息处理："><a href="#消息处理：" class="headerlink" title="消息处理："></a>消息处理：</h2><p>目标：在点击列表中某项时，显示该项PID</p>
<p>完成效果：</p>
<img src="/posts/49201/image-20250728181113600.png" class="" title="image-20250728181113600">

<h3 id="关键数据结构：-1"><a href="#关键数据结构：-1" class="headerlink" title="关键数据结构："></a>关键数据结构：</h3><h4 id="LVM-GETNEXTITEM消息："><a href="#LVM-GETNEXTITEM消息：" class="headerlink" title="LVM_GETNEXTITEM消息："></a>LVM_GETNEXTITEM消息：</h4><p>作用：搜索具有指定属性且具有与指定项的指定关系的列表视图项。可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Commctrl/nf-commctrl-listview_getnextitem"><strong>ListView_GetNextItem</strong></a> 宏发送。</p>
<ul>
<li><p><em>wParam</em></p>
<p>要开始搜索的项的索引。-1代表查找与指定标志匹配的第一个项。</p>
</li>
<li><p><em>lParam</em></p>
<p>指定与 <em>wParam</em> 中指定的项的关系。</p>
</li>
</ul>
<p>lParam的常见取值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LVNI_ABOVE</strong></td>
<td>搜索位于指定项上方的项。</td>
</tr>
<tr>
<td><strong>LVNI_BELOW</strong></td>
<td>搜索位于指定项下方的项。</td>
</tr>
<tr>
<td><strong>LVNI_TOLEFT</strong></td>
<td>搜索位于指定项左方的项。</td>
</tr>
<tr>
<td><strong>LVNI_TORIGHT</strong></td>
<td>搜索位于指定项右方的项。</td>
</tr>
<tr>
<td><strong>LVNI_SELECTED</strong></td>
<td>被选定的项</td>
</tr>
</tbody></table>
<h4 id="ListView-GetNextItem宏："><a href="#ListView-GetNextItem宏：" class="headerlink" title="ListView_GetNextItem宏："></a>ListView_GetNextItem宏：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ListView_GetNextItem(</span><br><span class="line">   HWND hwnd,			// 列表句柄</span><br><span class="line">   int  i,				// 与上面LVM_GETNEXTITEM消息的wParam参数相同</span><br><span class="line">   UINT flags			// 与上面LVM_GETNEXTITEM消息的lParam参数相同</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：发送LVM_GETNEXTITEM消息，搜索具有指定属性且具有与指定项的指定关系的列表视图项</p>
<p>返回值：返回索引（失败返回-1）</p>
<h4 id="LVM-GETITEMTEXT消息："><a href="#LVM-GETITEMTEXT消息：" class="headerlink" title="LVM_GETITEMTEXT消息："></a>LVM_GETITEMTEXT消息：</h4><p>作用：检索（获取）列表视图项或子项的文本。可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Commctrl/nf-commctrl-listview_getitemtext"><strong>ListView_GetItemText</strong></a> 宏发送。</p>
<ul>
<li><p><em>wParam</em></p>
<p>列表视图项的索引。</p>
</li>
<li><p><em>lParam</em></p>
<p>指向 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/commctrl/ns-commctrl-lvitema"><strong>LVITEM</strong></a> 结构的指针。</p>
</li>
</ul>
<h4 id="ListView-GetItemText-宏："><a href="#ListView-GetItemText-宏：" class="headerlink" title="ListView_GetItemText 宏："></a>ListView_GetItemText 宏：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void ListView_GetItemText(</span><br><span class="line">   HWND   hwndLV,		// 列表视图控件的句柄</span><br><span class="line">   int    i,			// 项的索引(列索引)</span><br><span class="line">   int    iSubItem_,	// 子项的索引（行索引）</span><br><span class="line">   LPTSTR pszText_,		// 接收缓冲区</span><br><span class="line">   int    cchTextMax_	// 缓冲区大小（字符数）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VOID EnumModules(HWND HwndList) &#123;</span><br><span class="line">    int Iitem = SendMessage(HwndList, LVM_GETNEXTITEM, -1, LVNI_SELECTED);</span><br><span class="line">    //int Iitem = ListView_GetNextItem(HwndList,-1, LVNI_SELECTED);</span><br><span class="line">    LV_ITEM lvi;</span><br><span class="line">    memset(&amp;lvi, 0, sizeof(LV_ITEM));</span><br><span class="line">    lvi.mask = LVIF_TEXT;</span><br><span class="line">    lvi.iItem = Iitem;</span><br><span class="line">    lvi.iSubItem = 1;</span><br><span class="line">    TCHAR szPid[20] = &#123; 0 &#125;;</span><br><span class="line">    lvi.pszText = szPid;</span><br><span class="line">    lvi.cchTextMax = 20;</span><br><span class="line">    SendMessage(HwndList, LVM_GETITEMTEXT, Iitem, (DWORD)&amp;lvi);</span><br><span class="line">    //ListView_GetItemText(HwndList,Iitem,1,szPid,20);</span><br><span class="line">    MessageBox(NULL, szPid, TEXT(&quot;PID&quot;), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最终代码："><a href="#最终代码：" class="headerlink" title="最终代码："></a>最终代码：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">// Resorce.cpp : 定义应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;framework.h&quot;</span><br><span class="line">#include &quot;testDe.h&quot;</span><br><span class="line">#include &lt;commctrl.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;comctl32.lib&quot;)</span><br><span class="line"></span><br><span class="line">INT_PTR CALLBACK   DialogProc(HWND, UINT, WPARAM, LPARAM);</span><br><span class="line">void InitProcessList(HWND);</span><br><span class="line">void InsertInfo(HWND);</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">    _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">    _In_ LPWSTR    lpCmdLine,</span><br><span class="line">    _In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, DialogProc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">作用：初始化列表（添加列）</span><br><span class="line">参数hwndDlg：对话框句柄</span><br><span class="line">*/</span><br><span class="line">void InitProcessList(HWND hwndDlg)&#123;</span><br><span class="line">    // 获取句柄</span><br><span class="line">    HWND HwndList=NULL;</span><br><span class="line">    HwndList = GetDlgItem(hwndDlg,IDC_LIST_PROCESS );</span><br><span class="line"></span><br><span class="line">    // 设置整行选中</span><br><span class="line">    SendMessage(HwndList, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);</span><br><span class="line"></span><br><span class="line">    // 获取控件总宽度</span><br><span class="line">    RECT rc;</span><br><span class="line">    GetClientRect(HwndList, &amp;rc);</span><br><span class="line">    int listWidth = rc.right - rc.left;</span><br><span class="line"></span><br><span class="line">    LV_COLUMN lv;</span><br><span class="line">    memset(&amp;lv, 0,sizeof(LV_COLUMN));</span><br><span class="line">    // 设置第一列</span><br><span class="line">    TCHAR Name[20] = TEXT(&quot;进程名&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM ;</span><br><span class="line">    lv.pszText = Name;				//  列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;         // 标题中间对齐</span><br><span class="line">    lv.cx = 200;								//列宽</span><br><span class="line">    lv.iSubItem = 0;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 0, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 0, &amp;lv);</span><br><span class="line"></span><br><span class="line">    // 设置第二列</span><br><span class="line">    TCHAR Name2[] = TEXT(&quot;PID&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM;</span><br><span class="line">    lv.pszText = Name2;				//列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;</span><br><span class="line">    lv.cx = 100;								//列宽</span><br><span class="line">    lv.iSubItem = 1;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 1, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 1, &amp;lv);</span><br><span class="line"></span><br><span class="line">    // 设置第三列</span><br><span class="line">    TCHAR Name3[] = TEXT(&quot;镜像基址&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM;</span><br><span class="line">    lv.pszText = Name3;				//列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;</span><br><span class="line">    lv.cx = 100;								//列宽</span><br><span class="line">    lv.iSubItem = 2;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 2, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 2, &amp;lv);</span><br><span class="line"></span><br><span class="line">    // 设置第四列</span><br><span class="line">    TCHAR Name4[] = TEXT(&quot;镜像大小&quot;);</span><br><span class="line">    lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM;</span><br><span class="line">    lv.pszText = Name4;				//列标题</span><br><span class="line">    lv.fmt = LVCFMT_CENTER;</span><br><span class="line">    lv.cx = listWidth - 200 - 100*2;	// 这里列宽取剩余大小是为了防止有剩余导致多出一个空列</span><br><span class="line">    lv.iSubItem = 3;</span><br><span class="line">    // SendMessage(HwndList, LVM_INSERTCOLUMN, 3, (DWORD)&amp;lv);</span><br><span class="line">    ListView_InsertColumn(HwndList, 3, &amp;lv);</span><br><span class="line"></span><br><span class="line">    InsertInfo(hwndDlg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">作用：插入信息到列表</span><br><span class="line">参数hwndDlg：对话框句柄</span><br><span class="line">*/</span><br><span class="line">void InsertInfo(HWND hwndDlg) &#123;</span><br><span class="line">    HWND hList = GetDlgItem(hwndDlg, IDC_LIST_PROCESS);</span><br><span class="line"></span><br><span class="line">    LVITEM lvi = &#123; 0 &#125;;</span><br><span class="line">    lvi.mask = LVIF_TEXT;</span><br><span class="line"></span><br><span class="line">    // 插入第 0 行</span><br><span class="line">    lvi.iItem = 0;</span><br><span class="line">    lvi.iSubItem = 0;</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;test.exe&quot;);</span><br><span class="line">    ListView_InsertItem(hList, &amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置其他列</span><br><span class="line">    ListView_SetItemText(hList, 0, 1, (LPWSTR)TEXT(&quot;100&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 0, 2, (LPWSTR)TEXT(&quot;0x77ffee&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 0, 3, (LPWSTR)TEXT(&quot;0x100&quot;));</span><br><span class="line"></span><br><span class="line">    // 插入第 1 行</span><br><span class="line">    lvi.iItem = 1;</span><br><span class="line">    lvi.iSubItem = 0;</span><br><span class="line">    lvi.pszText = (LPWSTR)TEXT(&quot;MyWin32.exe&quot;);</span><br><span class="line">    ListView_InsertItem(hList, &amp;lvi);</span><br><span class="line"></span><br><span class="line">    // 设置其他列</span><br><span class="line">    ListView_SetItemText(hList, 1, 1, (LPWSTR)TEXT(&quot;101&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 1, 2, (LPWSTR)TEXT(&quot;0x77ff00&quot;));</span><br><span class="line">    ListView_SetItemText(hList, 1, 3, (LPWSTR)TEXT(&quot;0x200&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">作用：消息处理（点击时弹出PID信息）</span><br><span class="line">参数HwndList：列表句柄</span><br><span class="line">*/</span><br><span class="line">VOID EnumModules(HWND HwndList) &#123;</span><br><span class="line">    int Iitem = SendMessage(HwndList, LVM_GETNEXTITEM, -1, LVNI_SELECTED);</span><br><span class="line">    //int Iitem = ListView_GetNextItem(HwndList,-1, LVNI_SELECTED);</span><br><span class="line">    LV_ITEM lvi;</span><br><span class="line">    memset(&amp;lvi, 0, sizeof(LV_ITEM));</span><br><span class="line">    lvi.mask = LVIF_TEXT;</span><br><span class="line">    lvi.iItem = Iitem;</span><br><span class="line">    lvi.iSubItem = 1;</span><br><span class="line">    TCHAR szPid[20] = &#123; 0 &#125;;</span><br><span class="line">    lvi.pszText = szPid;</span><br><span class="line">    lvi.cchTextMax = 20;</span><br><span class="line">    SendMessage(HwndList, LVM_GETITEMTEXT, Iitem, (DWORD)&amp;lvi);</span><br><span class="line">    //ListView_GetItemText(HwndList,Iitem,1,szPid,20);</span><br><span class="line">    MessageBox(NULL, szPid, TEXT(&quot;PID&quot;), MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回调函数</span><br><span class="line">INT_PTR CALLBACK DialogProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    switch (message) &#123;</span><br><span class="line">        case WM_INITDIALOG:   // 对话框初始化时对列表初始化</span><br><span class="line">            InitProcessList(hWnd);</span><br><span class="line">            return true;</span><br><span class="line">        case WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            WORD ButtonID = LOWORD(wParam);</span><br><span class="line">            WORD NotifCode = HIWORD(wParam);</span><br><span class="line">            switch (ButtonID) &#123;</span><br><span class="line">                case IDC_BUTTON_EXIT:</span><br><span class="line">                    EndDialog(hWnd, 0);</span><br><span class="line">                    return TRUE;</span><br><span class="line">                default:</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_NOTIFY:</span><br><span class="line">        &#123;</span><br><span class="line">            NMHDR* notice = (NMHDR*)lParam;</span><br><span class="line">            if (wParam == IDC_LIST_PROCESS &amp;&amp; notice-&gt;code == NM_CLICK) &#123;  // 判断是否是目标列表的消息</span><br><span class="line">                HWND HwndList = NULL;</span><br><span class="line">                HwndList = GetDlgItem(hWnd, IDC_LIST_PROCESS);</span><br><span class="line">                EnumModules(HwndList);</span><br><span class="line">            &#125;</span><br><span class="line">            return TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_CLOSE:</span><br><span class="line">            EndDialog(hWnd, 0);</span><br><span class="line">            return TRUE;</span><br><span class="line">        default:</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-07-28%20151631.png" alt="屏幕截图 2025-07-28 151631"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/32955/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/32955/" class="post-title-link" itemprop="url">资源表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-25 21:23:11" itemprop="dateCreated datePublished" datetime="2025-07-25T21:23:11+08:00">2025-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-28 20:18:58" itemprop="dateModified" datetime="2025-07-28T20:18:58+08:00">2025-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="资源表概述"><a href="#资源表概述" class="headerlink" title="资源表概述"></a>资源表概述</h1><h2 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h2><p>​	资源表（Resource Table）是Windows的PE文件中用于存储非代码&#x2F;非程序逻辑数据的核心结构，包括图标、对话框、字符串、位图、菜单等静态资源。其设计采用树形目录结构，确保资源的高效组织与访问。</p>
<p>​	资源表是可选头数据目录表的第三个成员，IMAGE_DATA_DIRECTORY[2]里面存储着资源表的起始RVA。资源表并非采用简单的结构体结构或结构体数组结构，为了对资源进行更好的管理，资源表采用如下的树状结构：</p>
<img src="/posts/32955/draw.drawio.png" class="" title="draw.drawio">

<p>每一级对应着不同的作用。其中：</p>
<ul>
<li>第一级：类型。资源被划分为了很多种类，例如图标、字符串、对话框、菜单、、、。这一级系统预定义了16种类型，都是使用ID来标识的。用户可使用大于16的ID或使用字符串来定义新类型。</li>
<li>第二级：编号。这里使用字符串或者ID对资源进行更细致的划分，如具体某个图标的ID。</li>
<li>第三级：代码页。这里使用语言&#x2F;代码页来区分不同资源（如中英文资源）。这里的每一个目录项结构都唯一指向一个资源数据入口（结构体）。这一级系统也预定义了一些代码页，如简体中文0x804。这些预定义的代码页都是用ID来标识的。用户也可自定义，但一般不会这么整（因为字符串需手动解析）。</li>
<li>叶子节点：资源数据入口（图中绿色部分）。里面储存着目标资源的RVA和大小。</li>
</ul>
<p>IMAGE_DATA_DIRECTORY[2]结构体中存储的RVA指向第一级（也就是根节点）的位置。这三层目录的每一个节点都是由一个资源目录头（图中红色）和若干个资源目录项（图中黄色）组成。第三层的节点指向数据资源入口（图中绿色部分），这里存储资源位置和大小。</p>
<h2 id="资源目录头："><a href="#资源目录头：" class="headerlink" title="资源目录头："></a><strong>资源目录头：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_RESOURCE_DIRECTORY &#123;</span><br><span class="line">    DWORD Characteristics;     // 通常为0</span><br><span class="line">    DWORD TimeDateStamp;      // 时间戳（通常为0）</span><br><span class="line">    WORD  MajorVersion;       // 主版本号（通常为0）</span><br><span class="line">    WORD  MinorVersion;       // 次版本号（通常为0）</span><br><span class="line">    WORD  NumberOfNamedEntries; // 以名字命名的目录项数量******</span><br><span class="line">    WORD  NumberOfIdEntries;    // 以ID命名的目录项数量******</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>其中，最后两个成员NumberOfNamedEntries和NumberOfIdEntries最为重要，这两者之和代表了接下来会有多少个目录项。</p>
<h2 id="资源目录项："><a href="#资源目录项：" class="headerlink" title="资源目录项："></a><strong>资源目录项：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            DWORD NameOffset:31; // 名称字符串偏移量（相对于当前资源段起始）</span><br><span class="line">            DWORD NameIsString:1; // 1=Name是字符串偏移；0=Name是整数ID</span><br><span class="line">        &#125;;</span><br><span class="line">        DWORD Name;              // 当 NameIsString=0 时，直接是整数ID（资源类型、名称ID或语言ID）</span><br><span class="line">        WORD  Id;                // 有时方便访问整数ID部分</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD OffsetToData;      // 低位：1=指向子目录；0=指向数据条目</span><br><span class="line">        struct &#123;</span><br><span class="line">            DWORD OffsetToDirectory:31; // 子目录或数据条目的偏移量（相对于总资源段起始，即根目录位置）</span><br><span class="line">            DWORD DataIsDirectory:1;    // 1=指向另一个目录；0=指向数据条目</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure>

<p>​	这个结构体由两个联合体构成，每个联合体占4个字节，一共占8个字节。</p>
<p>​	对于第一个联合体，它由一个4字节结构体、4字节的Name和2字节的id组成。这个id一般不用。在4字节结构体中，NameOffset占低0~31位，NameIsString占第32位。NameIsString仅仅是用来判断的：</p>
<ul>
<li>当NameIsString&#x3D;&#x3D;1时，第一个联合体的后31位是一个偏移，偏移基址为<strong>本节点</strong>起始位置，此偏移指向一个IMAGE_RESOURCE_DIR_STRING_U结构体，此结构体存储资源或资源类的名称。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_RESOURCE_DIR_STRING_U &#123;</span><br><span class="line">    USHORT Length;       // 字符串的字符数（非字节数）</span><br><span class="line">    WCHAR  NameString[1]; // 可变长 Unicode 字符串数组（无终止符）</span><br><span class="line">&#125; IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;</span><br></pre></td></tr></table></figure>

<ul>
<li>当NameIsString&#x3D;&#x3D;0时，此联合体代表此资源类或资源的ID。</li>
</ul>
<p>​	第二个联合体与第一个联合体结构相似，他的DataIsDirectory也是用来判断的。</p>
<ul>
<li>当DataIsDirectory &#x3D;&#x3D; 1，代表下一个节点还是正常节点，OffsetToDirectory表示下一个目录节点相对于<strong>根节点</strong>起始位置的偏移。</li>
<li>当DataIsDirectory &#x3D;&#x3D; 0，代表下一个节点是叶子节点，即OffsetToDirectory表示一个资源目录入口结构体相对于<strong>根节点</strong>起始位置的偏移。</li>
</ul>
<p>由于资源目录表采用三级树状结构，故前两级节点的DataIsDirectory&#x3D;&#x3D;1，而第三级节点的DataIsDirectory&#x3D;&#x3D;0。</p>
<h2 id="资源目录入口："><a href="#资源目录入口：" class="headerlink" title="资源目录入口："></a>资源目录入口：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_RESOURCE_DATA_ENTRY &#123;</span><br><span class="line">    DWORD   OffsetToData;  // 资源数据的 RVA (Relative Virtual Address) 或虚拟地址偏移。</span><br><span class="line">    DWORD   Size;           // 资源数据的原始大小（字节数）。</span><br><span class="line">    DWORD   CodePage;       // 用于解码字符串资源的代码页（通常未使用，设为 0）。</span><br><span class="line">    DWORD   Reserved;       // 保留字段，必须为 0。</span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure>

<h1 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h1><p>目标：解析资源表，递归打印各资源的类别、编号、代码页、RVA和大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;locale.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">IMAGE_RESOURCE_DIRECTORY* resdir;</span><br><span class="line">typedef struct Resource&#123;  // 定义一个结构体来存储资源信息</span><br><span class="line">    DWORD type;</span><br><span class="line">    DWORD id;</span><br><span class="line">    DWORD code;</span><br><span class="line">    DWORD RVA;</span><br><span class="line">    DWORD size;</span><br><span class="line">&#125; Resource;</span><br><span class="line"></span><br><span class="line">Resource resource=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">    DWORD foa=0;</span><br><span class="line">    if(rva&lt;oheader-&gt;SizeOfHeaders) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;fheader-&gt;NumberOfSections;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == fheader-&gt;NumberOfSections) &#123;printf(&quot;没有对应的FOA\n&quot;);return 0;&#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">    return foa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printResourceDirectory(IMAGE_RESOURCE_DIRECTORY* dir, int level) &#123;</span><br><span class="line">    if(dir == NULL) return;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;dir-&gt;NumberOfNamedEntries+dir-&gt;NumberOfIdEntries;i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; level; j++) printf(&quot;│   &quot;);</span><br><span class="line">        IMAGE_RESOURCE_DIRECTORY_ENTRY* entry = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)((BYTE*)dir + sizeof(IMAGE_RESOURCE_DIRECTORY) + i * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));</span><br><span class="line">        if(entry-&gt;NameIsString) &#123;</span><br><span class="line">            IMAGE_RESOURCE_DIR_STRING_U* name = (IMAGE_RESOURCE_DIR_STRING_U*)((BYTE*)dir + entry-&gt;NameOffset);</span><br><span class="line">            setlocale(LC_CTYPE, &quot;&quot;);</span><br><span class="line">            wchar_t nameBuffer[256]=&#123;0&#125;;</span><br><span class="line">            memcpy(nameBuffer, name-&gt;NameString, name-&gt;Length * sizeof(WCHAR));</span><br><span class="line">            nameBuffer[name-&gt;Length] = L&#x27;\0&#x27;; // 确保字符串以null结尾</span><br><span class="line">            wprintf(L&quot;├─type:%ls\n&quot;, nameBuffer);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;├─type:%#x\n&quot;, entry-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        if(entry-&gt;DataIsDirectory) &#123;</span><br><span class="line">            IMAGE_RESOURCE_DIRECTORY* subDir = (IMAGE_RESOURCE_DIRECTORY*)((BYTE*)resdir + entry-&gt;OffsetToDirectory);</span><br><span class="line">            printResourceDirectory(subDir, level + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            IMAGE_RESOURCE_DATA_ENTRY* dataEntry = (IMAGE_RESOURCE_DATA_ENTRY*)((BYTE*)resdir + entry-&gt;OffsetToData);</span><br><span class="line">            for(int j = 0; j &lt; level; j++) printf(&quot;│   &quot;);</span><br><span class="line">            printf(&quot;    └─ RVA: %#x, Size: %#x, FOA: %#x\n&quot;, dataEntry-&gt;OffsetToData, dataEntry-&gt;Size, RVA_to_FOA(dataEntry-&gt;OffsetToData));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    const char* pe_path = &quot;D:\\桌面\\testDe.exe&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    int psize=ftell(pf);</span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(psize);</span><br><span class="line">    fread(file_buf,1,psize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    dos = (IMAGE_DOS_HEADER*)file_buf;</span><br><span class="line">    if (dos-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        printf(&quot;不是有效的DOS头\n&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD offset = dos-&gt;e_lfanew;</span><br><span class="line">    if (memcmp(file_buf + offset, &quot;PE\0\0&quot;, 4) != 0) &#123;</span><br><span class="line">        printf(&quot;不是有效的PE文件\n&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        free(dos);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += 4; // 定位到file头</span><br><span class="line">    fheader = (IMAGE_FILE_HEADER*)(file_buf + offset);</span><br><span class="line">    offset += sizeof(IMAGE_FILE_HEADER); // 定位到可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)(file_buf + offset);</span><br><span class="line">    offset += sizeof(IMAGE_OPTIONAL_HEADER32);  // 定位到节表</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)(file_buf + offset);</span><br><span class="line">    resdir = (IMAGE_RESOURCE_DIRECTORY*)(file_buf + RVA_to_FOA(oheader-&gt;DataDirectory[2].VirtualAddress));</span><br><span class="line">    printResourceDirectory(resdir, 0);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<img src="/posts/32955/image-20250726203010231.png" class="" title="image-20250726203010231">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/27109/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/27109/" class="post-title-link" itemprop="url">使用Dialog创建对话框</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-24 16:12:06" itemprop="dateCreated datePublished" datetime="2025-07-24T16:12:06+08:00">2025-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-28 20:18:58" itemprop="dateModified" datetime="2025-07-28T20:18:58+08:00">2025-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="资源文件："><a href="#资源文件：" class="headerlink" title="资源文件："></a>资源文件：</h1><p>在VS2022里面创建Windows 桌面应用程序项目时，会自动在资源文件里面生成项目名.rc文件、项目名.ico文件（程序大图标）、small.ico文件（程序小图标），在头文件里面生成一个配套的Resource.h文件。VS为了防止资源文件和头文件不一致导致资源编译错误而启用了互斥锁，因此打开头文件后不能打开任何一个资源文件，反之亦然。</p>
<h2 id="Resource-h文件："><a href="#Resource-h文件：" class="headerlink" title="Resource.h文件："></a>Resource.h文件：</h2><p>先看生成的头文件内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span><br><span class="line">// Microsoft Visual C++ 生成的包含文件。</span><br><span class="line">// 供 DiaLog.rc 使用</span><br><span class="line">//</span><br><span class="line">#define IDC_MYICON                      2</span><br><span class="line">#define IDD_DIALOG_DIALOG               102</span><br><span class="line">#define IDS_APP_TITLE                   103				// 程序标题</span><br><span class="line">#define IDD_ABOUTBOX                    106				// 用于创建菜单对话框</span><br><span class="line">#define IDM_ABOUT                       104				// 用来判断是否为打开菜单命令</span><br><span class="line">#define IDM_EXIT                        105				</span><br><span class="line">#define IDI_DIALOG                      107				// 程序大图标</span><br><span class="line">#define IDI_SMALL                       108				// 程序小图标</span><br><span class="line">#define IDC_DIALOG                      109				// 这里的DIALOG是项目名，这个宏定义的资源指向了</span><br><span class="line">#define IDR_MAINFRAME                   128</span><br><span class="line"></span><br><span class="line">// Next default values for new objects</span><br><span class="line">// </span><br><span class="line">#ifdef APSTUDIO_INVOKED</span><br><span class="line">#ifndef APSTUDIO_READONLY_SYMBOLS</span><br><span class="line">#define _APS_NO_MFC                     1</span><br><span class="line">#define _APS_NEXT_RESOURCE_VALUE        130</span><br><span class="line">#define _APS_NEXT_COMMAND_VALUE         32771</span><br><span class="line">#define _APS_NEXT_CONTROL_VALUE         1000</span><br><span class="line">#define _APS_NEXT_SYMED_VALUE           110</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>头文件定义了 Windows 应用程序中的各类资源标识符（注意，头文件里面只是给资源编号，而具体的资源在.rc文件里面），分为以下几种资源类型：</p>
<table>
<thead>
<tr>
<th align="center">定义宏</th>
<th align="center">前缀含义</th>
<th align="center">资源类型</th>
<th align="center">典型用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>IDC_</code></td>
<td align="center">Control&#x2F;Resource</td>
<td align="center">图标&#x2F;光标&#x2F;控件</td>
<td align="center">窗口图标、按钮、静态文本</td>
</tr>
<tr>
<td align="center"><code>IDD_</code></td>
<td align="center">Dialog</td>
<td align="center">对话框</td>
<td align="center">应用程序窗口&#x2F;对话框模板</td>
</tr>
<tr>
<td align="center"><code>IDS_</code></td>
<td align="center">String</td>
<td align="center">字符串</td>
<td align="center">标题栏文本、状态信息</td>
</tr>
<tr>
<td align="center"><code>IDM_</code></td>
<td align="center">Menu</td>
<td align="center">菜单项</td>
<td align="center">菜单选项命令标识</td>
</tr>
<tr>
<td align="center"><code>IDI_</code></td>
<td align="center">Icon</td>
<td align="center">图标</td>
<td align="center">应用程序图标</td>
</tr>
<tr>
<td align="center"><code>IDR_</code></td>
<td align="center">Resource Bundle</td>
<td align="center">资源集合</td>
<td align="center">菜单&#x2F;工具栏&#x2F;加速键组合</td>
</tr>
</tbody></table>
<h2 id="rc文件"><a href="#rc文件" class="headerlink" title=".rc文件"></a>.rc文件</h2><p>.rc文件的本质是文本文件，可以通过右键-&gt;打开方式-&gt;源代码编辑器，看到其实质内容：</p>
<img src="/posts/27109/image-20250724165232101.png" class="" title="image-20250724165232101">

<p>资源视图实际上是VS提供的高级可视化界面，它通过树形结构管理.rc文件的内部，如：</p>
<img src="/posts/27109/image-20250724165430068.png" class="" title="image-20250724165430068">

<p>在这里面点击IDI_DIALOG能看到程序的大图标，这并非说明了.rc文件包含了这个图片，而是.rc仅仅引用了这个图片，然后VS2022显示出来的，实际上的.rc全是文本。引用语句像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDI_DIALOG              ICON                    &quot;DiaLog.ico&quot;</span><br></pre></td></tr></table></figure>



<h1 id="创建Dialog"><a href="#创建Dialog" class="headerlink" title="创建Dialog"></a>创建Dialog</h1><p>在VS2022里面右键项目，选择添加-&gt;资源</p>
<img src="/posts/27109/image-20250724161424938.png" class="" title="image-20250724161424938">

<p>选择Dialog-&gt;新建</p>
<img src="/posts/27109/image-20250724162143482.png" class="" title="image-20250724162143482">

<p>使用资源管理器打开.rc文件，他给我们生成了一个IDD_DIALOG1资源（对话框资源）。</p>
<p>IDD_DIALOG1是一个宏，在resource.h中有定义，代表一个唯一的整数值（129），用于标识对话框模板资源。在resource.h里面可以看到：</p>
<img src="/posts/27109/image-20250724170612991.png" class="" title="image-20250724170612991">



<p>双击打开IDD_DIALOG1：</p>
<img src="/posts/27109/image-20250724170112827.png" class="" title="image-20250724170112827">

<p>可以在右侧工具箱里面添加控件：</p>
<img src="/posts/27109/image-20250724221540200.png" class="" title="image-20250724221540200">

<p>这里我先把自带的“确定”与“取消”删掉，从空白开始创建，创建一个如下所示的对话框（像Button和static Button这些需要编辑的控件，单击即可编辑）：</p>
<img src="/posts/27109/image-20250724223039359.png" class="" title="image-20250724223039359">

<p>右键控件，选择属性即可看到控件的资源标识符（宏），点击ID即可更改宏的名称：</p>
<img src="/posts/27109/image-20250724223350010.png" class="" title="image-20250724223350010">

<p>这里我把4个控件的宏改了，分别改为了EditAccount、EditPassword、ButtonOK和ButtonCancel。在.h文件可以看到对这些控件的定义：</p>
<img src="/posts/27109/image-20250724225849806.png" class="" title="image-20250724225849806">

<p>代码实现</p>
<p>关键函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建对话框</span><br><span class="line">void DialogBoxA(</span><br><span class="line">  [in, optional]  hInstance,				// 进程句柄</span><br><span class="line">  [in]            lpTemplate,				// 对话框模板。 此参数是字符串的指针，该字符串指定对话框模板的名称或指定对话框模板的资源标识符的整数值。 如果参数指定资源标识符，则其高序单词必须为零，其低序单词必须包含标识符。 可以使用 MAKEINTRESOURCE 宏创建此值。</span><br><span class="line">  [in, optional]  hWndParent,				// 拥有对话框的窗口的句柄。</span><br><span class="line">  [in, optional]  lpDialogFunc				// 指向对话框回调函数的指针</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 获取编辑框内容到lpString中</span><br><span class="line">UINT GetDlgItemTextA(</span><br><span class="line">  [in]  HWND  hDlg,							// 对话框句柄</span><br><span class="line">  [in]  int   nIDDlgItem,					// 控件（编辑框）标识符</span><br><span class="line">  [out] LPSTR lpString,						// 缓冲区字符串</span><br><span class="line">  [in]  int   cchMax						// 缓冲区大小</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 结束对话框</span><br><span class="line">BOOL EndDialog(</span><br><span class="line">  [in] HWND    hDlg,						// 对话框句柄</span><br><span class="line">  [in] INT_PTR nResult</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>目标：使用Dialog创建对话框，完成账号、密码的输入与检测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// Resorce.cpp : 定义应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;framework.h&quot;</span><br><span class="line">#include &quot;Resorce.h&quot;</span><br><span class="line"></span><br><span class="line">INT_PTR CALLBACK   DialogProc(HWND, UINT, WPARAM, LPARAM);</span><br><span class="line"></span><br><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">                     _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">                     _In_ LPWSTR    lpCmdLine,</span><br><span class="line">                     _In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, DialogProc); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INT_PTR CALLBACK DialogProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    switch (message) &#123;</span><br><span class="line">        case WM_INITDIALOG:</span><br><span class="line">            MessageBox(hWnd, L&quot;初始化对话框&quot;, L&quot;提示信息&quot;, MB_OK);</span><br><span class="line">            return true;</span><br><span class="line">        case WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">            WORD ButtonID = LOWORD(wParam);</span><br><span class="line">            WORD NotifCode = HIWORD(wParam);</span><br><span class="line">            switch (ButtonID) &#123;</span><br><span class="line">                case ButtonOK:</span><br><span class="line">                &#123;</span><br><span class="line">                    TCHAR account[128];</span><br><span class="line">                    GetDlgItemText(hWnd, EditAccount, account, 128);</span><br><span class="line">                    TCHAR PassWords[128];</span><br><span class="line">                    GetDlgItemText(hWnd, EditPassword, PassWords, 128);</span><br><span class="line">                    TCHAR RealAccount[] = TEXT(&quot;Trsy&quot;);</span><br><span class="line">                    TCHAR RealPasswords[] = TEXT(&quot;trsy1234&quot;);</span><br><span class="line">                    if (wcscmp(RealAccount, account)) &#123;</span><br><span class="line">                        MessageBox(hWnd, L&quot;账号错误&quot;, L&quot;提示信息&quot;, MB_OK);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    if (wcscmp(RealPasswords, PassWords)) &#123;</span><br><span class="line">                        MessageBox(hWnd, L&quot;密码错误&quot;, L&quot;提示信息&quot;, MB_OK);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    MessageBox(hWnd, L&quot;登录成功&quot;, L&quot;提示信息&quot;, MB_OK);</span><br><span class="line">                    return TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                case ButtonCancel:</span><br><span class="line">                    EndDialog(hWnd, 0);</span><br><span class="line">                    return TRUE;</span><br><span class="line">                default:</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            return false;</span><br><span class="line">   &#125;</span><br><span class="line">//    return FALSE;    // 这里不需要调用系统回调函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/31163/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/31163/" class="post-title-link" itemprop="url">子窗口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-22 22:24:00" itemprop="dateCreated datePublished" datetime="2025-07-22T22:24:00+08:00">2025-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-28 20:18:58" itemprop="dateModified" datetime="2025-07-28T20:18:58+08:00">2025-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><p>创建按钮使用CreateWindow函数，但是参数与创建普通窗口略有不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND CreateWindow(</span><br><span class="line">  [in, optional] LPCWSTR   lpClassName,		// 类名（按钮使用系统预定义的&quot;button&quot;类名）</span><br><span class="line">  [in, optional] LPCWSTR   lpWindowName,	// 窗口名称</span><br><span class="line">  [in]           DWORD     dwStyle,      // 窗口的样式（子窗口必须包含WS_CHILD）</span><br><span class="line">  [in]           int       x,			// 窗口左上角相对于父窗口左上角坐标横坐标</span><br><span class="line">  [in]           int       y,			// 窗口左上角相对于父窗口左上角坐标纵坐标</span><br><span class="line">  [in]           int       nWidth,		// 宽度</span><br><span class="line">  [in]           int       nHeight,     // 高度</span><br><span class="line">  [in, optional] HWND      hWndParent,		// 父进程句柄</span><br><span class="line">  [in, optional] HMENU     hMenu,			// 子窗口编号（标识符）</span><br><span class="line">  [in, optional] HINSTANCE hInstance,		// 当前应用程序的句柄  </span><br><span class="line">  [in, optional] LPVOID    lpParam			// 附加信息，一般为NULL	</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中与创建普通窗口不同的点在于一下三个参数：</p>
<h2 id="lpClassName："><a href="#lpClassName：" class="headerlink" title="lpClassName："></a>lpClassName：</h2><p>类名，创建按钮时一般使用系统帮我们定义好的”button”类，可通过以下代码查看这个类的各个属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TCHAR buffer[30] = &#123; 0 &#125;;</span><br><span class="line">int size = 30;</span><br><span class="line">size = GetClassName(HwndPushButton, buffer, size);</span><br><span class="line">DebugLog(TEXT(&quot;类名:%s\n&quot;), buffer);</span><br><span class="line">WNDCLASS wc = &#123; 0 &#125;;</span><br><span class="line">GetClassInfo(hInstance, buffer, &amp;wc);</span><br><span class="line">DebugLog(&quot;lpfnWndProc:%x\n&quot;, wc.lpfnWndProc);</span><br><span class="line">DebugLog(TEXT(&quot;lpszClassName:%s\n&quot;), wc.lpszClassName);</span><br></pre></td></tr></table></figure>

<h2 id="dwStyle："><a href="#dwStyle：" class="headerlink" title="dwStyle："></a>dwStyle：</h2><p>样式。样式分为两种：</p>
<h3 id="基础样式："><a href="#基础样式：" class="headerlink" title="基础样式："></a>基础样式：</h3><p>以”WS_”开头，适用于所有窗口类型（包括主窗口、对话框、控件等），定义窗口的<strong>基本框架特性</strong>（可见性、边框、滚动条等）。</p>
<p>常用的基础样式有：</p>
<table>
<thead>
<tr>
<th align="center">样式</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>WS_OVERLAPPED</code></td>
<td align="center">创建顶层重叠窗口（非子窗口）</td>
</tr>
<tr>
<td align="center"><code>WS_CAPTION</code></td>
<td align="center">添加标题栏（包含 <code>WS_BORDER</code>）</td>
</tr>
<tr>
<td align="center"><code>WS_SYSMENU</code></td>
<td align="center">添加标题栏右侧的系统菜单（关闭按钮）</td>
</tr>
<tr>
<td align="center"><code>WS_THICKFRAME</code></td>
<td align="center">添加可调整大小的边框</td>
</tr>
<tr>
<td align="center"><code>WS_MINIMIZEBOX</code></td>
<td align="center">添加最小化按钮</td>
</tr>
<tr>
<td align="center"><code>WS_MAXIMIZEBOX</code></td>
<td align="center">添加最大化按钮</td>
</tr>
<tr>
<td align="center"><code>WS_CHILD</code></td>
<td align="center">窗口是子窗口（子窗口一定要添加）</td>
</tr>
<tr>
<td align="center"><code>WS_VISIBLE</code></td>
<td align="center">最初可见</td>
</tr>
<tr>
<td align="center"><code>WS_TILEDWINDOW</code></td>
<td align="center">常用于主窗口，是多个标准样式的组合，即&#96;WS_OVERLAPPED</td>
</tr>
</tbody></table>
<p>当窗口是按钮时，最基础的配置是<code>WS_CHILD | WS_VISIBLE </code></p>
<h3 id="专用样式："><a href="#专用样式：" class="headerlink" title="专用样式："></a>专用样式：</h3><p>仅当窗口类为某个固定样式时才会生效。当窗口类是”Button”时，用于定义按钮的<strong>具体类型和行为</strong>（普通按钮、复选框等）。</p>
<p>常用的按钮专用样式为：</p>
<p>基础按钮类型 (互斥类型，只能选其一)：</p>
<table>
<thead>
<tr>
<th>样式</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BS_PUSHBUTTON</code></td>
<td>标准下压按钮。</td>
</tr>
<tr>
<td><code>BS_DEFPUSHBUTTON</code></td>
<td>默认按钮（通常带粗边框）。按 Enter 键时也会触发此按钮。在一个对话框中只能有一个。</td>
</tr>
<tr>
<td><code>BS_CHECKBOX</code></td>
<td>复选框 （二元状态：选中&#x2F;未选中）。需手动处理状态切换。</td>
</tr>
<tr>
<td><code>BS_AUTOCHECKBOX</code></td>
<td>自动状态切换的复选框。点击时自动切换选中状态</td>
</tr>
<tr>
<td><code>BS_RADIOBUTTON</code></td>
<td>单选按钮（互斥选择）。 需手动管理组内互斥逻辑</td>
</tr>
<tr>
<td><code>BS_AUTORADIOBUTTON</code></td>
<td>自动单选按钮。自动管理组内互斥逻辑</td>
</tr>
<tr>
<td><code>BS_3STATE</code> &#x2F; <code>BS_AUTO3STATE</code></td>
<td>三态复选框 (未选&#x2F;选中&#x2F;灰显) ，用于”部分选中”状态（如文件夹选择）</td>
</tr>
</tbody></table>
<p>除这些外，还有其他可组合样式。</p>
<h2 id="hMenu："><a href="#hMenu：" class="headerlink" title="hMenu："></a>hMenu：</h2><p>如果窗口是子窗口，那么hMenu填的是子窗口编号，父窗口用来对子窗口进行标识，由自己指定，但是对于具有相同父窗口的所有子窗口，它必须是唯一的。</p>
<h2 id="按钮回调函数："><a href="#按钮回调函数：" class="headerlink" title="按钮回调函数："></a>按钮回调函数：</h2><p>所有系统控件类（如 “button”、”edit”、”listbox”）都有内置的窗口过程，这个内置过程由 Windows 系统提供（在 user32.dll 中实现），开发者无需自己实现按钮的回调函数。当用户按下按钮时，会调用系统提供的按钮回调函数对消息进行处理，处理完后会向父窗口发送<code>WM_COMMAND</code>消息。</p>
<p>发送的<code>WM_COMMAND</code>消息的成员wParam的低两个字节代表控件ID，即子窗口编号，高两个字节代表通知码；常用的通知码为BN_CLICKED，值为0，代表按钮被点击。成员lParam代表按钮句柄。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>目标：实现按钮事件的处理。</p>
<p>首先创建3种按钮：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void CreateButton(HWND ParentHwnd,HINSTANCE hInstance) &#123;</span><br><span class="line">    HWND HwndPushButton = CreateWindowA(</span><br><span class="line">        &quot;button&quot;,         // 窗口类名,button是系统预定义好的</span><br><span class="line">        &quot;普通按钮&quot;,    // 窗口名</span><br><span class="line">        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,   // 窗口样式</span><br><span class="line">        10, 10,         // 窗口左上角相对于父窗口左上角坐标x,y</span><br><span class="line">        80, 20,         // 宽、高</span><br><span class="line">        ParentHwnd,     // 父窗口句柄</span><br><span class="line">        (HMENU)1002,    // 子窗口编号（标识符）</span><br><span class="line">        hInstance,      // 进程句柄</span><br><span class="line">        NULL            // 附加信息，一般为NULL</span><br><span class="line">        );</span><br><span class="line">    HWND HwndCheckBox = CreateWindowA(</span><br><span class="line">        &quot;button&quot;,         // 窗口类名</span><br><span class="line">        &quot;复选框&quot;,    // 窗口名</span><br><span class="line">        WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,   // 窗口样式</span><br><span class="line">        10, 40,         // 窗口左上角相对于父窗口左上角坐标x,y</span><br><span class="line">        80, 20,         // 宽、高</span><br><span class="line">        ParentHwnd,     // 父窗口句柄</span><br><span class="line">        (HMENU)1003,    // 子窗口编号（标识符）</span><br><span class="line">        hInstance,      // 进程句柄</span><br><span class="line">        NULL</span><br><span class="line">    );</span><br><span class="line">    HWND HwndRadioButton = CreateWindowA(</span><br><span class="line">        &quot;button&quot;,         // 窗口类名</span><br><span class="line">        &quot;单选按钮&quot;,     // 窗口名</span><br><span class="line">        WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON,   // 窗口样式</span><br><span class="line">        10, 70,         // 窗口左上角相对于父窗口左上角坐标x,y</span><br><span class="line">        80, 20,         // 宽、高</span><br><span class="line">        ParentHwnd,     // 父窗口句柄</span><br><span class="line">        (HMENU)1004,    // 子窗口编号（标识符）</span><br><span class="line">        hInstance,      // 进程句柄</span><br><span class="line">        NULL</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在主窗口（父窗口）回调函数里面的switch语句中加入一个分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">case WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">        WORD ButtonID = LOWORD(wParam);</span><br><span class="line">        WORD NotifCode = HIWORD(wParam);</span><br><span class="line">        switch (ButtonID) &#123;</span><br><span class="line">            case 1002:</span><br><span class="line">                if (NotifCode == BN_CLICKED) &#123;</span><br><span class="line">                    MessageBox(hWnd, L&quot;普通按钮&quot;, L&quot;Button&quot;, MB_OK);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 1003:</span><br><span class="line">                if (NotifCode == BN_CLICKED) &#123;</span><br><span class="line">                    MessageBox(hWnd, L&quot;复选框&quot;, L&quot;Button&quot;, MB_OK);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 1004:</span><br><span class="line">                if (NotifCode == BN_CLICKED) &#123;</span><br><span class="line">                    MessageBox(hWnd, L&quot;单选按钮&quot;, L&quot;Button&quot;, MB_OK);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">    			return DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">// FirstWindow.cpp : 定义应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;framework.h&quot;</span><br><span class="line">#include &quot;FirstWindow.h&quot;</span><br><span class="line">#include &quot;Debug.h&quot;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);</span><br><span class="line">void CreateButton(HWND ParentHwnd, HINSTANCE hInstance);</span><br><span class="line"></span><br><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">                     _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">                     _In_ LPWSTR    lpCmdLine,</span><br><span class="line">                     _In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    // 1、注册窗口类</span><br><span class="line">    TCHAR Name[] = L&quot;My First Window&quot;;</span><br><span class="line">    WNDCLASS wnd = &#123; 0 &#125;;</span><br><span class="line">    wnd.lpfnWndProc = WndProc;          // 回调函数</span><br><span class="line">    wnd.lpszClassName = Name;           // 类名</span><br><span class="line">    wnd.hInstance = hInstance;         // 进程句柄</span><br><span class="line">    wnd.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // 背景色(白色)</span><br><span class="line">    wnd.hCursor = LoadCursor(NULL, IDC_ARROW);   // 箭头光标</span><br><span class="line">    RegisterClass(&amp;wnd);</span><br><span class="line"></span><br><span class="line">    // 2、创建窗口</span><br><span class="line">    HWND hwnd = CreateWindow(</span><br><span class="line">        Name,                   // 类名</span><br><span class="line">        TEXT(&quot;我的Win32窗口&quot;),          // 窗口标题</span><br><span class="line">        WS_OVERLAPPEDWINDOW,     // 标准窗口样式</span><br><span class="line">        CW_USEDEFAULT,     // 初始水平位置（默认居中）</span><br><span class="line">        CW_USEDEFAULT,      // 初始垂直位置</span><br><span class="line">        500,                // 宽度500px</span><br><span class="line">        300,                // 高度300px</span><br><span class="line">        NULL,       // 父窗口</span><br><span class="line">        NULL,       // 菜单</span><br><span class="line">        hInstance,  // 实例句柄</span><br><span class="line">        NULL</span><br><span class="line">        );</span><br><span class="line">    if (hwnd == NULL) &#123;</span><br><span class="line">        MessageBoxW(NULL, L&quot;窗口创建失败!&quot;, L&quot;错误&quot;, MB_OK | MB_ICONERROR);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CreateButton(hwnd,hInstance);</span><br><span class="line"></span><br><span class="line">    // 3. 显示窗口</span><br><span class="line">    ShowWindow(hwnd, SW_SHOW); // 显示窗口</span><br><span class="line">   </span><br><span class="line">    // 4. 消息循环</span><br><span class="line">    MSG msg;</span><br><span class="line">    while (GetMessage(&amp;msg, NULL, 0, 0) &gt; 0) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg); // 转换键盘消息</span><br><span class="line">        DispatchMessage(&amp;msg);  // 分发到窗口过程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建按钮</span><br><span class="line">void CreateButton(HWND ParentHwnd,HINSTANCE hInstance) &#123;</span><br><span class="line">    HWND HwndPushButton = CreateWindowA(</span><br><span class="line">        &quot;button&quot;,         // 窗口类名,button是系统预定义好的</span><br><span class="line">        &quot;普通按钮&quot;,    // 窗口名</span><br><span class="line">        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,   // 窗口样式，子窗口必须包含“WS_CHILD”，“WS_VISIBLE”代表窗口最初可见，</span><br><span class="line">        10, 10,         // 窗口左上角相对于父窗口左上角坐标x,y</span><br><span class="line">        80, 20,         // 宽、高</span><br><span class="line">        ParentHwnd,     // 父窗口句柄</span><br><span class="line">        (HMENU)1002,    // 子窗口编号（标识符）</span><br><span class="line">        hInstance,      // 进程句柄</span><br><span class="line">        NULL            // 附加信息，一般为NULL</span><br><span class="line">        );</span><br><span class="line">    HWND HwndCheckBox = CreateWindowA(</span><br><span class="line">        &quot;button&quot;,         // 窗口类名</span><br><span class="line">        &quot;复选框&quot;,    // 窗口名</span><br><span class="line">        WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,   // 窗口样式，子窗口必须包含“WS_CHILD”，“WS_VISIBLE”代表窗口最初可见，</span><br><span class="line">        10, 40,         // 窗口左上角相对于父窗口左上角坐标x,y</span><br><span class="line">        80, 20,         // 宽、高</span><br><span class="line">        ParentHwnd,     // 父窗口句柄</span><br><span class="line">        (HMENU)1003,    // 子窗口编号（标识符）</span><br><span class="line">        hInstance,      // 进程句柄</span><br><span class="line">        NULL</span><br><span class="line">    );</span><br><span class="line">    HWND HwndRadioButton = CreateWindowA(</span><br><span class="line">        &quot;button&quot;,         // 窗口类名</span><br><span class="line">        &quot;单选按钮&quot;,     // 窗口名</span><br><span class="line">        WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON,   // 窗口样式，子窗口必须包含“WS_CHILD”，“WS_VISIBLE”代表窗口最初可见</span><br><span class="line">        10, 70,         // 窗口左上角相对于父窗口左上角坐标x,y</span><br><span class="line">        80, 20,         // 宽、高</span><br><span class="line">        ParentHwnd,     // 父窗口句柄</span><br><span class="line">        (HMENU)1004,    // 子窗口编号（标识符）</span><br><span class="line">        hInstance,      // 进程句柄</span><br><span class="line">        NULL</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span><br><span class="line">//</span><br><span class="line">//  目标: 处理主窗口的消息。</span><br><span class="line">//</span><br><span class="line">//  WM_COMMAND  - 处理应用程序菜单</span><br><span class="line">//  WM_PAINT    - 绘制主窗口</span><br><span class="line">//  WM_DESTROY  - 发送退出消息并返回</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    switch (message)</span><br><span class="line">    &#123;</span><br><span class="line">        case WM_CREATE:</span><br><span class="line">        &#123;</span><br><span class="line">            CREATESTRUCT* info = (CREATESTRUCT*)lParam;</span><br><span class="line">            DebugLog(L&quot;窗口创建成功，窗口类名为%s\n&quot;, info-&gt;lpszClass);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_MOVE:</span><br><span class="line">        &#123;</span><br><span class="line">            POINTS point = MAKEPOINTS(lParam);</span><br><span class="line">            DebugLog(&quot;窗口移动到了(%d,%d)\n&quot;, point.x, point.y);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_LBUTTONDOWN:</span><br><span class="line">        &#123;</span><br><span class="line">            POINTS point2 = MAKEPOINTS(lParam);</span><br><span class="line">            DebugLog(&quot;按下了左键,坐标为(%d,%d)\n&quot;, point2.x, point2.y);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_KEYDOWN:</span><br><span class="line">            DebugLog(&quot;按下了键盘，wParam：%#x，lParam：%#x\n&quot;, wParam, lParam);</span><br><span class="line">            return 0;</span><br><span class="line">        case WM_CLOSE:</span><br><span class="line">            DebugLog(&quot;关闭窗口\n&quot;);</span><br><span class="line">            DestroyWindow(hWnd); // 销毁窗口</span><br><span class="line">            return 0;</span><br><span class="line">        case WM_DESTROY:</span><br><span class="line">            DebugLog(&quot;销毁窗口\n&quot;);</span><br><span class="line">            PostQuitMessage(0);</span><br><span class="line">            return 0;</span><br><span class="line">        case WM_COMMAND:</span><br><span class="line">        &#123;</span><br><span class="line">                WORD ButtonID = LOWORD(wParam);</span><br><span class="line">                WORD NotifCode = HIWORD(wParam);</span><br><span class="line">                switch (ButtonID) &#123;</span><br><span class="line">                    case 1002:</span><br><span class="line">                        if (NotifCode == BN_CLICKED) &#123;</span><br><span class="line">                            MessageBox(hWnd, L&quot;普通按钮&quot;, L&quot;Button&quot;, MB_OK);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case 1003:</span><br><span class="line">                        if (NotifCode == BN_CLICKED) &#123;</span><br><span class="line">                            MessageBox(hWnd, L&quot;复选框&quot;, L&quot;Button&quot;, MB_OK);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case 1004:</span><br><span class="line">                        if (NotifCode == BN_CLICKED) &#123;</span><br><span class="line">                            MessageBox(hWnd, L&quot;单选按钮&quot;, L&quot;Button&quot;, MB_OK);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            return DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/21586/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/21586/" class="post-title-link" itemprop="url">图形化界面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-20 16:07:53" itemprop="dateCreated datePublished" datetime="2025-07-20T16:07:53+08:00">2025-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-23 22:40:29" itemprop="dateModified" datetime="2025-07-23T22:40:29+08:00">2025-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h1><h2 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h2><p>事件是操作系统或应用程序中发生的某个特定的、可由系统检测到的行为或状态改变。在Windows中，事件通常与线程或进程的执行、用户的操作（如点击按钮、按键）、硬件的状态变化等相关联。事件分为两类：</p>
<ul>
<li><strong>系统事件（如硬件事件等）</strong>：操作系统监视这些事件。</li>
<li><strong>应用程序事件</strong>：应用程序定义的事件，如用户点击按钮、窗口失去焦点等。</li>
</ul>
<h2 id="消息："><a href="#消息：" class="headerlink" title="消息："></a>消息：</h2><p>消息是Windows应用程序与操作系统和其他应用程序之间进行通信的基本单位。Windows是一个基于消息的系统，所有的用户输入、系统事件和应用程序之间的交互都是通过消息传递的（其实就是用来描述事件的）。每个消息都包含特定的信息，例如鼠标位置、按键信息等。</p>
<ul>
<li><strong>类型</strong>：每个消息有一个唯一的标识符，称为“消息类型”，例如<code>WM_PAINT</code>表示窗口需要重绘，<code>WM_KEYDOWN</code>表示用户按下键盘的一个键。</li>
<li><strong>传递机制</strong>：消息是通过消息队列传递的，消息队列是每个线程维护的一个队列，操作系统将消息放入队列，应用程序从队列中获取消息并进行处理。</li>
</ul>
<h3 id="MSG结构"><a href="#MSG结构" class="headerlink" title="MSG结构"></a>MSG结构</h3><p><code>MSG</code>结构体用于存储Windows消息的详细信息。它包含了以下几个重要字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagMSG &#123;</span><br><span class="line">    HWND hwnd;       // 消息的目标窗口的句柄(谁处理这个消息)</span><br><span class="line">    UINT message;    // 消息的类型（是点击左键还是敲击键盘）</span><br><span class="line">    WPARAM wParam;   // 消息的附加信息。16位整数</span><br><span class="line">    LPARAM lParam;   // 消息的附加信息。32位整数</span><br><span class="line">    DWORD time;      // 消息产生的时间</span><br><span class="line">    POINT pt;        // 消息发生时鼠标的坐标</span><br><span class="line">&#125; MSG;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hwnd</code>：该消息所关联的目标窗口的句柄。每个窗口都有一个唯一的句柄，它指示消息应该传递给哪个窗口。</li>
<li><code>message</code>：表示消息的类型（如<code>WM_MOUSEMOVE</code>、<code>WM_KEYDOWN</code>等）。消息类型本来是有编号的，但是由于编号难记，就将编号定义为了宏。</li>
<li><code>wParam</code> 和 <code>lParam</code>：这些是消息的附加参数，通常用于传递更多的上下文信息。</li>
<li><code>time</code>：消息的产生时间。</li>
<li><code>pt</code>：事件发生时鼠标位置的坐标。</li>
</ul>
<h2 id="消息流程："><a href="#消息流程：" class="headerlink" title="消息流程："></a>消息流程：</h2><p>Windows应用程序的消息处理流程大致如下：</p>
<ol>
<li><strong>操作系统产生消息</strong>：操作系统根据外部事件（如用户输入、系统变化等）生成消息。</li>
<li><strong>消息放入消息队列</strong>：每个线程有一个消息队列，操作系统将消息放入队列中。</li>
<li><strong>消息获取</strong>：应用程序通过<code>GetMessage</code>、<code>PeekMessage</code>等函数从消息队列中获取消息。如果队列为空，<code>GetMessage</code>会阻塞等待消息。</li>
<li><strong>消息分发</strong>：应用程序调用<code>DispatchMessage</code>函数将消息分发到适当的窗口过程（窗口的消息处理函数）。窗口过程根据消息类型做出相应的处理。</li>
<li><strong>窗口过程处理消息</strong>：每个窗口有一个窗口过程，它是一个函数，负责处理该窗口的消息。例如，<code>WM_PAINT</code>消息可以在窗口过程中的<code>WM_PAINT</code>分支下进行处理，重新绘制窗口。</li>
<li><strong>返回结果</strong>：窗口过程完成消息处理后，返回结果到操作系统。如果是响应用户输入或其他事件，可能会引发新的消息。</li>
</ol>
<img src="/posts/21586/draw.drawio.png" class="" title="draw.drawio">

<h1 id="第一个图形界面程序："><a href="#第一个图形界面程序：" class="headerlink" title="第一个图形界面程序："></a>第一个图形界面程序：</h1><h2 id="关键函数和结构体"><a href="#关键函数和结构体" class="headerlink" title="关键函数和结构体"></a>关键函数和结构体</h2><h3 id="WNDCLASS"><a href="#WNDCLASS" class="headerlink" title="WNDCLASS"></a>WNDCLASS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASSA &#123;</span><br><span class="line">  UINT      style;  // 类样式</span><br><span class="line">  WNDPROC   lpfnWndProc;  // 窗口回调函数指针***</span><br><span class="line">  int       cbClsExtra;  // 要按照窗口类结构分配的额外字节数</span><br><span class="line">  int       cbWndExtra;  // 在窗口实例之后分配的额外字节数</span><br><span class="line">  HINSTANCE hInstance;  // 创建窗口的应用进程句柄***</span><br><span class="line">  HICON     hIcon;   // 类图标的句柄</span><br><span class="line">  HCURSOR   hCursor;  // 类游标的句柄</span><br><span class="line">  HBRUSH    hbrBackground;  // 类背景画笔的句柄</span><br><span class="line">  LPCSTR    lpszMenuName;  // 类菜单的资源名称</span><br><span class="line">  LPCSTR    lpszClassName;  // 窗口类名***</span><br><span class="line">&#125; WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;</span><br></pre></td></tr></table></figure>

<p>作用：定义窗口类</p>
<h3 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND CreateWindow(</span><br><span class="line">  [in, optional] LPCWSTR   lpClassName,		// 类名</span><br><span class="line">  [in, optional] LPCWSTR   lpWindowName,	// 窗口名称</span><br><span class="line">  [in]           DWORD     dwStyle,      // 窗口的样式</span><br><span class="line">  [in]           int       x,			// 窗口的初始水平位置</span><br><span class="line">  [in]           int       y,			// 窗口的初始垂直位置</span><br><span class="line">  [in]           int       nWidth,		// 宽度</span><br><span class="line">  [in]           int       nHeight,     // 高度</span><br><span class="line">  [in, optional] HWND      hWndParent,		// 父进程句柄</span><br><span class="line">  [in, optional] HMENU     hMenu,			// 菜单句柄</span><br><span class="line">  [in, optional] HINSTANCE hInstance,		// 当前应用程序的句柄  </span><br><span class="line">  [in, optional] LPVOID    lpParam			// 附加信息，一般为NULL	</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：注册窗口类</p>
<h3 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL ShowWindow(</span><br><span class="line">  [in] HWND hWnd,		// 窗口的句柄</span><br><span class="line">  [in] int  nCmdShow	// 窗口的显示方式。SW_SHOW代表激活窗口并以当前大小和位置显示窗口</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：展示窗口</p>
<h3 id="GetMessage"><a href="#GetMessage" class="headerlink" title="GetMessage"></a>GetMessage</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL GetMessage(</span><br><span class="line">  [out]          LPMSG lpMsg,			// 接收消息的指针</span><br><span class="line">  [in, optional] HWND  hWnd,			// 目标窗口的句柄。若为NULL，则当前线程的任何窗口的消息</span><br><span class="line">  [in]           UINT  wMsgFilterMin,	// 要检索的最低消息值的整数值。</span><br><span class="line">  [in]           UINT  wMsgFilterMax	// 要检索的最高消息值的整数值。</span><br><span class="line">);    // 若wMsgFilterMin和wMsgFilterMax都为0，则返回所有可用消息</span><br></pre></td></tr></table></figure>

<p>作用：读取消息</p>
<h3 id="TranslateMessage"><a href="#TranslateMessage" class="headerlink" title="TranslateMessage"></a>TranslateMessage</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL TranslateMessage(</span><br><span class="line">  [in] const MSG *lpMsg			// 消息指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：加工、转换消息</p>
<h3 id="DispatchMessage"><a href="#DispatchMessage" class="headerlink" title="DispatchMessage"></a>DispatchMessage</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LRESULT DispatchMessage(</span><br><span class="line">  [in] const MSG *lpMsg			// 消息指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：将消息分发到对应的回调函数</p>
<h3 id="WndProc"><a href="#WndProc" class="headerlink" title="WndProc"></a>WndProc</h3><p>这个是自编的窗口回调函数，但是此函数有固定的格式，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK DefWindowProc(</span><br><span class="line">	HWND hwnd, 		 // 窗口句柄</span><br><span class="line">	UINT msg, 		// 消息类型</span><br><span class="line">	WPARAM wParam, 		// 消息附加信息</span><br><span class="line">	LPARAM lParam		// 消息附加信息</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>返回值：如果返回0则代表已处理，否者传给系统处理(调用DefWindowProc函数，参数与此函数相同)</p>
<p>作用：处理消息</p>
<h2 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h2><p>win32窗口应用程序不再有终端来打印调试，不能使用printf函数，但是提供另一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void OutputDebugStringA(</span><br><span class="line">  [in, optional] LPCSTR lpOutputString   // 传入字符串指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个函数传入字符串指针，在调试控制台打印字符串。但是参数只有一个，没办法打印变量的值，可以进行封装使之具备打印变量的能力:</p>
<p>Debug.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">void DebugLogA(const char* format, ...);  // 窄字符打印</span><br><span class="line">void DebugLogW(const wchar_t* format, ...); // 宽字符打印</span><br></pre></td></tr></table></figure>

<p>DebugLog.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;Debug.h&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">/*</span><br><span class="line">函数功能：实现格式化打印</span><br><span class="line">参数1：format，格式化字符串，类似于&quot;Error %d: %s&quot;</span><br><span class="line">参数2：&quot;...&quot;，可变数量的参数，对应格式化字符串中的占位符</span><br><span class="line">使用方式：与printf函数完全相同</span><br><span class="line">*/</span><br><span class="line">void DebugLogA(const char* format, ...) &#123; // 窄字符版本</span><br><span class="line">    char buf[512] = &#123; 0 &#125;;</span><br><span class="line">    va_list args;				//  声明va_list 类型的变量 args</span><br><span class="line">    va_start(args, format);		// 初始化可变参数列表，使 args 指向 format 后的第一个可变参数</span><br><span class="line">    _vsnprintf_s(buf, _countof(buf), _TRUNCATE, format, args);	// 将格式化字符串和参数组合成最终字符串</span><br><span class="line">    OutputDebugStringA(buf);		// 打印组合后的字符串</span><br><span class="line">    va_end(args);					 // 清理可变参数列表资源，避免资源泄漏</span><br><span class="line">&#125;</span><br><span class="line">void DebugLogW(const wchar_t* format, ...) &#123;  // 宽字符版本</span><br><span class="line">    wchar_t buf[512] = &#123; 0 &#125;;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    _vsnwprintf_s(buf, _countof(buf), _TRUNCATE, format, args);</span><br><span class="line">    OutputDebugStringW(buf);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了封装。在WinMain函数里面需要使用时，要把头文件包含进去。也可以使用函数重载（只能C++用），将这两个函数的名字改成相同的，那编译器就会根据参数类型选定正确的函数。</p>
<p>程序如果出现了错误就只是不会弹窗，并不会告诉你错在哪，需要使用GetLastError函数获取错误码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Post_equals_last_error_ DWORD GetLastError();  // 返回一个错误码</span><br></pre></td></tr></table></figure>

<p>正常来说错误码还需要拿到Windows官方网站去查找对应的错误信息，这里也封装一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PrintLastError() &#123;</span><br><span class="line">    DWORD err = GetLastError();  // 获取错误码</span><br><span class="line">    LPSTR msg = NULL;  // 存储错误信息</span><br><span class="line">    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,</span><br><span class="line">        NULL, err, 0, (LPSTR)&amp;msg, 0, NULL);  // 查找错误信息</span><br><span class="line">    DebugLog(&quot;Error %d: %s&quot;, err, msg);   // 打印</span><br><span class="line">    LocalFree(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h2><ol>
<li>自定义窗口类</li>
<li>注册窗口类</li>
<li>创建窗口</li>
<li>显示窗口</li>
<li>设置消息循环，捕获事件</li>
<li>生成消息，交给系统</li>
<li>创建回调函数</li>
</ol>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">// FirstWindow.cpp : 定义应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;framework.h&quot;</span><br><span class="line">#include &quot;FirstWindow.h&quot;</span><br><span class="line">#include &quot;Debug.h&quot;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);</span><br><span class="line"></span><br><span class="line">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">                     _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">                     _In_ LPWSTR    lpCmdLine,</span><br><span class="line">                     _In_ int       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    // 1、注册窗口类</span><br><span class="line">    TCHAR Name[] = L&quot;My First Window&quot;;</span><br><span class="line">    WNDCLASS wnd = &#123; 0 &#125;;</span><br><span class="line">    wnd.lpfnWndProc = WndProc;          // 回调函数</span><br><span class="line">    wnd.lpszClassName = Name;           // 类名</span><br><span class="line">    wnd.hInstance = hInstance;         // 进程句柄</span><br><span class="line">    wnd.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // 背景色(白色)</span><br><span class="line">    wnd.hCursor = LoadCursor(NULL, IDC_ARROW);   // 箭头光标</span><br><span class="line">    RegisterClass(&amp;wnd);</span><br><span class="line"></span><br><span class="line">    // 2、创建窗口</span><br><span class="line">    HWND hwnd = CreateWindow(</span><br><span class="line">        Name,                   // 类名</span><br><span class="line">        TEXT(&quot;我的Win32窗口&quot;),          // 窗口标题</span><br><span class="line">        WS_OVERLAPPEDWINDOW,     // 标准窗口样式</span><br><span class="line">        CW_USEDEFAULT,     // 初始水平位置（默认居中）</span><br><span class="line">        CW_USEDEFAULT,      // 初始垂直位置</span><br><span class="line">        500,                // 宽度500px</span><br><span class="line">        300,                // 高度300px</span><br><span class="line">        NULL,       // 父窗口</span><br><span class="line">        NULL,       // 菜单</span><br><span class="line">        hInstance,  // 实例句柄</span><br><span class="line">        NULL</span><br><span class="line">        );</span><br><span class="line">    if (hwnd == NULL) &#123;</span><br><span class="line">        MessageBoxW(NULL, L&quot;窗口创建失败!&quot;, L&quot;错误&quot;, MB_OK | MB_ICONERROR);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 显示窗口</span><br><span class="line">    ShowWindow(hwnd, SW_SHOW); // 显示窗口</span><br><span class="line">   </span><br><span class="line">    // 4. 消息循环</span><br><span class="line">    MSG msg;</span><br><span class="line">    while (GetMessage(&amp;msg, NULL, 0, 0) &gt; 0) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg); // 转换键盘消息</span><br><span class="line">        DispatchMessage(&amp;msg);  // 分发到窗口过程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  </span><br><span class="line">函数: WndProc(HWND, UINT, WPARAM, LPARAM)</span><br><span class="line">目标: 处理主窗口的消息。</span><br><span class="line">*/ </span><br><span class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">    switch (message)</span><br><span class="line">    &#123;</span><br><span class="line">        case WM_CREATE:</span><br><span class="line">        &#123;</span><br><span class="line">            CREATESTRUCT* info = (CREATESTRUCT*)lParam;</span><br><span class="line">            DebugLogW(L&quot;窗口创建成功，窗口类名为%s\n&quot;, info-&gt;lpszClass);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_MOVE:</span><br><span class="line">        &#123;</span><br><span class="line">            POINTS point = MAKEPOINTS(lParam);</span><br><span class="line">            DebugLogA(&quot;窗口移动到了(%d,%d)\n&quot;, point.x, point.y);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_LBUTTONDOWN:</span><br><span class="line">        &#123;</span><br><span class="line">            POINTS point2 = MAKEPOINTS(lParam);</span><br><span class="line">            DebugLogA(&quot;按下了左键,坐标为(%d,%d)\n&quot;, point2.x, point2.y);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        case WM_KEYDOWN:</span><br><span class="line">            DebugLogA(&quot;按下了键盘，wParam：%#x，lParam：%#x\n&quot;, wParam, lParam);</span><br><span class="line">            return 0;</span><br><span class="line">        case WM_CLOSE:</span><br><span class="line">            DebugLogA(&quot;关闭窗口\n&quot;);</span><br><span class="line">            DestroyWindow(hWnd); // 销毁窗口</span><br><span class="line">            return 0;</span><br><span class="line">        case WM_DESTROY:</span><br><span class="line">            DebugLogA(&quot;销毁窗口\n&quot;);</span><br><span class="line">            PostQuitMessage(0);   // 关闭程序</span><br><span class="line">            return 0;</span><br><span class="line">        default:</span><br><span class="line">            return DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息类型："><a href="#消息类型：" class="headerlink" title="消息类型："></a>消息类型：</h2><h3 id="WM-CREATE-窗口创建通知"><a href="#WM-CREATE-窗口创建通知" class="headerlink" title="WM_CREATE - 窗口创建通知"></a><strong>WM_CREATE</strong> - 窗口创建通知</h3><p>代表窗口创建成功。</p>
<ul>
<li><p><em>wParam</em></p>
<p>未使用此参数。</p>
</li>
<li><p><em>lParam</em></p>
<p>指向CREATESTRUCTA 结构的指针，该结构包含有关所创建窗口的信息。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagCREATESTRUCT &#123;</span><br><span class="line">  LPVOID    lpCreateParams;  // 创建时传递的额外参数</span><br><span class="line">  HINSTANCE hInstance;       // 程序实例句柄</span><br><span class="line">  HMENU     hMenu;           // 菜单句柄或控件ID</span><br><span class="line">  HWND      hwndParent;      // 父窗口句柄</span><br><span class="line">  int       cy;              // 初始高度</span><br><span class="line">  int       cx;              // 初始宽度</span><br><span class="line">  int       y;               // 初始Y位置</span><br><span class="line">  int       x;               // 初始X位置</span><br><span class="line">  LONG      style;           // 窗口样式</span><br><span class="line">  LPCSTR    lpszName;        // 窗口标题（名称）</span><br><span class="line">  LPCSTR    lpszClass;       // 窗口类名</span><br><span class="line">  DWORD     dwExStyle;       // 扩展样式</span><br><span class="line">&#125; CREATESTRUCT;</span><br></pre></td></tr></table></figure>

<p>这个结构体信息与CreateWindow函数参数信息完全相同</p>
<h3 id="WM-MOVE-窗口移动通知"><a href="#WM-MOVE-窗口移动通知" class="headerlink" title="WM_MOVE - 窗口移动通知"></a><strong>WM_MOVE</strong> - 窗口移动通知</h3><ul>
<li><strong>wParam</strong>：未使用（值为0）</li>
<li><strong>lParam</strong>：包含新窗口位置的 坐标信息<ul>
<li>**LOWORD(lParam)**：屏幕坐标下的 X 位置</li>
<li>**HIWORD(lParam)**：屏幕坐标下的 Y 位置</li>
</ul>
</li>
</ul>
<p>可使用POINTS point &#x3D; MAKEPOINTS(lParam)来获取坐标</p>
<h3 id="WM-LBUTTONDOWN-鼠标左键按下"><a href="#WM-LBUTTONDOWN-鼠标左键按下" class="headerlink" title="WM_LBUTTONDOWN - 鼠标左键按下"></a>WM_LBUTTONDOWN - 鼠标左键按下</h3><ul>
<li><p><strong>wParam</strong>：<strong>修饰键状态标志</strong>（按位组合）</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>MK_LBUTTON</code></td>
<td align="center">0x0001</td>
<td align="center">鼠标左键按下状态</td>
</tr>
<tr>
<td align="center"><code>MK_RBUTTON</code></td>
<td align="center">0x0002</td>
<td align="center">鼠标右键按下状态</td>
</tr>
<tr>
<td align="center"><code>MK_SHIFT</code></td>
<td align="center">0x0004</td>
<td align="center">Shift键按下</td>
</tr>
<tr>
<td align="center"><code>MK_CONTROL</code></td>
<td align="center">0x0008</td>
<td align="center">Ctrl键按下</td>
</tr>
<tr>
<td align="center"><code>MK_MBUTTON</code></td>
<td align="center">0x0010</td>
<td align="center">鼠标中键按下</td>
</tr>
<tr>
<td align="center"><code>MK_XBUTTON1</code></td>
<td align="center">0x0020</td>
<td align="center">鼠标侧键1按下</td>
</tr>
<tr>
<td align="center"><code>MK_XBUTTON2</code></td>
<td align="center">0x0040</td>
<td align="center">鼠标侧键2按下</td>
</tr>
</tbody></table>
</li>
<li><p><strong>lParam</strong>：<strong>鼠标位置坐标</strong></p>
<ul>
<li>**LOWORD(lParam)**：X 坐标（相对于窗口客户区左上角）</li>
<li>**HIWORD(lParam)**：Y 坐标（相对于窗口客户区左上角）</li>
</ul>
</li>
</ul>
<h3 id="WM-KEYDOWN-键盘按键按下"><a href="#WM-KEYDOWN-键盘按键按下" class="headerlink" title="WM_KEYDOWN - 键盘按键按下"></a><strong>WM_KEYDOWN</strong> - 键盘按键按下</h3><ul>
<li><p><strong>wParam</strong>：<strong>虚拟键码</strong> (Virtual-Key Code) - 标识按下的物理键<br>常用虚拟键码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VK_SPACE  (32)    // 空格键</span><br><span class="line">VK_ESCAPE (27)    // Esc键</span><br><span class="line">VK_RETURN (13)    // Enter回车键</span><br><span class="line">VK_TAB    (9)     // Tab键</span><br><span class="line">VK_LEFT   (37)    // 左方向键</span><br><span class="line">VK_RIGHT  (39)    // 右方向键</span><br><span class="line">VK_UP     (38)    // 上方向键</span><br><span class="line">VK_DOWN   (40)    // 下方向键</span><br><span class="line">&#x27;A&#x27;-&#x27;Z&#x27;   (65-90) // 字母键</span><br><span class="line">&#x27;0&#x27;-&#x27;9&#x27;   (48-57) // 数字键</span><br><span class="line">F1-F24    (112-135) // 功能键</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>lParam</strong>：<strong>按键状态和重复信息</strong>（32位，按位解析）：</p>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">说明</th>
<th align="center">获取方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0-15</td>
<td align="center">重复计数（连续按下的次数）</td>
<td align="center"><code>LOBYTE(LOWORD(lParam))</code></td>
</tr>
<tr>
<td align="center">16-23</td>
<td align="center">扫描码（硬件相关）</td>
<td align="center"><code>HIWORD(lParam) &amp; 0xFF</code></td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">扩展键标志（1&#x3D;小键盘&#x2F;扩展键）</td>
<td align="center"><code>(lParam &amp; 0x01000000) ? true : false</code></td>
</tr>
<tr>
<td align="center">25-28</td>
<td align="center">保留</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">上下文键状态（1&#x3D;Alt键按下）</td>
<td align="center"><code>(lParam &amp; 0x20000000) ? true : false</code></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">前一个键状态（1&#x3D;之前已按下）</td>
<td align="center"><code>(lParam &amp; 0x40000000) ? true : false</code></td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">转换状态（0&#x3D;按下，1&#x3D;释放）</td>
<td align="center"><code>(lParam &amp; 0x80000000) ? false : true</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="WM-CLOSE-窗口关闭请求"><a href="#WM-CLOSE-窗口关闭请求" class="headerlink" title="WM_CLOSE - 窗口关闭请求"></a><strong>WM_CLOSE</strong> - 窗口关闭请求</h3><ul>
<li><strong>wParam</strong>：未使用（值为0）</li>
<li><strong>lParam</strong>：未使用（值为0）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/27450/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/27450/" class="post-title-link" itemprop="url">字符集与编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-19 20:47:18" itemprop="dateCreated datePublished" datetime="2025-07-19T20:47:18+08:00">2025-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-21 14:18:53" itemprop="dateModified" datetime="2025-07-21T14:18:53+08:00">2025-07-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>字符集是一个预定义的字符集合，每个字符被分配一个唯一的编号，称为码点。字符集类似于一个字典，将字符资源进行编号。</p>
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>ASCII（美国信息交换标准码）是最早出现的字符集，包含 128 个字符（0-127），包括英文大小写字母、数字、标点及控制字符（如换行符）。它将给这些字符分配码点，例如A的码点是 65。</p>
<p>ASCII字符集设计初衷只是为了美国使用，仅支持英文、数字及基本符号，世界上其他语言或表情符号无法用ASCII字符集来表示，于是后续出现了许多扩展字符集。</p>
<h2 id="本地化字符集："><a href="#本地化字符集：" class="headerlink" title="本地化字符集："></a>本地化字符集：</h2><p>为了解决ASCII字符集的局限性，各国开发了扩展字符集，以支持他们的语言和地区需求：</p>
<h3 id="GB2312-GBK："><a href="#GB2312-GBK：" class="headerlink" title="GB2312&#x2F;GBK："></a>GB2312&#x2F;GBK：</h3><p>GB2312是中国在1981年发布的国家标准，旨在收录大部分常用的中文字符。GBK是中国于1995年发布的字符集，兼容前面的GB2312，是对GB2312的扩充。</p>
<p>GBK作为ASCII的扩展字符集，完全兼容于ASCII。</p>
<h2 id="Unicode："><a href="#Unicode：" class="headerlink" title="Unicode："></a>Unicode：</h2><p>由于各国都使用了各自的本地化字符集，这些字符集各有冲突，互不兼容，可能一个码点在不同地区表示不同的字符，于是同一文件在不同地区打开可能出现乱码，单一编码也无法同时支持多语言（如中文 + 阿拉伯文 + 表情符号）。</p>
<p>在1991年，国际组织尝试将世界上所有语言符号（如汉字和表情）编在同一个字符集中，每一个字符分配全球唯一的一个码点，以解决互不兼容的问题。例如汉字“你”的码点是U+4F60。</p>
<p>Unicode目前一共U+0000~U+10FFFF的码位区（其中有一部分作为保留区，不分配给字符）。其中U+0000<code>~</code>U+FFFF包含绝大多数常用字符（拉丁字母、汉字、日韩文、标点等）；U+10000<code>~</code>U+10FFFF包含生僻汉字、历史文字、表情符号、专业符号等。</p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>编码是将字符的码点转换为二进制数据（字节序列）的规则，是上述字符集在计算中存储和传输的方式。</p>
<h2 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h2><p>使用1字节定长二进制数来表示ASCII字符集里面的字符。8比特中第一个比特置为0，后7个比特使用字符的码点。</p>
<h2 id="ANSI编码："><a href="#ANSI编码：" class="headerlink" title="ANSI编码："></a>ANSI编码：</h2><p>ANSI编码是指本地化的扩展ASCII编码，在Win32编程中，窄字符（char）就使用这种编码方式。</p>
<p>常用的ANSI编码有GBK编码，这是对GBK字符集的具体实现，此编码方式完全兼容于ASCII编码，属于变长编码方式。</p>
<ul>
<li>0~127个字符与ASCII完全相同，使用一个字节表示</li>
<li>绝大多数的汉字等扩展字符使用2字节来表示， 首字节在 <code>0x81</code> 到 <code>0xFE</code> (十进制 129 到 254) 之间，第二字节在 <code>0x40</code> 到 <code>0xFE</code> (十进制 64 到 254) 之间。</li>
</ul>
<p>Windows在不同的地区采用了不同的本地化字符，例如在中国大陆，使用GBK。GBK的优点是在中文环境下编码效率相对较高，仅需两个字节即可表示一个中文字符。但是不同地区的字符集和编码方式不同，并且Linux等其他系统使用的是utf-8，所以在跨地区或跨系统时，GBK不兼容。</p>
<h2 id="Unicode-编码："><a href="#Unicode-编码：" class="headerlink" title="Unicode 编码："></a>Unicode 编码：</h2><p>此类编码是对Unicode 字符集的实现，包括utf-8、utf-16、utf-32，其中utf-8是里面编码效率最高的，也是目前国际实际的标准。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8是可变长编码，之所以要选择可变长，是为了增加编码效率，让常用的字符占尽量少的字节，同时又要实现Unicode的全包含 ，以达到全球兼容的目的。</p>
<p>UTF-8采用了从1~4字节的不等编码，变长编码需要解决的主要问题是如何划定一个字符的结束位置，UTF-8给出的方案是将Unicode 字符集划分为4个范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">码点范围            | 字节布局</span><br><span class="line">U+0000 ~ U+007F    | 0xxxxxxx</span><br><span class="line">U+0080 ~ U+07FF    | 110xxxxx 10xxxxxx</span><br><span class="line">U+0800 ~ U+FFFF    | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">U+10000 ~ U+10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>

<p>其中码点在U+0000 ~ U+007F  的占一个字节，与ASCII完全兼容，所以以前使用ASCII的程序在UTF-8的环境下也能正常运行。每一个字符的第一个字节前面有几个比特连续的1，就代表这个字符由多少字节组成，首字节后的字节前两个比特都是“10”，是为了与ASCII字符区分出来。去掉首字符与后续字符的前缀，得到的比特位拼接在一起形成的二进制数在数值上等同于该字符Unicode 中的码点。</p>
<p>假设已知一个字符，需要将其编码为UTF-8，正确流程是：</p>
<ol>
<li>获取字符在Unicode 中的码点</li>
<li>判断该码点落在哪个范围内，以确定由几个字节组成及其字节前缀</li>
<li>将码点转化为二进制数，从右往左填充除前缀外的位置（上面的”x”），得到的就是UTF-8编码</li>
</ol>
<p>而解码则是：</p>
<ol>
<li>读取首字节，判断前几个比特位为1，代表该字符由几个字节组成</li>
<li>这几个字节的转化为二进制，前缀去掉，将剩余比特位拼接位二进制数，此即是其码点</li>
</ol>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 是可变长编码，字符的编码方式根据码点的范围决定。常见字符使用 2 字节表示，而超出该范围的字符（如表情符号）需要使用 4 字节，通过代理对（surrogate pairs）来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">U+0000~U+FFFF： 直接存储 0000~FFFF</span><br><span class="line"></span><br><span class="line">U+10000~U+10FFFF：由高位代理（2字节，起标识作用）和低位代理（2字节）组成的4字节代理对表示</span><br><span class="line">高位代理范围：0xD800~0xDBFF</span><br><span class="line">低位代理范围：0xDC00~0xDFFF</span><br><span class="line">这两个代理区是Unicode为UTF-16专门预留的空间，不可用作任何字符的码点！！！</span><br><span class="line">编码过程（例如码点为U+10437）：</span><br><span class="line">0x10437 - 0x10000 = 0x437  ---------得到一个00000~FFFFF共20位的值</span><br><span class="line">0x437 &gt;&gt; 10 = 0x1          ---------前10比特作为高位代理的偏移</span><br><span class="line">0x437 &amp; 0x3FF = 0x37	   ---------后10比特作为低位代理的偏移</span><br><span class="line">最后组成的代理对为：0xD801-0XDC37</span><br></pre></td></tr></table></figure>

<p>UTF-16是UTF-8和UTF-32的平衡与兼容，对于常用文字（包括中文），使用两字节来表示；对于不常用符号，使用4字节来表示。UTF-16较多的使用在Windows系统中</p>
<h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>UTF-32是定长编码，规定使用4字节来表示Unicode 中的所有字符。由于Unicode的码点范围为U+0~U+10FFFF，故仅需要21位比特即可完全表示，4字节完全够用。所以UTF-32采用了直接映射的方式，即令UTF-32编码在数值上等同于字符的码点。Linux系统中一般使用UTF-32编码。</p>
<h1 id="编译器与编码"><a href="#编译器与编码" class="headerlink" title="编译器与编码"></a>编译器与编码</h1><h2 id="“窄”与“宽”："><a href="#“窄”与“宽”：" class="headerlink" title="“窄”与“宽”："></a>“窄”与“宽”：</h2><p>窄字符编码是指<strong>使用单字节（<code>char</code>）存储文本的变长编码方案</strong>。包括UTF-8、GBK、ANSI、ASCII。窄字符编码并不是一个固定的编码方式，而是指一种字符表示方式，有如下特点：</p>
<ul>
<li>使用char类型存储字符</li>
<li>通常是不定长编码</li>
<li>是字节流编码，即基本单位是字节</li>
</ul>
<p>宽字符编码是指<strong>使用多字节(wchar_t)存储文本的定长编码方案。</strong>包括UTF-16，UTF-32。有如下特点：</p>
<ul>
<li>使用wchar_t类型存储字符</li>
<li>通常是定长编码</li>
<li>是字符流编码，即基本单位是字符（操作以字符为单位）</li>
</ul>
<h2 id="不同操作系统、编译器中窄字符与宽字符编码方式"><a href="#不同操作系统、编译器中窄字符与宽字符编码方式" class="headerlink" title="不同操作系统、编译器中窄字符与宽字符编码方式"></a>不同操作系统、编译器中窄字符与宽字符编码方式</h2><table>
<thead>
<tr>
<th></th>
<th>MSVC</th>
<th>GCC</th>
</tr>
</thead>
<tbody><tr>
<td>Windows(窄字符char)</td>
<td>默认输出文件编码为本地编码(中国是GBK)</td>
<td>默认输出文件编码为UTF-8</td>
</tr>
<tr>
<td>Windows(宽字符wchar_t)</td>
<td>固定输出文件编码为UTF-16</td>
<td>固定输出文件编码为UTF-16</td>
</tr>
<tr>
<td>Linux\macOS(窄字符char)</td>
<td>不使用MSVC</td>
<td>默认输出文件编码为UTF-8</td>
</tr>
<tr>
<td>Linux\macOS(宽字符wchar_t)</td>
<td>不使用MSVC</td>
<td>默认输出文件编码为UTF-32</td>
</tr>
</tbody></table>
<ol>
<li>在Windows（中国区）中，默认终端是GBK，MSVC编译器源文件默认识别为GBK，GCC源文件默认识别为UTF-8；       					而Linux里，默认终端、GCC默认源文件都是UTF-8文件；</li>
<li>GCC编译时若要指定源文件的编码为GBK，则需要使用“-finput-charset&#x3D;GBK”参数；若要指定输出文件中窄字符的编码为GBK，则需要使用“-fexec-charset&#x3D;GBK”参数。</li>
<li>源文件使用的编码方式影响的是<strong>编译器如何解析字符串文本</strong>，但最终生成的 <code>.exe</code> 文件中字符串的编码方式由 <code>-fexec-charset</code> 或其他机制决定，两者并无必然一致关系。</li>
<li>窄字符转化过程：假设的源文件为GBK，要输出的exe文件为utf-8，那么编译器会先将窄字符GBK解码为字符对应的Unicode码点，然后再将Unicode码点编码为utf-8，最后保存在exe文件中的是字符的utf-8编码形式。此时，若要在终端上打印，则终端会按默认编码（GBK）来解释窄字符，这样就会导致打印乱码。</li>
<li>宽字符转化过程：假设源文件为 GBK 编码，编译器会先将源文件内容解码为 Unicode 字符码点。对于宽字符文本（如 <code>L&quot;你好&quot;</code>），会将这些字符编码为目标平台的宽字符格式（Windows 为 UTF-16，Linux 为 UTF-32），并将这些宽字符序列保存在 <code>.exe</code> 文件中。</li>
<li>编译器在碰到无法正常识别的窄字符时，会直接将原字节照抄到exe文件中，不进行编码转换。因此如果源文件为gbk，但Gcc默认识别utf-8，则编译器识别错误，直接把窄字符在源文件中的字节复制到exe文件里面，由于终端是gbk，所以刚好能被终端识别，打印出正常的字符；</li>
<li>编译器在碰到无法正常识别的宽字符时，会直接编译失败。</li>
<li>终端本质上是按字节流工作的设备，因此在使用 <code>wprintf</code> 输出宽字符时，底层需要将宽字符编码为终端所支持的窄字符流。若当前进程没有设置正确的 <code>locale</code>（如默认是 <code>&quot;C&quot;</code>），那么字符转换会失败或退化为 ASCII，从而导致中文等字符无法正确打印。因此，在使用宽字符时，务必调用 <code>setlocale(LC_CTYPE, &quot;&quot;)</code> 来启用当前系统的本地编码设置。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/522/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/522/" class="post-title-link" itemprop="url">DLL注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-15 12:50:29" itemprop="dateCreated datePublished" datetime="2025-07-15T12:50:29+08:00">2025-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-21 14:18:53" itemprop="dateModified" datetime="2025-07-21T14:18:53+08:00">2025-07-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><p>DLL注入是一种将外部动态链接库（DLL）加载到目标进程地址空间并执行其代码的技术。其目的在于利用Windows提供的机制，在一个不属于自己的进程中强制加载并运行指定的代码。与导入表注入不同，DLL注入是强行将DLL加载进目标进程空间，不会改变原程序（不改变文件），不需要修改原程序的导入表，因此DLL注入只对此进程有效，而程序下一次运行产生的进程则不会受到影响。</p>
<p>每一个PE文件在运行时会获得操作系统分配的4GB的独立的、虚拟的空间，进程中的所有地址都是在这个空间中寻址，并且两个进程之间是独立的、分隔的，不会互相影响。而CreateRemoteThread函数可以在获取另一个进程句柄的条件下在另一个句柄中创建线程，因此，可以使用该函数在目标进程中创建一个线程，此线程运行LoadLibrary函数，将待注入DLL的路径作为参数传入，使LoadLibrary函数将待注入DLL注入进目标进程的空间中，进而触发DLL里面的DLLmain函数执行，完成我们需要的功能。但是正常来说我们无法获知目标进程中LoadLibrary函数的地址，并且目标进程中并没有存储DLL路径。于是我们需要使用API在目标进程中申请空间，写入DLL路径，将这个路径的地址作为LoadLibrary参数。由于LoadLibrary所在的DLL（kernel32.dll）在任何程序中都会加载，且是第一个被加载的模块，因此kernel32.dll会加载在它的ImageBase处，它在所有进程中的基址都相同，于是LoadLibrary函数在任何进程中的地址都相同，可用本进程的LoadLibrary地址当作目标进程LoadLibrary的地址。</p>
<h2 id="关键函数："><a href="#关键函数：" class="headerlink" title="关键函数："></a>关键函数：</h2><h3 id="1、CreateToolhelp32Snapshot"><a href="#1、CreateToolhelp32Snapshot" class="headerlink" title="1、CreateToolhelp32Snapshot"></a>1、CreateToolhelp32Snapshot</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateToolhelp32Snapshot(</span><br><span class="line">  DWORD dwFlags,        // 指定快照包含的内容。这里使用TH32CS_SNAPPROCESS获取所有进程信息</span><br><span class="line">  DWORD th32ProcessID   // 目标进程ID（某些标志需要，这里不需要，故设为0）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：创建系统快照（获取当前系统状态的只读视图）。</p>
<h3 id="2、Process32FirstW"><a href="#2、Process32FirstW" class="headerlink" title="2、Process32FirstW"></a>2、Process32FirstW</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI Process32FirstW(</span><br><span class="line">  HANDLE           hSnapshot,    // CreateToolhelp32Snapshot 返回的句柄(快照句柄)</span><br><span class="line">  LPPROCESSENTRY32W lppe          // 指向 PROCESSENTRY32W 结构的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取系统快照中的第一个进程信息。</p>
<p>结构体定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagPROCESSENTRY32W &#123;</span><br><span class="line">  DWORD     dwSize;              // 结构体大小（必须初始化）</span><br><span class="line">  DWORD     cntUsage;            // 保留字段</span><br><span class="line">  DWORD     th32ProcessID;       // 进程标识符(PID) -------有用</span><br><span class="line">  ULONG_PTR th32DefaultHeapID;   // 默认堆ID（已废弃）</span><br><span class="line">  DWORD     th32ModuleID;        // 模块ID（已废弃）</span><br><span class="line">  DWORD     cntThreads;          // 进程拥有的线程数</span><br><span class="line">  DWORD     th32ParentProcessID; // 父进程PID</span><br><span class="line">  LONG      pcPriClassBase;      // 线程基础优先级</span><br><span class="line">  DWORD     dwFlags;             // 保留字段</span><br><span class="line">  WCHAR     szExeFile[MAX_PATH]; // 可执行文件名（含扩展名）  --------有用</span><br><span class="line">&#125; PROCESSENTRY32W;</span><br></pre></td></tr></table></figure>

<h3 id="3、Process32NextW"><a href="#3、Process32NextW" class="headerlink" title="3、Process32NextW"></a>3、Process32NextW</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI Process32NextW(</span><br><span class="line">  HANDLE           hSnapshot,    // 快照句柄</span><br><span class="line">  LPPROCESSENTRY32W lppe          // 进程条目结构指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取快照中的下一个进程信息（需要在 <code>Process32FirstW</code>之后调用）</p>
<h3 id="4、OpenProcess"><a href="#4、OpenProcess" class="headerlink" title="4、OpenProcess"></a>4、<strong>OpenProcess</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">  DWORD dwDesiredAccess,  // 你希望获得的对目标进程的操作权限。</span><br><span class="line">  BOOL  bInheritHandle,   // 句柄继承选项。通常设为 FALSE（不继承）</span><br><span class="line">  DWORD dwProcessId       // 目标进程PID</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中dwDesiredAccess参数这里需要使用的权限有：</p>
<table>
<thead>
<tr>
<th>dwDesiredAccess参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PROCESS_CREATE_THREAD</td>
<td>允许在目标进程中创建远程线程（如 <code>CreateRemoteThread</code>）</td>
</tr>
<tr>
<td>PROCESS_QUERY_INFORMATION</td>
<td>获取进程基本信息</td>
</tr>
<tr>
<td>PROCESS_VM_OPERATION</td>
<td>执行虚拟内存操作（如 <code>VirtualAllocEx</code>、<code>VirtualFreeEx</code>）</td>
</tr>
<tr>
<td>PROCESS_VM_READ</td>
<td>读取目标进程内存（如 <code>ReadProcessMemory</code>）</td>
</tr>
<tr>
<td>PROCESS_VM_WRITE</td>
<td>写入目标进程内存（如 <code>WriteProcessMemory</code>）</td>
</tr>
</tbody></table>
<p><strong>功能</strong>：通过给出的进程PID获取进程句柄，是后续对进程注入的基础</p>
<h3 id="5、VirtualAllocEx"><a href="#5、VirtualAllocEx" class="headerlink" title="5、VirtualAllocEx"></a>5、<strong>VirtualAllocEx</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,        // 目标进程句柄</span><br><span class="line">  LPVOID lpAddress,       // 期望起始地址（通常为NULL）</span><br><span class="line">  SIZE_T dwSize,          // 分配区域大小</span><br><span class="line">  DWORD  flAllocationType,// 分配类型。通常为MEM_COMMIT，分配实际物理内存</span><br><span class="line">  DWORD  flProtect        // 内存保护标志。设为PAGE_READWRITE（需写入数据）</span><br><span class="line">);  // 返回值LPVOID代表指向任意类型的指针</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：向指定进程的虚拟地址空间中申请内存区域。分配失败返回NULL，成功时返回目标进程中分配的内存区域的起始地址（指针）。</p>
<h3 id="6、WriteProcessMemory"><a href="#6、WriteProcessMemory" class="headerlink" title="6、WriteProcessMemory"></a>6、<strong>WriteProcessMemory</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">  HANDLE  hProcess,              // 目标进程句柄</span><br><span class="line">  LPVOID  lpBaseAddress,         // 目标内存起始地址</span><br><span class="line">  LPCVOID lpBuffer,              // 本地数据缓冲区指针</span><br><span class="line">  SIZE_T  nSize,                 // 写入字节数</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten// 实际写入字节数（可置NULL）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：在指定进程内存中写入数据</p>
<h3 id="7、CreateRemoteThread"><a href="#7、CreateRemoteThread" class="headerlink" title="7、CreateRemoteThread"></a>7、<strong>CreateRemoteThread</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,        // 目标进程句柄</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpThreadAttributes, // 安全属性（通常NULL）</span><br><span class="line">  SIZE_T                dwStackSize,      // 初始栈大小（0=默认）</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,  // 线程函数地址（LoadLibrary指针）</span><br><span class="line">  LPVOID                 lpParameter,     // 线程参数（DLL路径在内存中的地址）</span><br><span class="line">  DWORD                  dwCreationFlags, // 创建标志（0=立即运行）</span><br><span class="line">  LPDWORD                lpThreadId       // 线程ID（可置NULL）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中参数lpStartAddress和lpParameter最重要</p>
<p><strong>功能</strong>：在目标进程中创建一个远程线程，线程从lpStartAddress处开始运行，并传入一个参数lpParameter。这里实际上就是在目标进程创建一个远程线程，把我的DLL路径作为参数传入，使线程在运行时使用LoadLibrary函数将我的DLL载入进程空间。</p>
<h3 id="8、WaitForSingleObject"><a href="#8、WaitForSingleObject" class="headerlink" title="8、WaitForSingleObject"></a>8、WaitForSingleObject</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI WaitForSingleObject(</span><br><span class="line">  HANDLE hHandle,      // 对象句柄（这里是线程句柄）</span><br><span class="line">  DWORD  dwMilliseconds // 超时时间（毫秒）,INFINITE代表无限等待直到结束</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：暂停当前线程的执行，持续检查 <code>hThread</code>线程的状态直到目标线程终止（进入 signaled 状态）才继续执行后续代码。</p>
<h3 id="9、VirtualFreeEx"><a href="#9、VirtualFreeEx" class="headerlink" title="9、VirtualFreeEx"></a>9、VirtualFreeEx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL VirtualFreeEx(</span><br><span class="line">  HANDLE hProcess,  // 目标进程句柄</span><br><span class="line">  LPVOID lpAddress,  // 要释放的内存起始地址</span><br><span class="line">  SIZE_T dwSize,     // 要释放的内存大小</span><br><span class="line">  DWORD  dwFreeType  // 释放类型（关键参数）。MEM_RELEASE为完全释放</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：释放目标进程空间</p>
<h3 id="10、EnumProcessModules"><a href="#10、EnumProcessModules" class="headerlink" title="10、EnumProcessModules"></a>10、EnumProcessModules</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL EnumProcessModules(</span><br><span class="line">  HANDLE  hProcess,      // 目标进程句柄</span><br><span class="line">  HMODULE *lphModule,    // 接收进程加载的模块句柄的数组</span><br><span class="line">  DWORD   cb,            // 数组缓冲区大小（字节）</span><br><span class="line">  LPDWORD lpcbNeeded     // 存储返回的实际的大小</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取指定进程加载的所有模块的句柄，存储在lphModule数组里面</p>
<h3 id="11、GetModuleFileNameExW"><a href="#11、GetModuleFileNameExW" class="headerlink" title="11、GetModuleFileNameExW"></a>11、GetModuleFileNameExW</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetModuleFileNameExW(</span><br><span class="line">  HANDLE  hProcess,     // 目标进程的句柄</span><br><span class="line">  HMODULE hModule,      // 模块句柄（NULL 表示进程主模块）</span><br><span class="line">  LPWSTR  lpFilename,   // 接收路径的缓冲区</span><br><span class="line">  DWORD   nSize         // 缓冲区大小（字符数）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：获取指定进程中某个模块（通常是 DLL ）的完整文件路径，返回写入的字符数。</p>
<h3 id="12、FreeLibrary"><a href="#12、FreeLibrary" class="headerlink" title="12、FreeLibrary"></a>12、FreeLibrary</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL FreeLibrary(</span><br><span class="line">  [in] HMODULE hLibModule   // 要释放的 DLL 模块句柄</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：卸载目标模块</p>
<h3 id="13、wcscmp"><a href="#13、wcscmp" class="headerlink" title="13、wcscmp"></a>13、wcscmp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int wcscmp(const wchar_t *str1, const wchar_t *str2);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：宽字符串的比较。返回值为0代表相等。</p>
<h3 id="14、FindWindow"><a href="#14、FindWindow" class="headerlink" title="14、FindWindow"></a>14、FindWindow</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWND FindWindow(</span><br><span class="line">    LPCTSTR lpClassName,  // 窗口类名（这里设为NULL）</span><br><span class="line">    LPCTSTR lpWindowName  // 窗口标题</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：通过窗口标题或取窗口句柄</p>
<p>返回值：返回窗口句柄</p>
<h3 id="15、GetWindowThreadProcessId"><a href="#15、GetWindowThreadProcessId" class="headerlink" title="15、GetWindowThreadProcessId"></a>15、GetWindowThreadProcessId</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetWindowThreadProcessId(</span><br><span class="line">    HWND    hWnd,        // 窗口句柄</span><br><span class="line">    LPDWORD lpdwProcessId// 接收进程ID的指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>作用：通过窗口句柄获取窗口PID</p>
<h1 id="主要逻辑："><a href="#主要逻辑：" class="headerlink" title="主要逻辑："></a>主要逻辑：</h1><h2 id="装载逻辑："><a href="#装载逻辑：" class="headerlink" title="装载逻辑："></a>装载逻辑：</h2><ol>
<li>使用CreateToolhelp32Snapshot获取进程快照</li>
<li>使用Process32FirstW获取第一个进程信息</li>
<li>使用循环和Process32NextW函数迭代进程信息，依次比对其中的可执行文件名，以此找到目标进程PID</li>
<li>使用OpenProcess函数获取目标进程句柄</li>
<li>使用VirtualAllocEx申请空间</li>
<li>使用WriteProcessMemory在申请的空间中写入自定义DLL的路径</li>
<li>使用CreateRemoteThread创建线程，参数lpStartAddress和lpParameter分别填LoadLibraryW函数指针（要转换为LPTHREAD_START_ROUTINE）和DLL路径的内存地址</li>
<li>在LoadLibrary将我们的DLL载入后，DLL中的DLLmain函数会执行</li>
<li>等待线程结束后，释放空间和句柄</li>
</ol>
<h3 id="卸载逻辑："><a href="#卸载逻辑：" class="headerlink" title="卸载逻辑："></a>卸载逻辑：</h3><ol>
<li>使用OpenProcess函数获取目标进程句柄</li>
<li>使用EnumProcessModules函数获取进程所有模块的句柄</li>
<li>使用GetModuleFileNameExW函数对句柄进行判断，找到目标DLL句柄</li>
<li>使用CreateRemoteThread创建线程，参数为FreeLibrary函数地址（要转换为LPTHREAD_START_ROUTINE）和DLL句柄</li>
<li>等待线程结束后，释放空间和句柄</li>
</ol>
<h1 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h1><p>注意：目标进程、注入进程、DLL必须都是同一个位数。32为dll无法注入到64位进程中，64位进程与32位进程中LoadLibrary函数地址不同，故不可用64位注入程序注入DLL进32位目标进程</p>
<p>注入程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include &lt;tlhelp32.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;shlwapi.h&gt;</span><br><span class="line">#include &lt;psapi.h&gt;</span><br><span class="line">DWORD FindPidByName(wchar_t *s)&#123;  // 通过进程名查找进程PID</span><br><span class="line">	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);</span><br><span class="line">	if (snapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;创建进程快照失败! 错误代码:&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">	PROCESSENTRY32W lppe= &#123;0&#125;;</span><br><span class="line">	lppe.dwSize = sizeof(PROCESSENTRY32W);</span><br><span class="line">	if(!Process32FirstW(snapshot,&amp;lppe))&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;无法枚举进程&quot; &lt;&lt; std::endl;</span><br><span class="line">        CloseHandle(snapshot);</span><br><span class="line">        return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	do&#123;</span><br><span class="line">		if(!wcscmp(s,lppe.szExeFile))&#123;</span><br><span class="line">			CloseHandle(snapshot);</span><br><span class="line">			return lppe.th32ProcessID;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;while(Process32NextW(snapshot,&amp;lppe));</span><br><span class="line">	CloseHandle(snapshot);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD FindPidByWindowsName(LPCWSTR WindowsName)&#123;  // 通过窗口名查找PID</span><br><span class="line">	HWND hwnd = FindWindowW(NULL,WindowsName);</span><br><span class="line">	if(hwnd)&#123;</span><br><span class="line">		DWORD PID=0;</span><br><span class="line">		GetWindowThreadProcessId(hwnd,&amp;PID);</span><br><span class="line">		return PID;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建远程线程加载dll</span><br><span class="line">void injection(DWORD pid,wchar_t path[])&#123;  // dll注入</span><br><span class="line">	// 1、打开进程</span><br><span class="line">	HANDLE phandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |</span><br><span class="line">        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,FALSE, pid);</span><br><span class="line">	if (!phandle) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;打开进程失败(代码：&quot;</span><br><span class="line">                  &lt;&lt; GetLastError() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 2、分配空间，写入dll路径</span><br><span class="line">	int size = (wcslen(path)+1)*sizeof(wchar_t);</span><br><span class="line">	LPVOID lpaddress = VirtualAllocEx(phandle, nullptr, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	if(!lpaddress)&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;申请空间失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	BOOL flag = WriteProcessMemory(phandle,lpaddress,path,size,NULL);</span><br><span class="line">	if(!flag)&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;写入失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 3、创建远程线程</span><br><span class="line">	HANDLE hThread = CreateRemoteThread(phandle,NULL,0,(LPTHREAD_START_ROUTINE)LoadLibraryW,lpaddress,0,NULL);</span><br><span class="line">	if(!hThread)&#123;</span><br><span class="line">		std::cerr &lt;&lt; &quot;线程创建失败&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 4、等待线程结束</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">	// 5、释放</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	VirtualFreeEx(phandle, lpaddress, size, MEM_RELEASE);</span><br><span class="line">	CloseHandle(phandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建远程线程卸载dll</span><br><span class="line">void unloadDll(DWORD pid,wchar_t path[])&#123;</span><br><span class="line">	// 1、打开进程</span><br><span class="line">	HANDLE phandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |</span><br><span class="line">        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,FALSE, pid);</span><br><span class="line">	if (!phandle) &#123;</span><br><span class="line">        std::wcerr &lt;&lt; &quot;打开进程失败(代码：&quot;</span><br><span class="line">                  &lt;&lt; GetLastError() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 3、获取进程加载的所有模块</span><br><span class="line">	HMODULE lphModule[1000];</span><br><span class="line">	DWORD dwsize;</span><br><span class="line">	BOOL flag = EnumProcessModules(phandle,lphModule,sizeof(lphModule),&amp;dwsize);</span><br><span class="line">	if(!flag)&#123;</span><br><span class="line">		CloseHandle(phandle);</span><br><span class="line">		std::cerr &lt;&lt; &quot;读取模块失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 4、寻找目标dll的句柄</span><br><span class="line">	int i;</span><br><span class="line">	wchar_t lpFilename[MAX_PATH];</span><br><span class="line">	for(i=0;;i++)&#123;</span><br><span class="line">		if(GetModuleFileNameExW(phandle,lphModule[i],lpFilename,MAX_PATH)==0)&#123;</span><br><span class="line">			CloseHandle(phandle);</span><br><span class="line">			std::cerr &lt;&lt; &quot;未找到此模块&quot; &lt;&lt; std::endl;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!_wcsicmp(path,lpFilename)) break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 5、生成线程，卸载dll</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	hThread = CreateRemoteThread(phandle,NULL,0,(LPTHREAD_START_ROUTINE)FreeLibrary,lphModule[i],0,NULL);</span><br><span class="line">	if(!hThread)&#123;</span><br><span class="line">		CloseHandle(phandle);</span><br><span class="line">		std::cerr &lt;&lt; &quot;打开线程失败&quot; &lt;&lt; std::endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 6、等待线程结束</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">	// 7、释放</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(phandle);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	wchar_t name[] = L&quot;target.exe&quot;;</span><br><span class="line">	DWORD PID = FindPidByName(name);</span><br><span class="line">	//const wchar_t WindowsName[] = L&quot;E:\\project\\target.exe&quot;;</span><br><span class="line">	// DWORD PID = FindPidByWindowsName(WindowsName);</span><br><span class="line">	if(PID == 0) return 0;</span><br><span class="line">	wchar_t path[] = L&quot;E:\\project\\DLL注入.dll&quot;;  // dll路径</span><br><span class="line">	injection(PID,path);</span><br><span class="line">	unloadDll(PID,path);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DLL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;dllmain.h&quot;</span><br><span class="line"></span><br><span class="line">int  add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APIENTRY DllMain(</span><br><span class="line">    HMODULE hModule, </span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">) &#123;</span><br><span class="line">    switch (ul_reason_for_call) &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH:</span><br><span class="line">            // 加载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已注入!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_PROCESS_DETACH:</span><br><span class="line">            // 卸载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已卸载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_ATTACH:</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_DETACH:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注入后：</p>
<img src="/posts/522/image-20250717221804965.png" class="" title="image-20250717221804965">

<p>卸载后：</p>
<img src="/posts/522/image-20250717221831532.png" class="" title="image-20250717221831532">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/30238/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/30238/" class="post-title-link" itemprop="url">Hook技术实现！</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-14 22:14:00 / 修改时间：20:36:33" itemprop="dateCreated datePublished" datetime="2025-07-14T22:14:00+08:00">2025-07-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Inline Hook的主要思路如下：</p>
<p>1、获取strcmp函数的地址</p>
<p>2、获取自定义函数的地址</p>
<p>3、取消strcmp函数地址保护</p>
<p>4、计算strcmp函数与自定义函数之间的偏移offset</p>
<p>5、修改strcmp函数头5个字节，改为jmp offset</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">int __cdecl my_strcmp(char s1[],char s2[])&#123;</span><br><span class="line">    printf(&quot;hook成功!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void hook()&#123; </span><br><span class="line">        // 取消函数地址保护</span><br><span class="line">        DWORD oldProtect;  // 旧保护属性</span><br><span class="line">        VirtualProtect((LPVOID)strcmp,0x1000,PAGE_EXECUTE_READWRITE,&amp;oldProtect);</span><br><span class="line"></span><br><span class="line">        // 获取函数地址</span><br><span class="line">        byte* funcAddr = (byte*)my_strcmp;</span><br><span class="line">        byte* strcmp_add = (byte*)strcmp;</span><br><span class="line"></span><br><span class="line">        // 跳转到自定义函数</span><br><span class="line">        __asm__ __volatile__ (</span><br><span class="line">    		&quot;movl %0, %%eax \n\t&quot;</span><br><span class="line">		    &quot;movl %1, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;subl %%eax, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;subl $5, %%ebx \n\t&quot;</span><br><span class="line">		    &quot;movb $0xe9, (%%eax) \n\t&quot;</span><br><span class="line">		    &quot;movl %%ebx, 1(%%eax)&quot;</span><br><span class="line">		    : /* 无输出操作数 */</span><br><span class="line">		    : &quot;r&quot; (strcmp_add), &quot;r&quot; (funcAddr)  // 输入操作数</span><br><span class="line">		    : &quot;eax&quot;, &quot;ebx&quot;, &quot;memory&quot;            // 破坏列表</span><br><span class="line">		);</span><br><span class="line">         DWORD floadprotect;</span><br><span class="line">         VirtualProtect((LPVOID)strcmp,0x1000,oldProtect,&amp;floadprotect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = hook();  // 使用全局变量调用，使该函数早于main函数执行</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char a[]=&quot;hello world&quot;;</span><br><span class="line">    char s[20];</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    if(!strcmp(a,s))</span><br><span class="line">        printf(&quot;right!\n&quot;);</span><br><span class="line">    else printf(&quot;wrong!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//77011C10</span><br></pre></td></tr></table></figure>

<p>Hook成功：</p>
<img src="/posts/30238/image-20250422225432814.png" class="" title="image-20250422225432814">

<h1 id="IAT-Hook"><a href="#IAT-Hook" class="headerlink" title="IAT Hook"></a>IAT Hook</h1><h2 id="留出交叉引用版"><a href="#留出交叉引用版" class="headerlink" title="留出交叉引用版"></a>留出交叉引用版</h2><p>流程：</p>
<ol>
<li>找到导入表开始位置</li>
<li>根据目标函数所在的dll的名字找到对应dll的导入表</li>
<li>根据函数名字找到对应的IAT表</li>
<li>取消IAT的地址保护，将地址修改为自定义函数</li>
<li>恢复地址保护</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">BYTE* SavedAddr = (BYTE*)MessageBoxA;  // 因为这里调用了目标函数，因此IDA中可以通过交叉引用找到全局变量，进而找到hook函数</span><br><span class="line">int WINAPI My_MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) &#123;</span><br><span class="line">    // 1. 修改参数</span><br><span class="line">    lpText = &quot;Hooked by IAT!&quot;;</span><br><span class="line"></span><br><span class="line">    // 2. 调用原始API</span><br><span class="line">    typedef int (WINAPI* OrigMsgBox)(HWND, LPCSTR, LPCSTR, UINT);</span><br><span class="line">    OrigMsgBox orig = (OrigMsgBox)SavedAddr; // SavedAddr是原始地址</span><br><span class="line">    return orig(hWnd, lpText, lpCaption, uType);</span><br><span class="line">&#125;</span><br><span class="line">int hook() &#123;</span><br><span class="line">    IMAGE_DOS_HEADER* dos;</span><br><span class="line">    IMAGE_FILE_HEADER* fheader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">    IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR * import;</span><br><span class="line">    HMODULE hMod = GetModuleHandle(NULL);</span><br><span class="line">    BYTE* base = (BYTE*)hMod;</span><br><span class="line">    BYTE* buffer = base;</span><br><span class="line">    dos = (IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    buffer += dos-&gt;e_lfanew + 4;</span><br><span class="line">    fheader = (IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_FILE_HEADER);</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    import = (IMAGE_IMPORT_DESCRIPTOR*)(base + oheader-&gt;DataDirectory[1].VirtualAddress);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0;; i++) &#123;</span><br><span class="line">        if ((import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0)</span><br><span class="line">            || (!strcmp((char*)(base + import[i].Name), &quot;USER32.dll&quot;))) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0) &#123;  // 寻找目标dll</span><br><span class="line">        printf(&quot;未找到该dll，hook失败\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    IMAGE_THUNK_DATA32 * IAT = (IMAGE_THUNK_DATA32*)(base + import[i].FirstThunk);</span><br><span class="line">    IMAGE_THUNK_DATA32 * INT = (IMAGE_THUNK_DATA32*)(base + import[i].OriginalFirstThunk);</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        DWORD address = IAT[j].u1.Function;</span><br><span class="line">        if (address == 0) &#123;</span><br><span class="line">            printf(&quot;未找到该函数!!!\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (address == (DWORD)SavedAddr) break;  // 这里使用地址寻找目标函数</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD my_func_add = (DWORD)My_MessageBoxA;</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    VirtualProtect(IAT + j, 4, PAGE_READWRITE, &amp;oldProtect);    // 取消地址保护</span><br><span class="line">    IAT[j].u1.Function = my_func_add;</span><br><span class="line">    VirtualProtect(IAT + j, 4, oldProtect, &amp;oldProtect);   // 恢复地址保护</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = hook();  // 使用全局变量调用，使该函数早于main函数执行</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MessageBoxA(NULL, &quot;This should be hooked&quot;, &quot;Original MessageBox&quot;, MB_OK);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="隐藏交叉引用版"><a href="#隐藏交叉引用版" class="headerlink" title="隐藏交叉引用版:"></a>隐藏交叉引用版:</h2><p>相比于上面这种方法，接下来这个方法只是在寻找原函数IAT位置时不使用地址判断，而是改为使用函数名判断；并且保留原函数地址时不直接引用原函数，而是获取IAT修改之前的值。这样一来，就无法通过交叉引用找到自定义函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">DWORD SavedAddr;</span><br><span class="line">int WINAPI My_MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) &#123;</span><br><span class="line">    // 1. 修改参数</span><br><span class="line">    lpText = &quot;Hooked by IAT!&quot;;</span><br><span class="line"></span><br><span class="line">    // 2. 调用原始API</span><br><span class="line">    typedef int (WINAPI* OrigMsgBox)(HWND, LPCSTR, LPCSTR, UINT);</span><br><span class="line">    OrigMsgBox orig = (OrigMsgBox)SavedAddr; // SavedAddr是原始地址</span><br><span class="line">    return orig(hWnd, lpText, lpCaption, uType);</span><br><span class="line">&#125;</span><br><span class="line">int hook() &#123;</span><br><span class="line">    IMAGE_DOS_HEADER* dos;</span><br><span class="line">    IMAGE_FILE_HEADER* fheader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">    IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR * import;</span><br><span class="line">    HMODULE hMod = GetModuleHandle(NULL);</span><br><span class="line">    BYTE* base = (BYTE*)hMod;</span><br><span class="line">    BYTE* buffer = base;</span><br><span class="line">    dos = (IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    buffer += dos-&gt;e_lfanew + 4;</span><br><span class="line">    fheader = (IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_FILE_HEADER);</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">import = (IMAGE_IMPORT_DESCRIPTOR*)(base + oheader-&gt;DataDirectory[1].VirtualAddress);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0;; i++) &#123;</span><br><span class="line">        if ((import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0)</span><br><span class="line">            || (!strcmp((char*)(base + import[i].Name), &quot;USER32.dll&quot;))) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (import[i].OriginalFirstThunk == 0 &amp;&amp; import[i].FirstThunk == 0) &#123;</span><br><span class="line">        printf(&quot;未找到该dll，hook失败\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    IMAGE_THUNK_DATA32 * IAT = (IMAGE_THUNK_DATA32*)(base + import[i].FirstThunk);</span><br><span class="line">    IMAGE_THUNK_DATA32 * INT = (IMAGE_THUNK_DATA32*)(base + import[i].OriginalFirstThunk);</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if (INT[j].u1.Ordinal &gt;&gt; 31 == 1) continue;</span><br><span class="line">        char* s = (char*)(base + INT[j].u1.AddressOfData + 2);</span><br><span class="line">        if (INT[j].u1.AddressOfData == 0) &#123;</span><br><span class="line">            printf(&quot;未找到该函数!!!\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!strcmp(s, &quot;MessageBoxA&quot;)) break;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD my_func_add = (DWORD)My_MessageBoxA;</span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    SavedAddr = IAT[j].u1.Function;   // 因为这里并没有引用原函数，而是直接通过IAT表获取原函数地址，所以交叉引用无效</span><br><span class="line">    VirtualProtect(IAT + j, 4, PAGE_READWRITE, &amp;oldProtect);</span><br><span class="line">    IAT[j].u1.Function = my_func_add;</span><br><span class="line">    VirtualProtect(IAT + j, 4, oldProtect, &amp;oldProtect);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = hook();  // 使用全局变量调用，使该函数早于main函数执行</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MessageBoxA(NULL, &quot;This should be hooked&quot;, &quot;Original MessageBox&quot;, MB_OK);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/30238/image-20250714180609215.png" class="" title="image-20250714180609215">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/44489/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/44489/" class="post-title-link" itemprop="url">导入表注入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-12 16:19:51 / 修改时间：21:52:13" itemprop="dateCreated datePublished" datetime="2025-07-12T16:19:51+08:00">2025-07-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="DLLMain："><a href="#DLLMain：" class="headerlink" title="DLLMain："></a>DLLMain：</h1><p>DllMain是.dll文件的入口函数，当系统加载或卸载 DLL 时会自动调用它。它的参数为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(</span><br><span class="line">    _In_ HINSTANCE hinstDLL,   // DLL 模块句柄</span><br><span class="line">    _In_ DWORD     fdwReason,  // 调用原因标志</span><br><span class="line">    _In_ LPVOID    lpvReserved // 保留参数（通常为NULL）</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中fdwReason调用原因：</p>
<table>
<thead>
<tr>
<th align="left"><strong>标志值</strong></th>
<th align="left"><strong>触发时机</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DLL_PROCESS_ATTACH</strong></td>
<td align="left">DLL 首次被进程加载时</td>
</tr>
<tr>
<td align="left"><strong>DLL_PROCESS_DETACH</strong></td>
<td align="left">DLL 从进程卸载时</td>
</tr>
<tr>
<td align="left">DLL_THREAD_ATTACH</td>
<td align="left">新线程在进程中创建时</td>
</tr>
<tr>
<td align="left">DLL_THREAD_DETACH</td>
<td align="left">线程正常退出时</td>
</tr>
</tbody></table>
<p>于是，可以用类似这样的代码来让dll加载和卸载时运行我们的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain(</span><br><span class="line">    HMODULE hModule, </span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">) &#123;</span><br><span class="line">    switch (ul_reason_for_call) &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH:</span><br><span class="line">            // 加载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已加载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_PROCESS_DETACH:</span><br><span class="line">            // 卸载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 即将卸载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_ATTACH:</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_DETACH:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="导入表注入步骤："><a href="#导入表注入步骤：" class="headerlink" title="导入表注入步骤："></a>导入表注入步骤：</h1><h2 id="dll文件："><a href="#dll文件：" class="headerlink" title="dll文件："></a>dll文件：</h2><p>在DLLMain里面加入要实现的函数和一个导出函数（这个一定要有，不然exe在加载阶段会直接报错），生成dll，把dll与待注入文件放同一个目录</p>
<p>.h：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">	_declspec(dllexport) int __stdcall add(int a, int b);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>.c：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &quot;dllmain.h&quot;</span><br><span class="line"></span><br><span class="line">int __stdcall add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APIENTRY DllMain(</span><br><span class="line">    HMODULE hModule, </span><br><span class="line">    DWORD  ul_reason_for_call,</span><br><span class="line">    LPVOID lpReserved</span><br><span class="line">) &#123;</span><br><span class="line">    switch (ul_reason_for_call) &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH:</span><br><span class="line">            // 加载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 已加载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_PROCESS_DETACH:</span><br><span class="line">            // 卸载时调用MessageBox函数</span><br><span class="line">            MessageBox(NULL, L&quot;DLL 即将卸载!&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_ATTACH:</span><br><span class="line">            break;</span><br><span class="line">        case DLL_THREAD_DETACH:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注入程序："><a href="#注入程序：" class="headerlink" title="注入程序："></a>注入程序：</h2><p>注入程序的主要逻辑是:</p>
<ul>
<li>先创建一个新节（注意可写）</li>
<li>将所有导入表移动到新节中</li>
<li>创建一个新的导入表结构</li>
<li>创建导入表结构中的INT和IAT（可以共享同一张表）</li>
<li>修正导入表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">DWORD FOA_to_RVA(DWORD foa)&#123;</span><br><span class="line">    DWORD rva=0;</span><br><span class="line">    if(foa&lt;oheader-&gt;SizeOfHeaders) &#123;</span><br><span class="line">        rva = foa;</span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;fheader-&gt;NumberOfSections;i++)&#123;</span><br><span class="line">        if(foa&gt;=sheader[i].PointerToRawData&amp;&amp;foa&lt;(sheader[i].PointerToRawData+sheader[i].SizeOfRawData))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    int offset=foa-sheader[i].PointerToRawData;</span><br><span class="line">    rva = sheader[i].VirtualAddress + offset;</span><br><span class="line">    return rva;</span><br><span class="line">&#125;</span><br><span class="line">DWORD RVA_to_FOA(DWORD rva)&#123;</span><br><span class="line">    DWORD foa=0;</span><br><span class="line">    if(rva&lt;oheader-&gt;SizeOfHeaders) &#123;</span><br><span class="line">        foa = rva;</span><br><span class="line">        return foa;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;i&lt;fheader-&gt;NumberOfSections;i++)&#123;</span><br><span class="line">        if(rva&gt;=sheader[i].VirtualAddress&amp;&amp;rva&lt;(sheader[i].VirtualAddress+sheader[i].Misc.VirtualSize))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == fheader-&gt;NumberOfSections) &#123;printf(&quot;没有对应的FOA\n&quot;);return 0;&#125;</span><br><span class="line">    int offset=rva-sheader[i].VirtualAddress;</span><br><span class="line">    foa=sheader[i].PointerToRawData+offset;</span><br><span class="line">    return foa;</span><br><span class="line">&#125;</span><br><span class="line">int new_section(int new_size)&#123;  // 创建新节，参数：新节大小，返回值：是否成功创建</span><br><span class="line">    // 判断是否能加节表:</span><br><span class="line">    if(oheader-&gt;SizeOfHeaders-(dos-&gt;e_lfanew+4+sizeof(IMAGE_FILE_HEADER)+fheader-&gt;SizeOfOptionalHeader+fheader-&gt;NumberOfSections*sizeof(IMAGE_SECTION_HEADER))&lt;=80)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;空间不足以创建节表\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = fheader-&gt;NumberOfSections;</span><br><span class="line">    strcpy(sheader[index].Name,&quot;new&quot;);</span><br><span class="line">    sheader[index].Misc.VirtualSize = new_size;</span><br><span class="line">    sheader[index].VirtualAddress = sheader[index-1].VirtualAddress + ((sheader[index-1].Misc.VirtualSize)/oheader-&gt;SectionAlignment+1)*oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].PointerToRawData = sheader[index-1].PointerToRawData + sheader[index-1].SizeOfRawData;</span><br><span class="line">    sheader[index].SizeOfRawData = new_size;</span><br><span class="line">    sheader[index].Characteristics = 0xE00000A0;  // 可读可写可执行</span><br><span class="line">    sheader[index].PointerToRelocations = sheader[index-1].PointerToRelocations;</span><br><span class="line">    sheader[index].PointerToLinenumbers = sheader[index-1].PointerToLinenumbers;</span><br><span class="line">    sheader[index].NumberOfRelocations = sheader[index-1].NumberOfRelocations;</span><br><span class="line">    sheader[index].NumberOfLinenumbers = sheader[index-1].NumberOfLinenumbers;</span><br><span class="line">    fheader-&gt;NumberOfSections++;</span><br><span class="line">    oheader-&gt;SizeOfImage+=oheader-&gt;SectionAlignment;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">DWORD move_import(DWORD offset,unsigned char *file_buf)&#123;  // 移动导入表。参数1：偏移FOA；参数2：文件指针</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR* import = (IMAGE_IMPORT_DESCRIPTOR*)(file_buf+RVA_to_FOA(oheader-&gt;DataDirectory[1].VirtualAddress));</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0;;i++)&#123;  // 判断有多少个导入表</span><br><span class="line">        if(import[i].FirstThunk==0&amp;&amp;import[i].OriginalFirstThunk==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(file_buf+offset,file_buf+RVA_to_FOA(oheader-&gt;DataDirectory[1].VirtualAddress),i*sizeof(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line">    oheader-&gt;DataDirectory[1].VirtualAddress = FOA_to_RVA(offset);</span><br><span class="line">    offset +=i*sizeof(IMAGE_IMPORT_DESCRIPTOR);</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">DWORD add_import(DWORD offset,unsigned char *file_buf,char *s)&#123;  // 增加导入表。参数1：偏移FOA；参数2：文件指针；参数3：dll名字</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR* new_import = (IMAGE_IMPORT_DESCRIPTOR*)(file_buf+offset);</span><br><span class="line">    offset += 2*sizeof(IMAGE_IMPORT_DESCRIPTOR); // 还要留一个空表作结尾，故乘2</span><br><span class="line">    IMAGE_THUNK_DATA32 *INT,*IAT;  // 这里指的是FOA</span><br><span class="line">    new_import-&gt;OriginalFirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    INT = (IMAGE_THUNK_DATA32*)(file_buf+offset);</span><br><span class="line">    INT-&gt;u1.Ordinal = 0x80000001; // 设置为序号导入，序号为1</span><br><span class="line">    INT[1].u1.Ordinal = 0x0;  // 留一个空结构为结尾</span><br><span class="line">    offset += 8;</span><br><span class="line">    new_import-&gt;FirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    IAT = (IMAGE_THUNK_DATA32*)(file_buf+offset);</span><br><span class="line">    IAT-&gt;u1.Ordinal = 0x80000001;</span><br><span class="line">    IAT[1].u1.Ordinal = 0x0;</span><br><span class="line">    offset += 8;</span><br><span class="line">    strcpy((char *)(file_buf+offset),s); // 复制名字</span><br><span class="line">    new_import-&gt;Name = FOA_to_RVA(offset);</span><br><span class="line">    offset += strlen(s)+1;</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">DWORD add_import_name(DWORD offset,unsigned char *file_buf,char *s)&#123;  // 增加导入表。参数1：偏移FOA；参数2：文件指针；参数3：dll名字</span><br><span class="line">    IMAGE_IMPORT_DESCRIPTOR* new_import = (IMAGE_IMPORT_DESCRIPTOR*)(file_buf+offset);</span><br><span class="line">    offset += 2*sizeof(IMAGE_IMPORT_DESCRIPTOR); // 还要留一个空表作结尾，故乘2</span><br><span class="line">    IMAGE_THUNK_DATA32 *INT;  // 这里指的是FOA</span><br><span class="line">    new_import-&gt;OriginalFirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    new_import-&gt;FirstThunk = FOA_to_RVA(offset);</span><br><span class="line">    INT = (IMAGE_THUNK_DATA32*)(file_buf+offset);</span><br><span class="line">    offset+=8;  // 一个INT表加一个空表共8字节</span><br><span class="line">    INT-&gt;u1.AddressOfData = FOA_to_RVA(offset);</span><br><span class="line">    IMAGE_IMPORT_BY_NAME* by_name=(IMAGE_IMPORT_BY_NAME*)(file_buf+offset);</span><br><span class="line">    by_name-&gt;Hint = 1;</span><br><span class="line">    offset+=2;</span><br><span class="line">    char *fun=&quot;add&quot;;  // 函数名</span><br><span class="line">    strcpy((char *)(file_buf+offset),fun);</span><br><span class="line">    offset+=strlen(fun)+1;</span><br><span class="line">    strcpy((char *)(file_buf+offset),s); // 复制名字</span><br><span class="line">    new_import-&gt;Name = FOA_to_RVA(offset);</span><br><span class="line">    offset += strlen(s)+1;</span><br><span class="line">    return offset;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int new_size = 0x1000;  // 定义新节大小</span><br><span class="line">    const char* pe_path = &quot;testdll.exe&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    int fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize+new_size);   // 多分配0x1000用作新节</span><br><span class="line">    memset(file_buf, 0, fsize+new_size);</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *buffer=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    if(dos-&gt;e_magic!=0x5A4D) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=dos-&gt;e_lfanew;  // 定位文件头</span><br><span class="line">    if(*(DWORD*)buffer!=0x4550) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=4;</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer+=sizeof(IMAGE_FILE_HEADER);      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    if(!new_section(new_size))&#123;free(file_buf);return 0;&#125;</span><br><span class="line">    DWORD offset=sheader[fheader-&gt;NumberOfSections-1].PointerToRawData;</span><br><span class="line">    offset=move_import(offset,file_buf);</span><br><span class="line">    char *s=&quot;dllmain.dll&quot;;</span><br><span class="line">    offset = add_import(offset,file_buf,s);</span><br><span class="line">    // 写入新文件</span><br><span class="line">    FILE *new_file = fopen(&quot;new.exe&quot;,&quot;wb&quot;);</span><br><span class="line">    if (!new_file) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int written=fwrite(file_buf,sizeof(unsigned char),fsize+new_size,new_file);</span><br><span class="line">    if(written!=fsize+new_size)&#123;</span><br><span class="line">        perror(&quot;写入错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(new_file);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注入后目标程序在运行时就会弹出：</p>
<img src="/posts/44489/image-20250712190125481.png" class="" title="image-20250712190125481">

<p>在运行完成后就会弹出</p>
<img src="/posts/44489/image-20250712190454257.png" class="" title="image-20250712190454257">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/8809/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_2.gif">
      <meta itemprop="name" content="comhacker">
      <meta itemprop="description" content="位卑未敢忘忧国，事定犹须待阖棺">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/8809/" class="post-title-link" itemprop="url">添加节</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-12 15:06:00 / 修改时间：21:49:10" itemprop="dateCreated datePublished" datetime="2025-07-12T15:06:00+08:00">2025-07-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="添加节："><a href="#添加节：" class="headerlink" title="添加节："></a>添加节：</h1><p>创建新节：</p>
<ol>
<li>分配新空间</li>
<li>加节表，需要80字节空间（40字节节表，40字节空节表）</li>
<li>修改文件头中NumberOfSections，增加可选头sizeofimage</li>
<li>填充节表内容</li>
</ol>
<p>注意：节表中的VirtualSize是内存对齐前的大小，在添加节时，新节的内存起始偏移应该是最后一个节的RVA+(（VirtualSize&#x2F;内存对齐）+1)*内存对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">IMAGE_DOS_HEADER* dos;</span><br><span class="line">IMAGE_FILE_HEADER* fheader;</span><br><span class="line">IMAGE_OPTIONAL_HEADER32* oheader;</span><br><span class="line">IMAGE_SECTION_HEADER* sheader;</span><br><span class="line">int new_section(int new_size)&#123;  // 创建新节，参数：新节大小，返回值：是否成功创建</span><br><span class="line">    // 判断是否能加节表:</span><br><span class="line">    if(oheader-&gt;SizeOfHeaders-(dos-&gt;e_lfanew+4+sizeof(IMAGE_FILE_HEADER)+fheader-&gt;SizeOfOptionalHeader+fheader-&gt;NumberOfSections*sizeof(IMAGE_SECTION_HEADER))&lt;=80)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;空间不足以创建节表\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = fheader-&gt;NumberOfSections;</span><br><span class="line">    strcpy(sheader[index].Name,&quot;new&quot;);</span><br><span class="line">    sheader[index].Misc.VirtualSize = new_size;</span><br><span class="line">    sheader[index].VirtualAddress = sheader[index-1].VirtualAddress + ((sheader[index-1].Misc.VirtualSize)/oheader-&gt;SectionAlignment+1)*oheader-&gt;SectionAlignment;</span><br><span class="line">    sheader[index].PointerToRawData = sheader[index-1].PointerToRawData + sheader[index-1].SizeOfRawData;</span><br><span class="line">    sheader[index].SizeOfRawData = new_size;</span><br><span class="line">    sheader[index].Characteristics = 0xE00000A0;  // 可读可写可执行</span><br><span class="line">    sheader[index].PointerToRelocations = sheader[index-1].PointerToRelocations;</span><br><span class="line">    sheader[index].PointerToLinenumbers = sheader[index-1].PointerToLinenumbers;</span><br><span class="line">    sheader[index].NumberOfRelocations = sheader[index-1].NumberOfRelocations;</span><br><span class="line">    sheader[index].NumberOfLinenumbers = sheader[index-1].NumberOfLinenumbers;</span><br><span class="line">    fheader-&gt;NumberOfSections++;</span><br><span class="line">    oheader-&gt;SizeOfImage+=oheader-&gt;SectionAlignment;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int new_size = 0x1000;  // 定义新节大小</span><br><span class="line">    const char* pe_path = &quot;dlltest.dll&quot;;</span><br><span class="line">    FILE* pf=fopen(pe_path,&quot;rb&quot;);</span><br><span class="line">    if(!pf) &#123;printf(&quot;打开文件失败！！\n&quot;);return 0;&#125;</span><br><span class="line">    fseek(pf, 0, SEEK_END);</span><br><span class="line">    int fsize=ftell(pf);    </span><br><span class="line">    fseek(pf, 0, SEEK_SET); </span><br><span class="line">    unsigned char* file_buf=(unsigned char *)malloc(fsize+new_size);   // 多分配0x1000用作新节</span><br><span class="line">    fread(file_buf,1,fsize,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    unsigned char *buffer=file_buf;</span><br><span class="line">    dos=(IMAGE_DOS_HEADER*)buffer;</span><br><span class="line">    if(dos-&gt;e_magic!=0x5A4D) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=dos-&gt;e_lfanew;  // 定位文件头</span><br><span class="line">    if(*(DWORD*)buffer!=0x4550) &#123;printf(&quot;不是PE文件!!\n&quot;);free(file_buf);;return 0;&#125;</span><br><span class="line">    buffer+=4;</span><br><span class="line">    fheader=(IMAGE_FILE_HEADER*)buffer;</span><br><span class="line">    buffer+=sizeof(IMAGE_FILE_HEADER);      // 定位可选头</span><br><span class="line">    oheader = (IMAGE_OPTIONAL_HEADER32*)buffer;</span><br><span class="line">    buffer += sizeof(IMAGE_OPTIONAL_HEADER32);   // 定位节表</span><br><span class="line">    sheader = (IMAGE_SECTION_HEADER*)buffer;</span><br><span class="line">    if(!new_section(new_size))&#123;free(file_buf);return 0;&#125;</span><br><span class="line">    // 写入新文件中</span><br><span class="line">    FILE *new_file = fopen(&quot;new.dll&quot;,&quot;wb&quot;);</span><br><span class="line">    if (!new_file) &#123;</span><br><span class="line">        perror(&quot;文件打开失败&quot;);</span><br><span class="line">        free(file_buf);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int written=fwrite(file_buf,sizeof(unsigned char),fsize+new_size,new_file);</span><br><span class="line">    if(written!=fsize+new_size)&#123;</span><br><span class="line">        perror(&quot;写入错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(new_file);</span><br><span class="line">    free(file_buf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="comhacker"
      src="/images/avatar_2.gif">
  <p class="site-author-name" itemprop="name">comhacker</p>
  <div class="site-description" itemprop="description">位卑未敢忘忧国，事定犹须待阖棺</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">comhacker</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
